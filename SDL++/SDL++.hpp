#pragma once
// Autogenerated with ../gen.py

#include <SDL3/SDL.h>
#include <exception>
#include <string>
#include <unordered_map>
#include <memory>
#include <vector>

namespace SDL {

class Error : public std::exception
{
    const char* msg;
public:
    Error(const char* msg) : msg(msg) { }
    const char* what() const throw() { return msg; }
};

bool operator!(SDL_GUID id)
{
    for (size_t i = 0; i < 16; i++)
    {
        if (id.data[i] != 0) return false;
    }
    return true;
}

using Rect = SDL_Rect;
using FRect = SDL_FRect;
using Point = SDL_Point;
using FPoint = SDL_FPoint;

enum WindowFlags
{
    UTILITY = SDL_UINT64_C(0x0000000000020000),
    TRANSPARENT = SDL_UINT64_C(0x0000000040000000),
    MOUSE_RELATIVE_MODE = SDL_UINT64_C(0x0000000000008000),
    HIDDEN = SDL_UINT64_C(0x0000000000000008),
    OPENGL = SDL_UINT64_C(0x0000000000000002),
    MOUSE_CAPTURE = SDL_UINT64_C(0x0000000000004000),
    VULKAN = SDL_UINT64_C(0x0000000010000000),
    MINIMIZED = SDL_UINT64_C(0x0000000000000040),
    BORDERLESS = SDL_UINT64_C(0x0000000000000010),
    ALWAYS_ON_TOP = SDL_UINT64_C(0x0000000000010000),
    MAXIMIZED = SDL_UINT64_C(0x0000000000000080),
    INPUT_FOCUS = SDL_UINT64_C(0x0000000000000200),
    POPUP_MENU = SDL_UINT64_C(0x0000000000080000),
    NOT_FOCUSABLE = SDL_UINT64_C(0x0000000080000000),
    RESIZABLE = SDL_UINT64_C(0x0000000000000020),
    MOUSE_FOCUS = SDL_UINT64_C(0x0000000000000400),
    METAL = SDL_UINT64_C(0x0000000020000000),
    MODAL = SDL_UINT64_C(0x0000000000001000),
    HIGH_PIXEL_DENSITY = SDL_UINT64_C(0x0000000000002000),
    FULLSCREEN = SDL_UINT64_C(0x0000000000000001),
    KEYBOARD_GRABBED = SDL_UINT64_C(0x0000000000100000),
    TOOLTIP = SDL_UINT64_C(0x0000000000040000),
    EXTERNAL = SDL_UINT64_C(0x0000000000000800),
    MOUSE_GRABBED = SDL_UINT64_C(0x0000000000000100),
    OCCLUDED = SDL_UINT64_C(0x0000000000000004)
};

enum GlobFlags
{
    CASEINSENSITIVE = (1u << 0)
};

enum GPUTextureUsageFlags
{
    COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE = (1u << 6),
    SAMPLER = (1u << 0),
    COMPUTE_STORAGE_READ = (1u << 4),
    GRAPHICS_STORAGE_READ = (1u << 3),
    DEPTH_STENCIL_TARGET = (1u << 2),
    COLOR_TARGET = (1u << 1),
    COMPUTE_STORAGE_WRITE = (1u << 5)
};

enum InitFlags
{
    VIDEO = 0x00000020u,
    HAPTIC = 0x00001000u,
    CAMERA = 0x00010000u,
    GAMEPAD = 0x00002000u,
    JOYSTICK = 0x00000200u,
    EVENTS = 0x00004000u,
    SENSOR = 0x00008000u,
    AUDIO = 0x00000010u
};

enum MessageBoxFlags
{
    BUTTON_ESCAPEKEY_DEFAULT = 0x00000002u,
    WARNING = 0x00000020u,
    INFORMATION = 0x00000040u,
    BUTTONS_LEFT_TO_RIGHT = 0x00000080u,
    BUTTONS_RIGHT_TO_LEFT = 0x00000100u,
    ERROR = 0x00000010u,
    BUTTON_RETURNKEY_DEFAULT = 0x00000001u
};

enum TrayEntryFlags
{
    BUTTON = 0x00000001u,
    CHECKBOX = 0x00000002u,
    CHECKED = 0x40000000u,
    SUBMENU = 0x00000004u,
    DISABLED = 0x80000000u
};

namespace raw
{
//! @copydoc SDL_ReportAssertion()
inline SDL_AssertState ReportAssertion(SDL_AssertData* data, const char* func, const char* file, int line) { return SDL_ReportAssertion(data, func, file, line); }

//! @copydoc SDL_SetAssertionHandler()
inline void SetAssertionHandler(SDL_AssertionHandler handler, void* userdata) { SDL_SetAssertionHandler(handler, userdata); }

//! @copydoc SDL_GetDefaultAssertionHandler()
inline SDL_AssertionHandler GetDefaultAssertionHandler() { return SDL_GetDefaultAssertionHandler(); }

//! @copydoc SDL_GetAssertionHandler()
inline SDL_AssertionHandler GetAssertionHandler(void** puserdata) { return SDL_GetAssertionHandler(puserdata); }

//! @copydoc SDL_GetAssertionReport()
inline const SDL_AssertData* GetAssertionReport() { return SDL_GetAssertionReport(); }

//! @copydoc SDL_ResetAssertionReport()
inline void ResetAssertionReport() { SDL_ResetAssertionReport(); }

//! @copydoc SDL_AsyncIOFromFile()
inline SDL_AsyncIO* AsyncIOFromFile(const char* file, const char* mode) { auto _ret = SDL_AsyncIOFromFile(file, mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAsyncIOSize()
inline Sint64 GetAsyncIOSize(SDL_AsyncIO* asyncio) { auto _ret = SDL_GetAsyncIOSize(asyncio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ReadAsyncIO()
inline void ReadAsyncIO(SDL_AsyncIO* asyncio, void* ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue* queue, void* userdata) { auto _ret = SDL_ReadAsyncIO(asyncio, ptr, offset, size, queue, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteAsyncIO()
inline void WriteAsyncIO(SDL_AsyncIO* asyncio, void* ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue* queue, void* userdata) { auto _ret = SDL_WriteAsyncIO(asyncio, ptr, offset, size, queue, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CloseAsyncIO()
inline void CloseAsyncIO(SDL_AsyncIO* asyncio, bool flush, SDL_AsyncIOQueue* queue, void* userdata) { auto _ret = SDL_CloseAsyncIO(asyncio, flush, queue, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateAsyncIOQueue()
inline SDL_AsyncIOQueue* CreateAsyncIOQueue() { auto _ret = SDL_CreateAsyncIOQueue(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroyAsyncIOQueue()
inline void DestroyAsyncIOQueue(SDL_AsyncIOQueue* queue) { SDL_DestroyAsyncIOQueue(queue); }

//! @copydoc SDL_GetAsyncIOResult()
inline bool GetAsyncIOResult(SDL_AsyncIOQueue* queue, SDL_AsyncIOOutcome* outcome) { return SDL_GetAsyncIOResult(queue, outcome); }

//! @copydoc SDL_WaitAsyncIOResult()
inline bool WaitAsyncIOResult(SDL_AsyncIOQueue* queue, SDL_AsyncIOOutcome* outcome, Sint32 timeoutMS) { return SDL_WaitAsyncIOResult(queue, outcome, timeoutMS); }

//! @copydoc SDL_SignalAsyncIOQueue()
inline void SignalAsyncIOQueue(SDL_AsyncIOQueue* queue) { SDL_SignalAsyncIOQueue(queue); }

//! @copydoc SDL_LoadFileAsync()
inline void LoadFileAsync(const char* file, SDL_AsyncIOQueue* queue, void* userdata) { auto _ret = SDL_LoadFileAsync(file, queue, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_TryLockSpinlock()
inline bool TryLockSpinlock(SDL_SpinLock* lock) { return SDL_TryLockSpinlock(lock); }

//! @copydoc SDL_LockSpinlock()
inline void LockSpinlock(SDL_SpinLock* lock) { SDL_LockSpinlock(lock); }

//! @copydoc SDL_UnlockSpinlock()
inline void UnlockSpinlock(SDL_SpinLock* lock) { SDL_UnlockSpinlock(lock); }

//! @copydoc SDL_MemoryBarrierReleaseFunction()
inline void MemoryBarrierReleaseFunction() { SDL_MemoryBarrierReleaseFunction(); }

//! @copydoc SDL_MemoryBarrierAcquireFunction()
inline void MemoryBarrierAcquireFunction() { SDL_MemoryBarrierAcquireFunction(); }

//! @copydoc SDL_CompareAndSwapAtomicInt()
inline bool CompareAndSwapAtomicInt(SDL_AtomicInt* a, int oldval, int newval) { return SDL_CompareAndSwapAtomicInt(a, oldval, newval); }

//! @copydoc SDL_SetAtomicInt()
inline int SetAtomicInt(SDL_AtomicInt* a, int v) { return SDL_SetAtomicInt(a, v); }

//! @copydoc SDL_GetAtomicInt()
inline int GetAtomicInt(SDL_AtomicInt* a) { return SDL_GetAtomicInt(a); }

//! @copydoc SDL_AddAtomicInt()
inline int AddAtomicInt(SDL_AtomicInt* a, int v) { return SDL_AddAtomicInt(a, v); }

//! @copydoc SDL_CompareAndSwapAtomicU32()
inline bool CompareAndSwapAtomicU32(SDL_AtomicU32* a, Uint32 oldval, Uint32 newval) { return SDL_CompareAndSwapAtomicU32(a, oldval, newval); }

//! @copydoc SDL_SetAtomicU32()
inline Uint32 SetAtomicU32(SDL_AtomicU32* a, Uint32 v) { return SDL_SetAtomicU32(a, v); }

//! @copydoc SDL_GetAtomicU32()
inline Uint32 GetAtomicU32(SDL_AtomicU32* a) { return SDL_GetAtomicU32(a); }

//! @copydoc SDL_CompareAndSwapAtomicPointer()
inline bool CompareAndSwapAtomicPointer(void** a, void* oldval, void* newval) { return SDL_CompareAndSwapAtomicPointer(a, oldval, newval); }

//! @copydoc SDL_SetAtomicPointer()
inline void* SetAtomicPointer(void** a, void* v) { return SDL_SetAtomicPointer(a, v); }

//! @copydoc SDL_GetAtomicPointer()
inline void* GetAtomicPointer(void** a) { return SDL_GetAtomicPointer(a); }

//! @copydoc SDL_Swap16()
inline Uint16 Swap16(Uint16 x) { return SDL_Swap16(x); }

//! @copydoc SDL_Swap32()
inline Uint32 Swap32(Uint32 x) { return SDL_Swap32(x); }

//! @copydoc SDL_Swap64()
inline Uint64 Swap64(Uint64 x) { return SDL_Swap64(x); }

//! @copydoc SDL_SwapFloat()
inline float SwapFloat(float x) { return SDL_SwapFloat(x); }

//! @copydoc SDL_SetErrorV()
inline bool SetErrorV(const char* fmt, va_list ap) { return SDL_SetErrorV(fmt, ap); }

//! @copydoc SDL_OutOfMemory()
inline bool OutOfMemory() { return SDL_OutOfMemory(); }

//! @copydoc SDL_GetError()
inline const char* GetError() { return SDL_GetError(); }

//! @copydoc SDL_ClearError()
inline bool ClearError() { return SDL_ClearError(); }

//! @copydoc SDL_GetGlobalProperties()
inline SDL_PropertiesID GetGlobalProperties() { auto _ret = SDL_GetGlobalProperties(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateProperties()
inline SDL_PropertiesID CreateProperties() { auto _ret = SDL_CreateProperties(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CopyProperties()
inline void CopyProperties(SDL_PropertiesID src, SDL_PropertiesID dst) { auto _ret = SDL_CopyProperties(src, dst); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LockProperties()
inline void LockProperties(SDL_PropertiesID props) { auto _ret = SDL_LockProperties(props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UnlockProperties()
inline void UnlockProperties(SDL_PropertiesID props) { SDL_UnlockProperties(props); }

//! @copydoc SDL_SetPointerPropertyWithCleanup()
inline void SetPointerPropertyWithCleanup(SDL_PropertiesID props, const char* name, void* value, SDL_CleanupPropertyCallback cleanup, void* userdata) { auto _ret = SDL_SetPointerPropertyWithCleanup(props, name, value, cleanup, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetPointerProperty()
inline void SetPointerProperty(SDL_PropertiesID props, const char* name, void* value) { auto _ret = SDL_SetPointerProperty(props, name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetStringProperty()
inline void SetStringProperty(SDL_PropertiesID props, const char* name, const char* value) { auto _ret = SDL_SetStringProperty(props, name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetNumberProperty()
inline void SetNumberProperty(SDL_PropertiesID props, const char* name, Sint64 value) { auto _ret = SDL_SetNumberProperty(props, name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetFloatProperty()
inline void SetFloatProperty(SDL_PropertiesID props, const char* name, float value) { auto _ret = SDL_SetFloatProperty(props, name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetBooleanProperty()
inline void SetBooleanProperty(SDL_PropertiesID props, const char* name, bool value) { auto _ret = SDL_SetBooleanProperty(props, name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HasProperty()
inline bool HasProperty(SDL_PropertiesID props, const char* name) { return SDL_HasProperty(props, name); }

//! @copydoc SDL_GetPropertyType()
inline SDL_PropertyType GetPropertyType(SDL_PropertiesID props, const char* name) { return SDL_GetPropertyType(props, name); }

//! @copydoc SDL_GetPointerProperty()
inline void* GetPointerProperty(SDL_PropertiesID props, const char* name, void* default_value) { return SDL_GetPointerProperty(props, name, default_value); }

//! @copydoc SDL_GetStringProperty()
inline const char* GetStringProperty(SDL_PropertiesID props, const char* name, const char* default_value) { return SDL_GetStringProperty(props, name, default_value); }

//! @copydoc SDL_GetNumberProperty()
inline Sint64 GetNumberProperty(SDL_PropertiesID props, const char* name, Sint64 default_value) { return SDL_GetNumberProperty(props, name, default_value); }

//! @copydoc SDL_GetFloatProperty()
inline float GetFloatProperty(SDL_PropertiesID props, const char* name, float default_value) { return SDL_GetFloatProperty(props, name, default_value); }

//! @copydoc SDL_GetBooleanProperty()
inline bool GetBooleanProperty(SDL_PropertiesID props, const char* name, bool default_value) { return SDL_GetBooleanProperty(props, name, default_value); }

//! @copydoc SDL_ClearProperty()
inline void ClearProperty(SDL_PropertiesID props, const char* name) { auto _ret = SDL_ClearProperty(props, name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_EnumerateProperties()
inline void EnumerateProperties(SDL_PropertiesID props, SDL_EnumeratePropertiesCallback callback, void* userdata) { auto _ret = SDL_EnumerateProperties(props, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyProperties()
inline void DestroyProperties(SDL_PropertiesID props) { SDL_DestroyProperties(props); }

//! @copydoc SDL_CreateThreadRuntime()
inline SDL_Thread* CreateThreadRuntime(SDL_ThreadFunction fn, const char* name, void* data, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread) { auto _ret = SDL_CreateThreadRuntime(fn, name, data, pfnBeginThread, pfnEndThread); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateThreadWithPropertiesRuntime()
inline SDL_Thread* CreateThreadWithPropertiesRuntime(SDL_PropertiesID props, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread) { auto _ret = SDL_CreateThreadWithPropertiesRuntime(props, pfnBeginThread, pfnEndThread); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetThreadName()
inline const char* GetThreadName(SDL_Thread* thread) { return SDL_GetThreadName(thread); }

//! @copydoc SDL_GetCurrentThreadID()
inline SDL_ThreadID GetCurrentThreadID() { return SDL_GetCurrentThreadID(); }

//! @copydoc SDL_GetThreadID()
inline SDL_ThreadID GetThreadID(SDL_Thread* thread) { return SDL_GetThreadID(thread); }

//! @copydoc SDL_SetCurrentThreadPriority()
inline void SetCurrentThreadPriority(SDL_ThreadPriority priority) { auto _ret = SDL_SetCurrentThreadPriority(priority); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitThread()
inline void WaitThread(SDL_Thread* thread, int* status) { SDL_WaitThread(thread, status); }

//! @copydoc SDL_GetThreadState()
inline SDL_ThreadState GetThreadState(SDL_Thread* thread) { return SDL_GetThreadState(thread); }

//! @copydoc SDL_DetachThread()
inline void DetachThread(SDL_Thread* thread) { SDL_DetachThread(thread); }

//! @copydoc SDL_GetTLS()
inline void* GetTLS(SDL_TLSID* id) { auto _ret = SDL_GetTLS(id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetTLS()
inline void SetTLS(SDL_TLSID* id, const void* value, SDL_TLSDestructorCallback destructor) { auto _ret = SDL_SetTLS(id, value, destructor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CleanupTLS()
inline void CleanupTLS() { SDL_CleanupTLS(); }

//! @copydoc SDL_CreateMutex()
inline SDL_Mutex* CreateMutex() { auto _ret = SDL_CreateMutex(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_LockMutex()
inline void LockMutex(SDL_Mutex* mutex) { SDL_LockMutex(mutex); }

//! @copydoc SDL_TryLockMutex()
inline bool TryLockMutex(SDL_Mutex* mutex) { return SDL_TryLockMutex(mutex); }

//! @copydoc SDL_UnlockMutex()
inline void UnlockMutex(SDL_Mutex* mutex) { SDL_UnlockMutex(mutex); }

//! @copydoc SDL_DestroyMutex()
inline void DestroyMutex(SDL_Mutex* mutex) { SDL_DestroyMutex(mutex); }

//! @copydoc SDL_CreateRWLock()
inline SDL_RWLock* CreateRWLock() { auto _ret = SDL_CreateRWLock(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_LockRWLockForReading()
inline void LockRWLockForReading(SDL_RWLock* rwlock) { SDL_LockRWLockForReading(rwlock); }

//! @copydoc SDL_LockRWLockForWriting()
inline void LockRWLockForWriting(SDL_RWLock* rwlock) { SDL_LockRWLockForWriting(rwlock); }

//! @copydoc SDL_TryLockRWLockForReading()
inline bool TryLockRWLockForReading(SDL_RWLock* rwlock) { return SDL_TryLockRWLockForReading(rwlock); }

//! @copydoc SDL_TryLockRWLockForWriting()
inline bool TryLockRWLockForWriting(SDL_RWLock* rwlock) { return SDL_TryLockRWLockForWriting(rwlock); }

//! @copydoc SDL_UnlockRWLock()
inline void UnlockRWLock(SDL_RWLock* rwlock) { SDL_UnlockRWLock(rwlock); }

//! @copydoc SDL_DestroyRWLock()
inline void DestroyRWLock(SDL_RWLock* rwlock) { SDL_DestroyRWLock(rwlock); }

//! @copydoc SDL_CreateSemaphore()
inline SDL_Semaphore* CreateSemaphore(Uint32 initial_value) { auto _ret = SDL_CreateSemaphore(initial_value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroySemaphore()
inline void DestroySemaphore(SDL_Semaphore* sem) { SDL_DestroySemaphore(sem); }

//! @copydoc SDL_WaitSemaphore()
inline void WaitSemaphore(SDL_Semaphore* sem) { SDL_WaitSemaphore(sem); }

//! @copydoc SDL_TryWaitSemaphore()
inline bool TryWaitSemaphore(SDL_Semaphore* sem) { return SDL_TryWaitSemaphore(sem); }

//! @copydoc SDL_WaitSemaphoreTimeout()
inline bool WaitSemaphoreTimeout(SDL_Semaphore* sem, Sint32 timeoutMS) { return SDL_WaitSemaphoreTimeout(sem, timeoutMS); }

//! @copydoc SDL_SignalSemaphore()
inline void SignalSemaphore(SDL_Semaphore* sem) { SDL_SignalSemaphore(sem); }

//! @copydoc SDL_GetSemaphoreValue()
inline Uint32 GetSemaphoreValue(SDL_Semaphore* sem) { return SDL_GetSemaphoreValue(sem); }

//! @copydoc SDL_CreateCondition()
inline SDL_Condition* CreateCondition() { auto _ret = SDL_CreateCondition(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroyCondition()
inline void DestroyCondition(SDL_Condition* cond) { SDL_DestroyCondition(cond); }

//! @copydoc SDL_SignalCondition()
inline void SignalCondition(SDL_Condition* cond) { SDL_SignalCondition(cond); }

//! @copydoc SDL_BroadcastCondition()
inline void BroadcastCondition(SDL_Condition* cond) { SDL_BroadcastCondition(cond); }

//! @copydoc SDL_WaitCondition()
inline void WaitCondition(SDL_Condition* cond, SDL_Mutex* mutex) { SDL_WaitCondition(cond, mutex); }

//! @copydoc SDL_WaitConditionTimeout()
inline bool WaitConditionTimeout(SDL_Condition* cond, SDL_Mutex* mutex, Sint32 timeoutMS) { return SDL_WaitConditionTimeout(cond, mutex, timeoutMS); }

//! @copydoc SDL_ShouldInit()
inline bool ShouldInit(SDL_InitState* state) { return SDL_ShouldInit(state); }

//! @copydoc SDL_ShouldQuit()
inline bool ShouldQuit(SDL_InitState* state) { return SDL_ShouldQuit(state); }

//! @copydoc SDL_SetInitialized()
inline void SetInitialized(SDL_InitState* state, bool initialized) { SDL_SetInitialized(state, initialized); }

//! @copydoc SDL_IOFromFile()
inline SDL_IOStream* IOFromFile(const char* file, const char* mode) { auto _ret = SDL_IOFromFile(file, mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IOFromMem()
inline SDL_IOStream* IOFromMem(void* mem, size_t size) { auto _ret = SDL_IOFromMem(mem, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IOFromConstMem()
inline SDL_IOStream* IOFromConstMem(const void* mem, size_t size) { auto _ret = SDL_IOFromConstMem(mem, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IOFromDynamicMem()
inline SDL_IOStream* IOFromDynamicMem() { auto _ret = SDL_IOFromDynamicMem(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_OpenIO()
inline SDL_IOStream* OpenIO(const SDL_IOStreamInterface* iface, void* userdata) { auto _ret = SDL_OpenIO(iface, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CloseIO()
inline void CloseIO(SDL_IOStream* context) { auto _ret = SDL_CloseIO(context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetIOProperties()
inline SDL_PropertiesID GetIOProperties(SDL_IOStream* context) { auto _ret = SDL_GetIOProperties(context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetIOStatus()
inline SDL_IOStatus GetIOStatus(SDL_IOStream* context) { return SDL_GetIOStatus(context); }

//! @copydoc SDL_GetIOSize()
inline Sint64 GetIOSize(SDL_IOStream* context) { auto _ret = SDL_GetIOSize(context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SeekIO()
inline Sint64 SeekIO(SDL_IOStream* context, Sint64 offset, SDL_IOWhence whence) { auto _ret = SDL_SeekIO(context, offset, whence); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_TellIO()
inline Sint64 TellIO(SDL_IOStream* context) { return SDL_TellIO(context); }

//! @copydoc SDL_ReadIO()
inline size_t ReadIO(SDL_IOStream* context, void* ptr, size_t size) { auto _ret = SDL_ReadIO(context, ptr, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_WriteIO()
inline size_t WriteIO(SDL_IOStream* context, const void* ptr, size_t size) { auto _ret = SDL_WriteIO(context, ptr, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IOvprintf()
inline size_t IOvprintf(SDL_IOStream* context, const char* fmt, va_list ap) { auto _ret = SDL_IOvprintf(context, fmt, ap); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_FlushIO()
inline void FlushIO(SDL_IOStream* context) { auto _ret = SDL_FlushIO(context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LoadFile_IO()
inline void* LoadFile_IO(SDL_IOStream* src, size_t* datasize, bool closeio) { auto _ret = SDL_LoadFile_IO(src, datasize, closeio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_LoadFile()
inline void* LoadFile(const char* file, size_t* datasize) { auto _ret = SDL_LoadFile(file, datasize); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SaveFile_IO()
inline void SaveFile_IO(SDL_IOStream* src, const void* data, size_t datasize, bool closeio) { auto _ret = SDL_SaveFile_IO(src, data, datasize, closeio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SaveFile()
inline void SaveFile(const char* file, const void* data, size_t datasize) { auto _ret = SDL_SaveFile(file, data, datasize); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU8()
inline void ReadU8(SDL_IOStream* src, Uint8* value) { auto _ret = SDL_ReadU8(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS8()
inline void ReadS8(SDL_IOStream* src, Sint8* value) { auto _ret = SDL_ReadS8(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU16LE()
inline void ReadU16LE(SDL_IOStream* src, Uint16* value) { auto _ret = SDL_ReadU16LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS16LE()
inline void ReadS16LE(SDL_IOStream* src, Sint16* value) { auto _ret = SDL_ReadS16LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU16BE()
inline void ReadU16BE(SDL_IOStream* src, Uint16* value) { auto _ret = SDL_ReadU16BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS16BE()
inline void ReadS16BE(SDL_IOStream* src, Sint16* value) { auto _ret = SDL_ReadS16BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU32LE()
inline void ReadU32LE(SDL_IOStream* src, Uint32* value) { auto _ret = SDL_ReadU32LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS32LE()
inline void ReadS32LE(SDL_IOStream* src, Sint32* value) { auto _ret = SDL_ReadS32LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU32BE()
inline void ReadU32BE(SDL_IOStream* src, Uint32* value) { auto _ret = SDL_ReadU32BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS32BE()
inline void ReadS32BE(SDL_IOStream* src, Sint32* value) { auto _ret = SDL_ReadS32BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU64LE()
inline void ReadU64LE(SDL_IOStream* src, Uint64* value) { auto _ret = SDL_ReadU64LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS64LE()
inline void ReadS64LE(SDL_IOStream* src, Sint64* value) { auto _ret = SDL_ReadS64LE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadU64BE()
inline void ReadU64BE(SDL_IOStream* src, Uint64* value) { auto _ret = SDL_ReadU64BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadS64BE()
inline void ReadS64BE(SDL_IOStream* src, Sint64* value) { auto _ret = SDL_ReadS64BE(src, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU8()
inline void WriteU8(SDL_IOStream* dst, Uint8 value) { auto _ret = SDL_WriteU8(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS8()
inline void WriteS8(SDL_IOStream* dst, Sint8 value) { auto _ret = SDL_WriteS8(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU16LE()
inline void WriteU16LE(SDL_IOStream* dst, Uint16 value) { auto _ret = SDL_WriteU16LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS16LE()
inline void WriteS16LE(SDL_IOStream* dst, Sint16 value) { auto _ret = SDL_WriteS16LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU16BE()
inline void WriteU16BE(SDL_IOStream* dst, Uint16 value) { auto _ret = SDL_WriteU16BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS16BE()
inline void WriteS16BE(SDL_IOStream* dst, Sint16 value) { auto _ret = SDL_WriteS16BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU32LE()
inline void WriteU32LE(SDL_IOStream* dst, Uint32 value) { auto _ret = SDL_WriteU32LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS32LE()
inline void WriteS32LE(SDL_IOStream* dst, Sint32 value) { auto _ret = SDL_WriteS32LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU32BE()
inline void WriteU32BE(SDL_IOStream* dst, Uint32 value) { auto _ret = SDL_WriteU32BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS32BE()
inline void WriteS32BE(SDL_IOStream* dst, Sint32 value) { auto _ret = SDL_WriteS32BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU64LE()
inline void WriteU64LE(SDL_IOStream* dst, Uint64 value) { auto _ret = SDL_WriteU64LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS64LE()
inline void WriteS64LE(SDL_IOStream* dst, Sint64 value) { auto _ret = SDL_WriteS64LE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteU64BE()
inline void WriteU64BE(SDL_IOStream* dst, Uint64 value) { auto _ret = SDL_WriteU64BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteS64BE()
inline void WriteS64BE(SDL_IOStream* dst, Sint64 value) { auto _ret = SDL_WriteS64BE(dst, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetNumAudioDrivers()
inline int GetNumAudioDrivers() { return SDL_GetNumAudioDrivers(); }

//! @copydoc SDL_GetAudioDriver()
inline const char* GetAudioDriver(int index) { return SDL_GetAudioDriver(index); }

//! @copydoc SDL_GetCurrentAudioDriver()
inline const char* GetCurrentAudioDriver() { return SDL_GetCurrentAudioDriver(); }

//! @copydoc SDL_GetAudioPlaybackDevices()
inline SDL_AudioDeviceID* GetAudioPlaybackDevices(int* count) { auto _ret = SDL_GetAudioPlaybackDevices(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioRecordingDevices()
inline SDL_AudioDeviceID* GetAudioRecordingDevices(int* count) { auto _ret = SDL_GetAudioRecordingDevices(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioDeviceName()
inline const char* GetAudioDeviceName(SDL_AudioDeviceID devid) { auto _ret = SDL_GetAudioDeviceName(devid); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioDeviceFormat()
inline void GetAudioDeviceFormat(SDL_AudioDeviceID devid, SDL_AudioSpec* spec, int* sample_frames) { auto _ret = SDL_GetAudioDeviceFormat(devid, spec, sample_frames); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioDeviceChannelMap()
inline int* GetAudioDeviceChannelMap(SDL_AudioDeviceID devid, int* count) { return SDL_GetAudioDeviceChannelMap(devid, count); }

//! @copydoc SDL_OpenAudioDevice()
inline SDL_AudioDeviceID OpenAudioDevice(SDL_AudioDeviceID devid, const SDL_AudioSpec* spec) { auto _ret = SDL_OpenAudioDevice(devid, spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IsAudioDevicePhysical()
inline bool IsAudioDevicePhysical(SDL_AudioDeviceID devid) { return SDL_IsAudioDevicePhysical(devid); }

//! @copydoc SDL_IsAudioDevicePlayback()
inline bool IsAudioDevicePlayback(SDL_AudioDeviceID devid) { return SDL_IsAudioDevicePlayback(devid); }

//! @copydoc SDL_PauseAudioDevice()
inline void PauseAudioDevice(SDL_AudioDeviceID dev) { auto _ret = SDL_PauseAudioDevice(dev); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ResumeAudioDevice()
inline void ResumeAudioDevice(SDL_AudioDeviceID dev) { auto _ret = SDL_ResumeAudioDevice(dev); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_AudioDevicePaused()
inline bool AudioDevicePaused(SDL_AudioDeviceID dev) { return SDL_AudioDevicePaused(dev); }

//! @copydoc SDL_GetAudioDeviceGain()
inline float GetAudioDeviceGain(SDL_AudioDeviceID devid) { auto _ret = SDL_GetAudioDeviceGain(devid); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetAudioDeviceGain()
inline void SetAudioDeviceGain(SDL_AudioDeviceID devid, float gain) { auto _ret = SDL_SetAudioDeviceGain(devid, gain); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CloseAudioDevice()
inline void CloseAudioDevice(SDL_AudioDeviceID devid) { SDL_CloseAudioDevice(devid); }

//! @copydoc SDL_BindAudioStreams()
inline void BindAudioStreams(SDL_AudioDeviceID devid, SDL_AudioStream** streams, int num_streams) { auto _ret = SDL_BindAudioStreams(devid, streams, num_streams); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BindAudioStream()
inline void BindAudioStream(SDL_AudioDeviceID devid, SDL_AudioStream* stream) { auto _ret = SDL_BindAudioStream(devid, stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UnbindAudioStreams()
inline void UnbindAudioStreams(SDL_AudioStream** streams, int num_streams) { SDL_UnbindAudioStreams(streams, num_streams); }

//! @copydoc SDL_UnbindAudioStream()
inline void UnbindAudioStream(SDL_AudioStream* stream) { SDL_UnbindAudioStream(stream); }

//! @copydoc SDL_GetAudioStreamDevice()
inline SDL_AudioDeviceID GetAudioStreamDevice(SDL_AudioStream* stream) { return SDL_GetAudioStreamDevice(stream); }

//! @copydoc SDL_CreateAudioStream()
inline SDL_AudioStream* CreateAudioStream(const SDL_AudioSpec* src_spec, const SDL_AudioSpec* dst_spec) { auto _ret = SDL_CreateAudioStream(src_spec, dst_spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioStreamProperties()
inline SDL_PropertiesID GetAudioStreamProperties(SDL_AudioStream* stream) { auto _ret = SDL_GetAudioStreamProperties(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioStreamFormat()
inline void GetAudioStreamFormat(SDL_AudioStream* stream, SDL_AudioSpec* src_spec, SDL_AudioSpec* dst_spec) { auto _ret = SDL_GetAudioStreamFormat(stream, src_spec, dst_spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAudioStreamFormat()
inline void SetAudioStreamFormat(SDL_AudioStream* stream, const SDL_AudioSpec* src_spec, const SDL_AudioSpec* dst_spec) { auto _ret = SDL_SetAudioStreamFormat(stream, src_spec, dst_spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioStreamFrequencyRatio()
inline float GetAudioStreamFrequencyRatio(SDL_AudioStream* stream) { auto _ret = SDL_GetAudioStreamFrequencyRatio(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetAudioStreamFrequencyRatio()
inline void SetAudioStreamFrequencyRatio(SDL_AudioStream* stream, float ratio) { auto _ret = SDL_SetAudioStreamFrequencyRatio(stream, ratio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioStreamGain()
inline float GetAudioStreamGain(SDL_AudioStream* stream) { auto _ret = SDL_GetAudioStreamGain(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetAudioStreamGain()
inline void SetAudioStreamGain(SDL_AudioStream* stream, float gain) { auto _ret = SDL_SetAudioStreamGain(stream, gain); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioStreamInputChannelMap()
inline int* GetAudioStreamInputChannelMap(SDL_AudioStream* stream, int* count) { return SDL_GetAudioStreamInputChannelMap(stream, count); }

//! @copydoc SDL_GetAudioStreamOutputChannelMap()
inline int* GetAudioStreamOutputChannelMap(SDL_AudioStream* stream, int* count) { return SDL_GetAudioStreamOutputChannelMap(stream, count); }

//! @copydoc SDL_SetAudioStreamInputChannelMap()
inline void SetAudioStreamInputChannelMap(SDL_AudioStream* stream, const int* chmap, int count) { auto _ret = SDL_SetAudioStreamInputChannelMap(stream, chmap, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAudioStreamOutputChannelMap()
inline void SetAudioStreamOutputChannelMap(SDL_AudioStream* stream, const int* chmap, int count) { auto _ret = SDL_SetAudioStreamOutputChannelMap(stream, chmap, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PutAudioStreamData()
inline void PutAudioStreamData(SDL_AudioStream* stream, const void* buf, int len) { auto _ret = SDL_PutAudioStreamData(stream, buf, len); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioStreamData()
inline int GetAudioStreamData(SDL_AudioStream* stream, void* buf, int len) { auto _ret = SDL_GetAudioStreamData(stream, buf, len); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioStreamAvailable()
inline int GetAudioStreamAvailable(SDL_AudioStream* stream) { auto _ret = SDL_GetAudioStreamAvailable(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetAudioStreamQueued()
inline int GetAudioStreamQueued(SDL_AudioStream* stream) { auto _ret = SDL_GetAudioStreamQueued(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_FlushAudioStream()
inline void FlushAudioStream(SDL_AudioStream* stream) { auto _ret = SDL_FlushAudioStream(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ClearAudioStream()
inline void ClearAudioStream(SDL_AudioStream* stream) { auto _ret = SDL_ClearAudioStream(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PauseAudioStreamDevice()
inline void PauseAudioStreamDevice(SDL_AudioStream* stream) { auto _ret = SDL_PauseAudioStreamDevice(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ResumeAudioStreamDevice()
inline void ResumeAudioStreamDevice(SDL_AudioStream* stream) { auto _ret = SDL_ResumeAudioStreamDevice(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_AudioStreamDevicePaused()
inline bool AudioStreamDevicePaused(SDL_AudioStream* stream) { return SDL_AudioStreamDevicePaused(stream); }

//! @copydoc SDL_LockAudioStream()
inline void LockAudioStream(SDL_AudioStream* stream) { auto _ret = SDL_LockAudioStream(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UnlockAudioStream()
inline void UnlockAudioStream(SDL_AudioStream* stream) { auto _ret = SDL_UnlockAudioStream(stream); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAudioStreamGetCallback()
inline void SetAudioStreamGetCallback(SDL_AudioStream* stream, SDL_AudioStreamCallback callback, void* userdata) { auto _ret = SDL_SetAudioStreamGetCallback(stream, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAudioStreamPutCallback()
inline void SetAudioStreamPutCallback(SDL_AudioStream* stream, SDL_AudioStreamCallback callback, void* userdata) { auto _ret = SDL_SetAudioStreamPutCallback(stream, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyAudioStream()
inline void DestroyAudioStream(SDL_AudioStream* stream) { SDL_DestroyAudioStream(stream); }

//! @copydoc SDL_OpenAudioDeviceStream()
inline SDL_AudioStream* OpenAudioDeviceStream(SDL_AudioDeviceID devid, const SDL_AudioSpec* spec, SDL_AudioStreamCallback callback, void* userdata) { auto _ret = SDL_OpenAudioDeviceStream(devid, spec, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetAudioPostmixCallback()
inline void SetAudioPostmixCallback(SDL_AudioDeviceID devid, SDL_AudioPostmixCallback callback, void* userdata) { auto _ret = SDL_SetAudioPostmixCallback(devid, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LoadWAV_IO()
inline void LoadWAV_IO(SDL_IOStream* src, bool closeio, SDL_AudioSpec* spec, Uint8** audio_buf, Uint32* audio_len) { auto _ret = SDL_LoadWAV_IO(src, closeio, spec, audio_buf, audio_len); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LoadWAV()
inline void LoadWAV(const char* path, SDL_AudioSpec* spec, Uint8** audio_buf, Uint32* audio_len) { auto _ret = SDL_LoadWAV(path, spec, audio_buf, audio_len); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_MixAudio()
inline void MixAudio(Uint8* dst, const Uint8* src, SDL_AudioFormat format, Uint32 len, float volume) { auto _ret = SDL_MixAudio(dst, src, format, len, volume); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ConvertAudioSamples()
inline void ConvertAudioSamples(const SDL_AudioSpec* src_spec, const Uint8* src_data, int src_len, const SDL_AudioSpec* dst_spec, Uint8** dst_data, int* dst_len) { auto _ret = SDL_ConvertAudioSamples(src_spec, src_data, src_len, dst_spec, dst_data, dst_len); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAudioFormatName()
inline const char* GetAudioFormatName(SDL_AudioFormat format) { return SDL_GetAudioFormatName(format); }

//! @copydoc SDL_GetSilenceValueForFormat()
inline int GetSilenceValueForFormat(SDL_AudioFormat format) { return SDL_GetSilenceValueForFormat(format); }

//! @copydoc SDL_MostSignificantBitIndex32()
inline int MostSignificantBitIndex32(Uint32 x) { return SDL_MostSignificantBitIndex32(x); }

//! @copydoc SDL_HasExactlyOneBitSet32()
inline bool HasExactlyOneBitSet32(Uint32 x) { return SDL_HasExactlyOneBitSet32(x); }

//! @copydoc SDL_ComposeCustomBlendMode()
inline SDL_BlendMode ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation) { return SDL_ComposeCustomBlendMode(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation); }

//! @copydoc SDL_GetPixelFormatName()
inline const char* GetPixelFormatName(SDL_PixelFormat format) { return SDL_GetPixelFormatName(format); }

//! @copydoc SDL_GetMasksForPixelFormat()
inline void GetMasksForPixelFormat(SDL_PixelFormat format, int* bpp, Uint32* Rmask, Uint32* Gmask, Uint32* Bmask, Uint32* Amask) { auto _ret = SDL_GetMasksForPixelFormat(format, bpp, Rmask, Gmask, Bmask, Amask); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetPixelFormatForMasks()
inline SDL_PixelFormat GetPixelFormatForMasks(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask) { return SDL_GetPixelFormatForMasks(bpp, Rmask, Gmask, Bmask, Amask); }

//! @copydoc SDL_GetPixelFormatDetails()
inline const SDL_PixelFormatDetails* GetPixelFormatDetails(SDL_PixelFormat format) { auto _ret = SDL_GetPixelFormatDetails(format); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreatePalette()
inline SDL_Palette* CreatePalette(int ncolors) { auto _ret = SDL_CreatePalette(ncolors); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetPaletteColors()
inline void SetPaletteColors(SDL_Palette* palette, const SDL_Color* colors, int firstcolor, int ncolors) { auto _ret = SDL_SetPaletteColors(palette, colors, firstcolor, ncolors); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyPalette()
inline void DestroyPalette(SDL_Palette* palette) { SDL_DestroyPalette(palette); }

//! @copydoc SDL_MapRGB()
inline Uint32 MapRGB(const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8 r, Uint8 g, Uint8 b) { return SDL_MapRGB(format, palette, r, g, b); }

//! @copydoc SDL_MapRGBA()
inline Uint32 MapRGBA(const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8 r, Uint8 g, Uint8 b, Uint8 a) { return SDL_MapRGBA(format, palette, r, g, b, a); }

//! @copydoc SDL_GetRGB()
inline void GetRGB(Uint32 pixel, const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8* r, Uint8* g, Uint8* b) { SDL_GetRGB(pixel, format, palette, r, g, b); }

//! @copydoc SDL_GetRGBA()
inline void GetRGBA(Uint32 pixel, const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8* r, Uint8* g, Uint8* b, Uint8* a) { SDL_GetRGBA(pixel, format, palette, r, g, b, a); }

//! @copydoc SDL_RectToFRect()
inline void RectToFRect(const SDL_Rect* rect, SDL_FRect* frect) { SDL_RectToFRect(rect, frect); }

//! @copydoc SDL_PointInRect()
inline bool PointInRect(const SDL_Point* p, const SDL_Rect* r) { return SDL_PointInRect(p, r); }

//! @copydoc SDL_RectEmpty()
inline bool RectEmpty(const SDL_Rect* r) { return SDL_RectEmpty(r); }

//! @copydoc SDL_RectsEqual()
inline bool RectsEqual(const SDL_Rect* a, const SDL_Rect* b) { return SDL_RectsEqual(a, b); }

//! @copydoc SDL_HasRectIntersection()
inline bool HasRectIntersection(const SDL_Rect* A, const SDL_Rect* B) { return SDL_HasRectIntersection(A, B); }

//! @copydoc SDL_GetRectIntersection()
inline bool GetRectIntersection(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* result) { return SDL_GetRectIntersection(A, B, result); }

//! @copydoc SDL_GetRectUnion()
inline void GetRectUnion(const SDL_Rect* A, const SDL_Rect* B, SDL_Rect* result) { auto _ret = SDL_GetRectUnion(A, B, result); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRectEnclosingPoints()
inline bool GetRectEnclosingPoints(const SDL_Point* points, int count, const SDL_Rect* clip, SDL_Rect* result) { return SDL_GetRectEnclosingPoints(points, count, clip, result); }

//! @copydoc SDL_GetRectAndLineIntersection()
inline bool GetRectAndLineIntersection(const SDL_Rect* rect, int* X1, int* Y1, int* X2, int* Y2) { return SDL_GetRectAndLineIntersection(rect, X1, Y1, X2, Y2); }

//! @copydoc SDL_PointInRectFloat()
inline bool PointInRectFloat(const SDL_FPoint* p, const SDL_FRect* r) { return SDL_PointInRectFloat(p, r); }

//! @copydoc SDL_RectEmptyFloat()
inline bool RectEmptyFloat(const SDL_FRect* r) { return SDL_RectEmptyFloat(r); }

//! @copydoc SDL_RectsEqualEpsilon()
inline bool RectsEqualEpsilon(const SDL_FRect* a, const SDL_FRect* b, const float epsilon) { return SDL_RectsEqualEpsilon(a, b, epsilon); }

//! @copydoc SDL_RectsEqualFloat()
inline bool RectsEqualFloat(const SDL_FRect* a, const SDL_FRect* b) { return SDL_RectsEqualFloat(a, b); }

//! @copydoc SDL_HasRectIntersectionFloat()
inline bool HasRectIntersectionFloat(const SDL_FRect* A, const SDL_FRect* B) { return SDL_HasRectIntersectionFloat(A, B); }

//! @copydoc SDL_GetRectIntersectionFloat()
inline bool GetRectIntersectionFloat(const SDL_FRect* A, const SDL_FRect* B, SDL_FRect* result) { return SDL_GetRectIntersectionFloat(A, B, result); }

//! @copydoc SDL_GetRectUnionFloat()
inline void GetRectUnionFloat(const SDL_FRect* A, const SDL_FRect* B, SDL_FRect* result) { auto _ret = SDL_GetRectUnionFloat(A, B, result); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRectEnclosingPointsFloat()
inline bool GetRectEnclosingPointsFloat(const SDL_FPoint* points, int count, const SDL_FRect* clip, SDL_FRect* result) { return SDL_GetRectEnclosingPointsFloat(points, count, clip, result); }

//! @copydoc SDL_GetRectAndLineIntersectionFloat()
inline bool GetRectAndLineIntersectionFloat(const SDL_FRect* rect, float* X1, float* Y1, float* X2, float* Y2) { return SDL_GetRectAndLineIntersectionFloat(rect, X1, Y1, X2, Y2); }

//! @copydoc SDL_CreateSurface()
inline SDL_Surface* CreateSurface(int width, int height, SDL_PixelFormat format) { auto _ret = SDL_CreateSurface(width, height, format); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateSurfaceFrom()
inline SDL_Surface* CreateSurfaceFrom(int width, int height, SDL_PixelFormat format, void* pixels, int pitch) { auto _ret = SDL_CreateSurfaceFrom(width, height, format, pixels, pitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroySurface()
inline void DestroySurface(SDL_Surface* surface) { SDL_DestroySurface(surface); }

//! @copydoc SDL_GetSurfaceProperties()
inline SDL_PropertiesID GetSurfaceProperties(SDL_Surface* surface) { auto _ret = SDL_GetSurfaceProperties(surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetSurfaceColorspace()
inline void SetSurfaceColorspace(SDL_Surface* surface, SDL_Colorspace colorspace) { auto _ret = SDL_SetSurfaceColorspace(surface, colorspace); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetSurfaceColorspace()
inline SDL_Colorspace GetSurfaceColorspace(SDL_Surface* surface) { return SDL_GetSurfaceColorspace(surface); }

//! @copydoc SDL_CreateSurfacePalette()
inline SDL_Palette* CreateSurfacePalette(SDL_Surface* surface) { auto _ret = SDL_CreateSurfacePalette(surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetSurfacePalette()
inline void SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette) { auto _ret = SDL_SetSurfacePalette(surface, palette); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetSurfacePalette()
inline SDL_Palette* GetSurfacePalette(SDL_Surface* surface) { return SDL_GetSurfacePalette(surface); }

//! @copydoc SDL_AddSurfaceAlternateImage()
inline void AddSurfaceAlternateImage(SDL_Surface* surface, SDL_Surface* image) { auto _ret = SDL_AddSurfaceAlternateImage(surface, image); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SurfaceHasAlternateImages()
inline bool SurfaceHasAlternateImages(SDL_Surface* surface) { return SDL_SurfaceHasAlternateImages(surface); }

//! @copydoc SDL_GetSurfaceImages()
inline SDL_Surface** GetSurfaceImages(SDL_Surface* surface, int* count) { auto _ret = SDL_GetSurfaceImages(surface, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_RemoveSurfaceAlternateImages()
inline void RemoveSurfaceAlternateImages(SDL_Surface* surface) { SDL_RemoveSurfaceAlternateImages(surface); }

//! @copydoc SDL_LockSurface()
inline void LockSurface(SDL_Surface* surface) { auto _ret = SDL_LockSurface(surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UnlockSurface()
inline void UnlockSurface(SDL_Surface* surface) { SDL_UnlockSurface(surface); }

//! @copydoc SDL_LoadBMP_IO()
inline SDL_Surface* LoadBMP_IO(SDL_IOStream* src, bool closeio) { auto _ret = SDL_LoadBMP_IO(src, closeio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_LoadBMP()
inline SDL_Surface* LoadBMP(const char* file) { auto _ret = SDL_LoadBMP(file); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SaveBMP_IO()
inline void SaveBMP_IO(SDL_Surface* surface, SDL_IOStream* dst, bool closeio) { auto _ret = SDL_SaveBMP_IO(surface, dst, closeio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SaveBMP()
inline void SaveBMP(SDL_Surface* surface, const char* file) { auto _ret = SDL_SaveBMP(surface, file); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetSurfaceRLE()
inline void SetSurfaceRLE(SDL_Surface* surface, bool enabled) { auto _ret = SDL_SetSurfaceRLE(surface, enabled); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SurfaceHasRLE()
inline bool SurfaceHasRLE(SDL_Surface* surface) { return SDL_SurfaceHasRLE(surface); }

//! @copydoc SDL_SetSurfaceColorKey()
inline void SetSurfaceColorKey(SDL_Surface* surface, bool enabled, Uint32 key) { auto _ret = SDL_SetSurfaceColorKey(surface, enabled, key); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SurfaceHasColorKey()
inline bool SurfaceHasColorKey(SDL_Surface* surface) { return SDL_SurfaceHasColorKey(surface); }

//! @copydoc SDL_GetSurfaceColorKey()
inline void GetSurfaceColorKey(SDL_Surface* surface, Uint32* key) { auto _ret = SDL_GetSurfaceColorKey(surface, key); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetSurfaceColorMod()
inline void SetSurfaceColorMod(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b) { auto _ret = SDL_SetSurfaceColorMod(surface, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetSurfaceColorMod()
inline void GetSurfaceColorMod(SDL_Surface* surface, Uint8* r, Uint8* g, Uint8* b) { auto _ret = SDL_GetSurfaceColorMod(surface, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetSurfaceAlphaMod()
inline void SetSurfaceAlphaMod(SDL_Surface* surface, Uint8 alpha) { auto _ret = SDL_SetSurfaceAlphaMod(surface, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetSurfaceAlphaMod()
inline void GetSurfaceAlphaMod(SDL_Surface* surface, Uint8* alpha) { auto _ret = SDL_GetSurfaceAlphaMod(surface, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetSurfaceBlendMode()
inline void SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode) { auto _ret = SDL_SetSurfaceBlendMode(surface, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetSurfaceBlendMode()
inline void GetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode* blendMode) { auto _ret = SDL_GetSurfaceBlendMode(surface, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetSurfaceClipRect()
inline bool SetSurfaceClipRect(SDL_Surface* surface, const SDL_Rect* rect) { return SDL_SetSurfaceClipRect(surface, rect); }

//! @copydoc SDL_GetSurfaceClipRect()
inline void GetSurfaceClipRect(SDL_Surface* surface, SDL_Rect* rect) { auto _ret = SDL_GetSurfaceClipRect(surface, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_FlipSurface()
inline void FlipSurface(SDL_Surface* surface, SDL_FlipMode flip) { auto _ret = SDL_FlipSurface(surface, flip); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DuplicateSurface()
inline SDL_Surface* DuplicateSurface(SDL_Surface* surface) { auto _ret = SDL_DuplicateSurface(surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ScaleSurface()
inline SDL_Surface* ScaleSurface(SDL_Surface* surface, int width, int height, SDL_ScaleMode scaleMode) { auto _ret = SDL_ScaleSurface(surface, width, height, scaleMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ConvertSurface()
inline SDL_Surface* ConvertSurface(SDL_Surface* surface, SDL_PixelFormat format) { auto _ret = SDL_ConvertSurface(surface, format); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ConvertSurfaceAndColorspace()
inline SDL_Surface* ConvertSurfaceAndColorspace(SDL_Surface* surface, SDL_PixelFormat format, SDL_Palette* palette, SDL_Colorspace colorspace, SDL_PropertiesID props) { auto _ret = SDL_ConvertSurfaceAndColorspace(surface, format, palette, colorspace, props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ConvertPixels()
inline void ConvertPixels(int width, int height, SDL_PixelFormat src_format, const void* src, int src_pitch, SDL_PixelFormat dst_format, void* dst, int dst_pitch) { auto _ret = SDL_ConvertPixels(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ConvertPixelsAndColorspace()
inline void ConvertPixelsAndColorspace(int width, int height, SDL_PixelFormat src_format, SDL_Colorspace src_colorspace, SDL_PropertiesID src_properties, const void* src, int src_pitch, SDL_PixelFormat dst_format, SDL_Colorspace dst_colorspace, SDL_PropertiesID dst_properties, void* dst, int dst_pitch) { auto _ret = SDL_ConvertPixelsAndColorspace(width, height, src_format, src_colorspace, src_properties, src, src_pitch, dst_format, dst_colorspace, dst_properties, dst, dst_pitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PremultiplyAlpha()
inline void PremultiplyAlpha(int width, int height, SDL_PixelFormat src_format, const void* src, int src_pitch, SDL_PixelFormat dst_format, void* dst, int dst_pitch, bool linear) { auto _ret = SDL_PremultiplyAlpha(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PremultiplySurfaceAlpha()
inline void PremultiplySurfaceAlpha(SDL_Surface* surface, bool linear) { auto _ret = SDL_PremultiplySurfaceAlpha(surface, linear); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ClearSurface()
inline void ClearSurface(SDL_Surface* surface, float r, float g, float b, float a) { auto _ret = SDL_ClearSurface(surface, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_FillSurfaceRect()
inline void FillSurfaceRect(SDL_Surface* dst, const SDL_Rect* rect, Uint32 color) { auto _ret = SDL_FillSurfaceRect(dst, rect, color); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_FillSurfaceRects()
inline void FillSurfaceRects(SDL_Surface* dst, const SDL_Rect* rects, int count, Uint32 color) { auto _ret = SDL_FillSurfaceRects(dst, rects, count, color); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurface()
inline void BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, const SDL_Rect* dstrect) { auto _ret = SDL_BlitSurface(src, srcrect, dst, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurfaceUnchecked()
inline void BlitSurfaceUnchecked(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, const SDL_Rect* dstrect) { auto _ret = SDL_BlitSurfaceUnchecked(src, srcrect, dst, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurfaceScaled()
inline void BlitSurfaceScaled(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, const SDL_Rect* dstrect, SDL_ScaleMode scaleMode) { auto _ret = SDL_BlitSurfaceScaled(src, srcrect, dst, dstrect, scaleMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurfaceUncheckedScaled()
inline void BlitSurfaceUncheckedScaled(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, const SDL_Rect* dstrect, SDL_ScaleMode scaleMode) { auto _ret = SDL_BlitSurfaceUncheckedScaled(src, srcrect, dst, dstrect, scaleMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurfaceTiled()
inline void BlitSurfaceTiled(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, const SDL_Rect* dstrect) { auto _ret = SDL_BlitSurfaceTiled(src, srcrect, dst, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurfaceTiledWithScale()
inline void BlitSurfaceTiledWithScale(SDL_Surface* src, const SDL_Rect* srcrect, float scale, SDL_ScaleMode scaleMode, SDL_Surface* dst, const SDL_Rect* dstrect) { auto _ret = SDL_BlitSurfaceTiledWithScale(src, srcrect, scale, scaleMode, dst, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_BlitSurface9Grid()
inline void BlitSurface9Grid(SDL_Surface* src, const SDL_Rect* srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, SDL_ScaleMode scaleMode, SDL_Surface* dst, const SDL_Rect* dstrect) { auto _ret = SDL_BlitSurface9Grid(src, srcrect, left_width, right_width, top_height, bottom_height, scale, scaleMode, dst, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_MapSurfaceRGB()
inline Uint32 MapSurfaceRGB(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b) { return SDL_MapSurfaceRGB(surface, r, g, b); }

//! @copydoc SDL_MapSurfaceRGBA()
inline Uint32 MapSurfaceRGBA(SDL_Surface* surface, Uint8 r, Uint8 g, Uint8 b, Uint8 a) { return SDL_MapSurfaceRGBA(surface, r, g, b, a); }

//! @copydoc SDL_ReadSurfacePixel()
inline void ReadSurfacePixel(SDL_Surface* surface, int x, int y, Uint8* r, Uint8* g, Uint8* b, Uint8* a) { auto _ret = SDL_ReadSurfacePixel(surface, x, y, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadSurfacePixelFloat()
inline void ReadSurfacePixelFloat(SDL_Surface* surface, int x, int y, float* r, float* g, float* b, float* a) { auto _ret = SDL_ReadSurfacePixelFloat(surface, x, y, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteSurfacePixel()
inline void WriteSurfacePixel(SDL_Surface* surface, int x, int y, Uint8 r, Uint8 g, Uint8 b, Uint8 a) { auto _ret = SDL_WriteSurfacePixel(surface, x, y, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteSurfacePixelFloat()
inline void WriteSurfacePixelFloat(SDL_Surface* surface, int x, int y, float r, float g, float b, float a) { auto _ret = SDL_WriteSurfacePixelFloat(surface, x, y, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetNumCameraDrivers()
inline int GetNumCameraDrivers() { return SDL_GetNumCameraDrivers(); }

//! @copydoc SDL_GetCameraDriver()
inline const char* GetCameraDriver(int index) { return SDL_GetCameraDriver(index); }

//! @copydoc SDL_GetCurrentCameraDriver()
inline const char* GetCurrentCameraDriver() { return SDL_GetCurrentCameraDriver(); }

//! @copydoc SDL_GetCameras()
inline SDL_CameraID* GetCameras(int* count) { auto _ret = SDL_GetCameras(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraSupportedFormats()
inline SDL_CameraSpec** GetCameraSupportedFormats(SDL_CameraID devid, int* count) { auto _ret = SDL_GetCameraSupportedFormats(devid, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraName()
inline const char* GetCameraName(SDL_CameraID instance_id) { auto _ret = SDL_GetCameraName(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraPosition()
inline SDL_CameraPosition GetCameraPosition(SDL_CameraID instance_id) { return SDL_GetCameraPosition(instance_id); }

//! @copydoc SDL_OpenCamera()
inline SDL_Camera* OpenCamera(SDL_CameraID instance_id, const SDL_CameraSpec* spec) { auto _ret = SDL_OpenCamera(instance_id, spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraPermissionState()
inline int GetCameraPermissionState(SDL_Camera* camera) { return SDL_GetCameraPermissionState(camera); }

//! @copydoc SDL_GetCameraID()
inline SDL_CameraID GetCameraID(SDL_Camera* camera) { auto _ret = SDL_GetCameraID(camera); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraProperties()
inline SDL_PropertiesID GetCameraProperties(SDL_Camera* camera) { auto _ret = SDL_GetCameraProperties(camera); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCameraFormat()
inline void GetCameraFormat(SDL_Camera* camera, SDL_CameraSpec* spec) { auto _ret = SDL_GetCameraFormat(camera, spec); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_AcquireCameraFrame()
inline SDL_Surface* AcquireCameraFrame(SDL_Camera* camera, Uint64* timestampNS) { return SDL_AcquireCameraFrame(camera, timestampNS); }

//! @copydoc SDL_ReleaseCameraFrame()
inline void ReleaseCameraFrame(SDL_Camera* camera, SDL_Surface* frame) { SDL_ReleaseCameraFrame(camera, frame); }

//! @copydoc SDL_CloseCamera()
inline void CloseCamera(SDL_Camera* camera) { SDL_CloseCamera(camera); }

//! @copydoc SDL_SetClipboardText()
inline void SetClipboardText(const char* text) { auto _ret = SDL_SetClipboardText(text); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetClipboardText()
inline char* GetClipboardText() { auto _ret = SDL_GetClipboardText(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_HasClipboardText()
inline bool HasClipboardText() { return SDL_HasClipboardText(); }

//! @copydoc SDL_SetPrimarySelectionText()
inline void SetPrimarySelectionText(const char* text) { auto _ret = SDL_SetPrimarySelectionText(text); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetPrimarySelectionText()
inline char* GetPrimarySelectionText() { auto _ret = SDL_GetPrimarySelectionText(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_HasPrimarySelectionText()
inline bool HasPrimarySelectionText() { return SDL_HasPrimarySelectionText(); }

//! @copydoc SDL_SetClipboardData()
inline void SetClipboardData(SDL_ClipboardDataCallback callback, SDL_ClipboardCleanupCallback cleanup, void* userdata, const char** mime_types, size_t num_mime_types) { auto _ret = SDL_SetClipboardData(callback, cleanup, userdata, mime_types, num_mime_types); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ClearClipboardData()
inline void ClearClipboardData() { auto _ret = SDL_ClearClipboardData(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetClipboardData()
inline void* GetClipboardData(const char* mime_type, size_t* size) { auto _ret = SDL_GetClipboardData(mime_type, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_HasClipboardData()
inline bool HasClipboardData(const char* mime_type) { return SDL_HasClipboardData(mime_type); }

//! @copydoc SDL_GetClipboardMimeTypes()
inline char** GetClipboardMimeTypes(size_t* num_mime_types) { auto _ret = SDL_GetClipboardMimeTypes(num_mime_types); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumLogicalCPUCores()
inline int GetNumLogicalCPUCores() { return SDL_GetNumLogicalCPUCores(); }

//! @copydoc SDL_GetCPUCacheLineSize()
inline int GetCPUCacheLineSize() { return SDL_GetCPUCacheLineSize(); }

//! @copydoc SDL_HasAltiVec()
inline bool HasAltiVec() { return SDL_HasAltiVec(); }

//! @copydoc SDL_HasMMX()
inline bool HasMMX() { return SDL_HasMMX(); }

//! @copydoc SDL_HasSSE()
inline bool HasSSE() { return SDL_HasSSE(); }

//! @copydoc SDL_HasSSE2()
inline bool HasSSE2() { return SDL_HasSSE2(); }

//! @copydoc SDL_HasSSE3()
inline bool HasSSE3() { return SDL_HasSSE3(); }

//! @copydoc SDL_HasSSE41()
inline bool HasSSE41() { return SDL_HasSSE41(); }

//! @copydoc SDL_HasSSE42()
inline bool HasSSE42() { return SDL_HasSSE42(); }

//! @copydoc SDL_HasAVX()
inline bool HasAVX() { return SDL_HasAVX(); }

//! @copydoc SDL_HasAVX2()
inline bool HasAVX2() { return SDL_HasAVX2(); }

//! @copydoc SDL_HasAVX512F()
inline bool HasAVX512F() { return SDL_HasAVX512F(); }

//! @copydoc SDL_HasARMSIMD()
inline bool HasARMSIMD() { return SDL_HasARMSIMD(); }

//! @copydoc SDL_HasNEON()
inline bool HasNEON() { return SDL_HasNEON(); }

//! @copydoc SDL_HasLSX()
inline bool HasLSX() { return SDL_HasLSX(); }

//! @copydoc SDL_HasLASX()
inline bool HasLASX() { return SDL_HasLASX(); }

//! @copydoc SDL_GetSystemRAM()
inline int GetSystemRAM() { return SDL_GetSystemRAM(); }

//! @copydoc SDL_GetSIMDAlignment()
inline size_t GetSIMDAlignment() { return SDL_GetSIMDAlignment(); }

//! @copydoc SDL_GetNumVideoDrivers()
inline int GetNumVideoDrivers() { return SDL_GetNumVideoDrivers(); }

//! @copydoc SDL_GetVideoDriver()
inline const char* GetVideoDriver(int index) { return SDL_GetVideoDriver(index); }

//! @copydoc SDL_GetCurrentVideoDriver()
inline const char* GetCurrentVideoDriver() { return SDL_GetCurrentVideoDriver(); }

//! @copydoc SDL_GetSystemTheme()
inline SDL_SystemTheme GetSystemTheme() { return SDL_GetSystemTheme(); }

//! @copydoc SDL_GetDisplays()
inline SDL_DisplayID* GetDisplays(int* count) { auto _ret = SDL_GetDisplays(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetPrimaryDisplay()
inline SDL_DisplayID GetPrimaryDisplay() { auto _ret = SDL_GetPrimaryDisplay(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayProperties()
inline SDL_PropertiesID GetDisplayProperties(SDL_DisplayID displayID) { auto _ret = SDL_GetDisplayProperties(displayID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayName()
inline const char* GetDisplayName(SDL_DisplayID displayID) { auto _ret = SDL_GetDisplayName(displayID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayBounds()
inline void GetDisplayBounds(SDL_DisplayID displayID, SDL_Rect* rect) { auto _ret = SDL_GetDisplayBounds(displayID, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetDisplayUsableBounds()
inline void GetDisplayUsableBounds(SDL_DisplayID displayID, SDL_Rect* rect) { auto _ret = SDL_GetDisplayUsableBounds(displayID, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetNaturalDisplayOrientation()
inline SDL_DisplayOrientation GetNaturalDisplayOrientation(SDL_DisplayID displayID) { return SDL_GetNaturalDisplayOrientation(displayID); }

//! @copydoc SDL_GetCurrentDisplayOrientation()
inline SDL_DisplayOrientation GetCurrentDisplayOrientation(SDL_DisplayID displayID) { return SDL_GetCurrentDisplayOrientation(displayID); }

//! @copydoc SDL_GetDisplayContentScale()
inline float GetDisplayContentScale(SDL_DisplayID displayID) { auto _ret = SDL_GetDisplayContentScale(displayID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetFullscreenDisplayModes()
inline SDL_DisplayMode** GetFullscreenDisplayModes(SDL_DisplayID displayID, int* count) { auto _ret = SDL_GetFullscreenDisplayModes(displayID, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetClosestFullscreenDisplayMode()
inline void GetClosestFullscreenDisplayMode(SDL_DisplayID displayID, int w, int h, float refresh_rate, bool include_high_density_modes, SDL_DisplayMode* closest) { auto _ret = SDL_GetClosestFullscreenDisplayMode(displayID, w, h, refresh_rate, include_high_density_modes, closest); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetDesktopDisplayMode()
inline const SDL_DisplayMode* GetDesktopDisplayMode(SDL_DisplayID displayID) { auto _ret = SDL_GetDesktopDisplayMode(displayID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCurrentDisplayMode()
inline const SDL_DisplayMode* GetCurrentDisplayMode(SDL_DisplayID displayID) { auto _ret = SDL_GetCurrentDisplayMode(displayID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayForPoint()
inline SDL_DisplayID GetDisplayForPoint(const SDL_Point* point) { auto _ret = SDL_GetDisplayForPoint(point); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayForRect()
inline SDL_DisplayID GetDisplayForRect(const SDL_Rect* rect) { auto _ret = SDL_GetDisplayForRect(rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDisplayForWindow()
inline SDL_DisplayID GetDisplayForWindow(SDL_Window* window) { auto _ret = SDL_GetDisplayForWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowPixelDensity()
inline float GetWindowPixelDensity(SDL_Window* window) { auto _ret = SDL_GetWindowPixelDensity(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowDisplayScale()
inline float GetWindowDisplayScale(SDL_Window* window) { auto _ret = SDL_GetWindowDisplayScale(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetWindowFullscreenMode()
inline void SetWindowFullscreenMode(SDL_Window* window, const SDL_DisplayMode* mode) { auto _ret = SDL_SetWindowFullscreenMode(window, mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowFullscreenMode()
inline const SDL_DisplayMode* GetWindowFullscreenMode(SDL_Window* window) { return SDL_GetWindowFullscreenMode(window); }

//! @copydoc SDL_GetWindowICCProfile()
inline void* GetWindowICCProfile(SDL_Window* window, size_t* size) { auto _ret = SDL_GetWindowICCProfile(window, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowPixelFormat()
inline SDL_PixelFormat GetWindowPixelFormat(SDL_Window* window) { auto _ret = SDL_GetWindowPixelFormat(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindows()
inline SDL_Window** GetWindows(int* count) { auto _ret = SDL_GetWindows(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateWindow()
inline SDL_Window* CreateWindow(const char* title, int w, int h, SDL::WindowFlags flags) { auto _ret = SDL_CreateWindow(title, w, h, flags); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreatePopupWindow()
inline SDL_Window* CreatePopupWindow(SDL_Window* parent, int offset_x, int offset_y, int w, int h, SDL::WindowFlags flags) { auto _ret = SDL_CreatePopupWindow(parent, offset_x, offset_y, w, h, flags); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateWindowWithProperties()
inline SDL_Window* CreateWindowWithProperties(SDL_PropertiesID props) { auto _ret = SDL_CreateWindowWithProperties(props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowID()
inline SDL_WindowID GetWindowID(SDL_Window* window) { auto _ret = SDL_GetWindowID(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowFromID()
inline SDL_Window* GetWindowFromID(SDL_WindowID id) { auto _ret = SDL_GetWindowFromID(id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowParent()
inline SDL_Window* GetWindowParent(SDL_Window* window) { return SDL_GetWindowParent(window); }

//! @copydoc SDL_GetWindowProperties()
inline SDL_PropertiesID GetWindowProperties(SDL_Window* window) { auto _ret = SDL_GetWindowProperties(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetWindowFlags()
inline SDL::WindowFlags GetWindowFlags(SDL_Window* window) { return (SDL::WindowFlags) SDL_GetWindowFlags(window); }

//! @copydoc SDL_SetWindowTitle()
inline void SetWindowTitle(SDL_Window* window, const char* title) { auto _ret = SDL_SetWindowTitle(window, title); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowTitle()
inline const char* GetWindowTitle(SDL_Window* window) { return SDL_GetWindowTitle(window); }

//! @copydoc SDL_SetWindowIcon()
inline void SetWindowIcon(SDL_Window* window, SDL_Surface* icon) { auto _ret = SDL_SetWindowIcon(window, icon); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowPosition()
inline void SetWindowPosition(SDL_Window* window, int x, int y) { auto _ret = SDL_SetWindowPosition(window, x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowPosition()
inline void GetWindowPosition(SDL_Window* window, int* x, int* y) { auto _ret = SDL_GetWindowPosition(window, x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowSize()
inline void SetWindowSize(SDL_Window* window, int w, int h) { auto _ret = SDL_SetWindowSize(window, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowSize()
inline void GetWindowSize(SDL_Window* window, int* w, int* h) { auto _ret = SDL_GetWindowSize(window, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowSafeArea()
inline void GetWindowSafeArea(SDL_Window* window, SDL_Rect* rect) { auto _ret = SDL_GetWindowSafeArea(window, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowAspectRatio()
inline void SetWindowAspectRatio(SDL_Window* window, float min_aspect, float max_aspect) { auto _ret = SDL_SetWindowAspectRatio(window, min_aspect, max_aspect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowAspectRatio()
inline void GetWindowAspectRatio(SDL_Window* window, float* min_aspect, float* max_aspect) { auto _ret = SDL_GetWindowAspectRatio(window, min_aspect, max_aspect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowBordersSize()
inline void GetWindowBordersSize(SDL_Window* window, int* top, int* left, int* bottom, int* right) { auto _ret = SDL_GetWindowBordersSize(window, top, left, bottom, right); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowSizeInPixels()
inline void GetWindowSizeInPixels(SDL_Window* window, int* w, int* h) { auto _ret = SDL_GetWindowSizeInPixels(window, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowMinimumSize()
inline void SetWindowMinimumSize(SDL_Window* window, int min_w, int min_h) { auto _ret = SDL_SetWindowMinimumSize(window, min_w, min_h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowMinimumSize()
inline void GetWindowMinimumSize(SDL_Window* window, int* w, int* h) { auto _ret = SDL_GetWindowMinimumSize(window, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowMaximumSize()
inline void SetWindowMaximumSize(SDL_Window* window, int max_w, int max_h) { auto _ret = SDL_SetWindowMaximumSize(window, max_w, max_h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowMaximumSize()
inline void GetWindowMaximumSize(SDL_Window* window, int* w, int* h) { auto _ret = SDL_GetWindowMaximumSize(window, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowBordered()
inline void SetWindowBordered(SDL_Window* window, bool bordered) { auto _ret = SDL_SetWindowBordered(window, bordered); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowResizable()
inline void SetWindowResizable(SDL_Window* window, bool resizable) { auto _ret = SDL_SetWindowResizable(window, resizable); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowAlwaysOnTop()
inline void SetWindowAlwaysOnTop(SDL_Window* window, bool on_top) { auto _ret = SDL_SetWindowAlwaysOnTop(window, on_top); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ShowWindow()
inline void ShowWindow(SDL_Window* window) { auto _ret = SDL_ShowWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HideWindow()
inline void HideWindow(SDL_Window* window) { auto _ret = SDL_HideWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RaiseWindow()
inline void RaiseWindow(SDL_Window* window) { auto _ret = SDL_RaiseWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_MaximizeWindow()
inline void MaximizeWindow(SDL_Window* window) { auto _ret = SDL_MaximizeWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_MinimizeWindow()
inline void MinimizeWindow(SDL_Window* window) { auto _ret = SDL_MinimizeWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RestoreWindow()
inline void RestoreWindow(SDL_Window* window) { auto _ret = SDL_RestoreWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowFullscreen()
inline void SetWindowFullscreen(SDL_Window* window, bool fullscreen) { auto _ret = SDL_SetWindowFullscreen(window, fullscreen); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SyncWindow()
inline bool SyncWindow(SDL_Window* window) { return SDL_SyncWindow(window); }

//! @copydoc SDL_WindowHasSurface()
inline bool WindowHasSurface(SDL_Window* window) { return SDL_WindowHasSurface(window); }

//! @copydoc SDL_GetWindowSurface()
inline SDL_Surface* GetWindowSurface(SDL_Window* window) { auto _ret = SDL_GetWindowSurface(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetWindowSurfaceVSync()
inline void SetWindowSurfaceVSync(SDL_Window* window, int vsync) { auto _ret = SDL_SetWindowSurfaceVSync(window, vsync); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowSurfaceVSync()
inline void GetWindowSurfaceVSync(SDL_Window* window, int* vsync) { auto _ret = SDL_GetWindowSurfaceVSync(window, vsync); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UpdateWindowSurface()
inline void UpdateWindowSurface(SDL_Window* window) { auto _ret = SDL_UpdateWindowSurface(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UpdateWindowSurfaceRects()
inline void UpdateWindowSurfaceRects(SDL_Window* window, const SDL_Rect* rects, int numrects) { auto _ret = SDL_UpdateWindowSurfaceRects(window, rects, numrects); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyWindowSurface()
inline void DestroyWindowSurface(SDL_Window* window) { auto _ret = SDL_DestroyWindowSurface(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowKeyboardGrab()
inline void SetWindowKeyboardGrab(SDL_Window* window, bool grabbed) { auto _ret = SDL_SetWindowKeyboardGrab(window, grabbed); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowMouseGrab()
inline void SetWindowMouseGrab(SDL_Window* window, bool grabbed) { auto _ret = SDL_SetWindowMouseGrab(window, grabbed); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowKeyboardGrab()
inline bool GetWindowKeyboardGrab(SDL_Window* window) { return SDL_GetWindowKeyboardGrab(window); }

//! @copydoc SDL_GetWindowMouseGrab()
inline bool GetWindowMouseGrab(SDL_Window* window) { return SDL_GetWindowMouseGrab(window); }

//! @copydoc SDL_GetGrabbedWindow()
inline SDL_Window* GetGrabbedWindow() { return SDL_GetGrabbedWindow(); }

//! @copydoc SDL_SetWindowMouseRect()
inline void SetWindowMouseRect(SDL_Window* window, const SDL_Rect* rect) { auto _ret = SDL_SetWindowMouseRect(window, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowMouseRect()
inline const SDL_Rect* GetWindowMouseRect(SDL_Window* window) { return SDL_GetWindowMouseRect(window); }

//! @copydoc SDL_SetWindowOpacity()
inline void SetWindowOpacity(SDL_Window* window, float opacity) { auto _ret = SDL_SetWindowOpacity(window, opacity); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowOpacity()
inline float GetWindowOpacity(SDL_Window* window) { auto _ret = SDL_GetWindowOpacity(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetWindowParent()
inline void SetWindowParent(SDL_Window* window, SDL_Window* parent) { auto _ret = SDL_SetWindowParent(window, parent); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowModal()
inline void SetWindowModal(SDL_Window* window, bool modal) { auto _ret = SDL_SetWindowModal(window, modal); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowFocusable()
inline void SetWindowFocusable(SDL_Window* window, bool focusable) { auto _ret = SDL_SetWindowFocusable(window, focusable); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ShowWindowSystemMenu()
inline void ShowWindowSystemMenu(SDL_Window* window, int x, int y) { auto _ret = SDL_ShowWindowSystemMenu(window, x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowHitTest()
inline void SetWindowHitTest(SDL_Window* window, SDL_HitTest callback, void* callback_data) { auto _ret = SDL_SetWindowHitTest(window, callback, callback_data); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowShape()
inline void SetWindowShape(SDL_Window* window, SDL_Surface* shape) { auto _ret = SDL_SetWindowShape(window, shape); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_FlashWindow()
inline void FlashWindow(SDL_Window* window, SDL_FlashOperation operation) { auto _ret = SDL_FlashWindow(window, operation); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyWindow()
inline void DestroyWindow(SDL_Window* window) { SDL_DestroyWindow(window); }

//! @copydoc SDL_ScreenSaverEnabled()
inline bool ScreenSaverEnabled() { return SDL_ScreenSaverEnabled(); }

//! @copydoc SDL_EnableScreenSaver()
inline void EnableScreenSaver() { auto _ret = SDL_EnableScreenSaver(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DisableScreenSaver()
inline void DisableScreenSaver() { auto _ret = SDL_DisableScreenSaver(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_LoadLibrary()
inline void GL_LoadLibrary(const char* path) { auto _ret = SDL_GL_LoadLibrary(path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_GetProcAddress()
inline SDL_FunctionPointer GL_GetProcAddress(const char* proc) { return SDL_GL_GetProcAddress(proc); }

//! @copydoc SDL_EGL_GetProcAddress()
inline SDL_FunctionPointer EGL_GetProcAddress(const char* proc) { return SDL_EGL_GetProcAddress(proc); }

//! @copydoc SDL_GL_UnloadLibrary()
inline void GL_UnloadLibrary() { SDL_GL_UnloadLibrary(); }

//! @copydoc SDL_GL_ExtensionSupported()
inline bool GL_ExtensionSupported(const char* extension) { return SDL_GL_ExtensionSupported(extension); }

//! @copydoc SDL_GL_ResetAttributes()
inline void GL_ResetAttributes() { SDL_GL_ResetAttributes(); }

//! @copydoc SDL_GL_SetAttribute()
inline void GL_SetAttribute(SDL_GLAttr attr, int value) { auto _ret = SDL_GL_SetAttribute(attr, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_GetAttribute()
inline void GL_GetAttribute(SDL_GLAttr attr, int* value) { auto _ret = SDL_GL_GetAttribute(attr, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_CreateContext()
inline SDL_GLContext GL_CreateContext(SDL_Window* window) { auto _ret = SDL_GL_CreateContext(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GL_MakeCurrent()
inline void GL_MakeCurrent(SDL_Window* window, SDL_GLContext context) { auto _ret = SDL_GL_MakeCurrent(window, context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_GetCurrentWindow()
inline SDL_Window* GL_GetCurrentWindow() { auto _ret = SDL_GL_GetCurrentWindow(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GL_GetCurrentContext()
inline SDL_GLContext GL_GetCurrentContext() { auto _ret = SDL_GL_GetCurrentContext(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_EGL_GetCurrentDisplay()
inline SDL_EGLDisplay EGL_GetCurrentDisplay() { auto _ret = SDL_EGL_GetCurrentDisplay(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_EGL_GetCurrentConfig()
inline SDL_EGLConfig EGL_GetCurrentConfig() { auto _ret = SDL_EGL_GetCurrentConfig(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_EGL_GetWindowSurface()
inline SDL_EGLSurface EGL_GetWindowSurface(SDL_Window* window) { return SDL_EGL_GetWindowSurface(window); }

//! @copydoc SDL_EGL_SetAttributeCallbacks()
inline void EGL_SetAttributeCallbacks(SDL_EGLAttribArrayCallback platformAttribCallback, SDL_EGLIntArrayCallback surfaceAttribCallback, SDL_EGLIntArrayCallback contextAttribCallback, void* userdata) { SDL_EGL_SetAttributeCallbacks(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata); }

//! @copydoc SDL_GL_SetSwapInterval()
inline void GL_SetSwapInterval(int interval) { auto _ret = SDL_GL_SetSwapInterval(interval); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_GetSwapInterval()
inline void GL_GetSwapInterval(int* interval) { auto _ret = SDL_GL_GetSwapInterval(interval); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_SwapWindow()
inline void GL_SwapWindow(SDL_Window* window) { auto _ret = SDL_GL_SwapWindow(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GL_DestroyContext()
inline void GL_DestroyContext(SDL_GLContext context) { auto _ret = SDL_GL_DestroyContext(context); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ShowOpenFileDialog()
inline void ShowOpenFileDialog(SDL_DialogFileCallback callback, void* userdata, SDL_Window* window, const SDL_DialogFileFilter* filters, int nfilters, const char* default_location, bool allow_many) { SDL_ShowOpenFileDialog(callback, userdata, window, filters, nfilters, default_location, allow_many); }

//! @copydoc SDL_ShowSaveFileDialog()
inline void ShowSaveFileDialog(SDL_DialogFileCallback callback, void* userdata, SDL_Window* window, const SDL_DialogFileFilter* filters, int nfilters, const char* default_location) { SDL_ShowSaveFileDialog(callback, userdata, window, filters, nfilters, default_location); }

//! @copydoc SDL_ShowOpenFolderDialog()
inline void ShowOpenFolderDialog(SDL_DialogFileCallback callback, void* userdata, SDL_Window* window, const char* default_location, bool allow_many) { SDL_ShowOpenFolderDialog(callback, userdata, window, default_location, allow_many); }

//! @copydoc SDL_ShowFileDialogWithProperties()
inline void ShowFileDialogWithProperties(SDL_FileDialogType type, SDL_DialogFileCallback callback, void* userdata, SDL_PropertiesID props) { SDL_ShowFileDialogWithProperties(type, callback, userdata, props); }

//! @copydoc SDL_GUIDToString()
inline void GUIDToString(SDL_GUID guid, char* pszGUID, int cbGUID) { SDL_GUIDToString(guid, pszGUID, cbGUID); }

//! @copydoc SDL_StringToGUID()
inline SDL_GUID StringToGUID(const char* pchGUID) { return SDL_StringToGUID(pchGUID); }

//! @copydoc SDL_GetPowerInfo()
inline SDL_PowerState GetPowerInfo(int* seconds, int* percent) { auto _ret = SDL_GetPowerInfo(seconds, percent); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensors()
inline SDL_SensorID* GetSensors(int* count) { auto _ret = SDL_GetSensors(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorNameForID()
inline const char* GetSensorNameForID(SDL_SensorID instance_id) { return SDL_GetSensorNameForID(instance_id); }

//! @copydoc SDL_GetSensorTypeForID()
inline SDL_SensorType GetSensorTypeForID(SDL_SensorID instance_id) { return SDL_GetSensorTypeForID(instance_id); }

//! @copydoc SDL_GetSensorNonPortableTypeForID()
inline int GetSensorNonPortableTypeForID(SDL_SensorID instance_id) { return SDL_GetSensorNonPortableTypeForID(instance_id); }

//! @copydoc SDL_OpenSensor()
inline SDL_Sensor* OpenSensor(SDL_SensorID instance_id) { auto _ret = SDL_OpenSensor(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorFromID()
inline SDL_Sensor* GetSensorFromID(SDL_SensorID instance_id) { auto _ret = SDL_GetSensorFromID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorProperties()
inline SDL_PropertiesID GetSensorProperties(SDL_Sensor* sensor) { auto _ret = SDL_GetSensorProperties(sensor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorName()
inline const char* GetSensorName(SDL_Sensor* sensor) { auto _ret = SDL_GetSensorName(sensor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorType()
inline SDL_SensorType GetSensorType(SDL_Sensor* sensor) { return SDL_GetSensorType(sensor); }

//! @copydoc SDL_GetSensorNonPortableType()
inline int GetSensorNonPortableType(SDL_Sensor* sensor) { return SDL_GetSensorNonPortableType(sensor); }

//! @copydoc SDL_GetSensorID()
inline SDL_SensorID GetSensorID(SDL_Sensor* sensor) { auto _ret = SDL_GetSensorID(sensor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetSensorData()
inline void GetSensorData(SDL_Sensor* sensor, float* data, int num_values) { auto _ret = SDL_GetSensorData(sensor, data, num_values); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CloseSensor()
inline void CloseSensor(SDL_Sensor* sensor) { SDL_CloseSensor(sensor); }

//! @copydoc SDL_UpdateSensors()
inline void UpdateSensors() { SDL_UpdateSensors(); }

//! @copydoc SDL_LockJoysticks()
inline void LockJoysticks() { SDL_LockJoysticks(); }

//! @copydoc SDL_UnlockJoysticks()
inline void UnlockJoysticks() { SDL_UnlockJoysticks(); }

//! @copydoc SDL_HasJoystick()
inline bool HasJoystick() { return SDL_HasJoystick(); }

//! @copydoc SDL_GetJoysticks()
inline SDL_JoystickID* GetJoysticks(int* count) { auto _ret = SDL_GetJoysticks(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickNameForID()
inline const char* GetJoystickNameForID(SDL_JoystickID instance_id) { auto _ret = SDL_GetJoystickNameForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickPathForID()
inline const char* GetJoystickPathForID(SDL_JoystickID instance_id) { auto _ret = SDL_GetJoystickPathForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickPlayerIndexForID()
inline int GetJoystickPlayerIndexForID(SDL_JoystickID instance_id) { return SDL_GetJoystickPlayerIndexForID(instance_id); }

//! @copydoc SDL_GetJoystickGUIDForID()
inline SDL_GUID GetJoystickGUIDForID(SDL_JoystickID instance_id) { return SDL_GetJoystickGUIDForID(instance_id); }

//! @copydoc SDL_GetJoystickVendorForID()
inline Uint16 GetJoystickVendorForID(SDL_JoystickID instance_id) { return SDL_GetJoystickVendorForID(instance_id); }

//! @copydoc SDL_GetJoystickProductForID()
inline Uint16 GetJoystickProductForID(SDL_JoystickID instance_id) { return SDL_GetJoystickProductForID(instance_id); }

//! @copydoc SDL_GetJoystickProductVersionForID()
inline Uint16 GetJoystickProductVersionForID(SDL_JoystickID instance_id) { return SDL_GetJoystickProductVersionForID(instance_id); }

//! @copydoc SDL_GetJoystickTypeForID()
inline SDL_JoystickType GetJoystickTypeForID(SDL_JoystickID instance_id) { return SDL_GetJoystickTypeForID(instance_id); }

//! @copydoc SDL_OpenJoystick()
inline SDL_Joystick* OpenJoystick(SDL_JoystickID instance_id) { auto _ret = SDL_OpenJoystick(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickFromID()
inline SDL_Joystick* GetJoystickFromID(SDL_JoystickID instance_id) { auto _ret = SDL_GetJoystickFromID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickFromPlayerIndex()
inline SDL_Joystick* GetJoystickFromPlayerIndex(int player_index) { auto _ret = SDL_GetJoystickFromPlayerIndex(player_index); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_AttachVirtualJoystick()
inline SDL_JoystickID AttachVirtualJoystick(const SDL_VirtualJoystickDesc* desc) { auto _ret = SDL_AttachVirtualJoystick(desc); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DetachVirtualJoystick()
inline void DetachVirtualJoystick(SDL_JoystickID instance_id) { auto _ret = SDL_DetachVirtualJoystick(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_IsJoystickVirtual()
inline bool IsJoystickVirtual(SDL_JoystickID instance_id) { return SDL_IsJoystickVirtual(instance_id); }

//! @copydoc SDL_SetJoystickVirtualAxis()
inline void SetJoystickVirtualAxis(SDL_Joystick* joystick, int axis, Sint16 value) { auto _ret = SDL_SetJoystickVirtualAxis(joystick, axis, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetJoystickVirtualBall()
inline void SetJoystickVirtualBall(SDL_Joystick* joystick, int ball, Sint16 xrel, Sint16 yrel) { auto _ret = SDL_SetJoystickVirtualBall(joystick, ball, xrel, yrel); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetJoystickVirtualButton()
inline void SetJoystickVirtualButton(SDL_Joystick* joystick, int button, bool down) { auto _ret = SDL_SetJoystickVirtualButton(joystick, button, down); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetJoystickVirtualHat()
inline void SetJoystickVirtualHat(SDL_Joystick* joystick, int hat, Uint8 value) { auto _ret = SDL_SetJoystickVirtualHat(joystick, hat, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetJoystickVirtualTouchpad()
inline void SetJoystickVirtualTouchpad(SDL_Joystick* joystick, int touchpad, int finger, bool down, float x, float y, float pressure) { auto _ret = SDL_SetJoystickVirtualTouchpad(joystick, touchpad, finger, down, x, y, pressure); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SendJoystickVirtualSensorData()
inline void SendJoystickVirtualSensorData(SDL_Joystick* joystick, SDL_SensorType type, Uint64 sensor_timestamp, const float* data, int num_values) { auto _ret = SDL_SendJoystickVirtualSensorData(joystick, type, sensor_timestamp, data, num_values); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetJoystickProperties()
inline SDL_PropertiesID GetJoystickProperties(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickProperties(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickName()
inline const char* GetJoystickName(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickName(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickPath()
inline const char* GetJoystickPath(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickPath(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickPlayerIndex()
inline int GetJoystickPlayerIndex(SDL_Joystick* joystick) { return SDL_GetJoystickPlayerIndex(joystick); }

//! @copydoc SDL_SetJoystickPlayerIndex()
inline void SetJoystickPlayerIndex(SDL_Joystick* joystick, int player_index) { auto _ret = SDL_SetJoystickPlayerIndex(joystick, player_index); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetJoystickGUID()
inline SDL_GUID GetJoystickGUID(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickGUID(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickVendor()
inline Uint16 GetJoystickVendor(SDL_Joystick* joystick) { return SDL_GetJoystickVendor(joystick); }

//! @copydoc SDL_GetJoystickProduct()
inline Uint16 GetJoystickProduct(SDL_Joystick* joystick) { return SDL_GetJoystickProduct(joystick); }

//! @copydoc SDL_GetJoystickProductVersion()
inline Uint16 GetJoystickProductVersion(SDL_Joystick* joystick) { return SDL_GetJoystickProductVersion(joystick); }

//! @copydoc SDL_GetJoystickFirmwareVersion()
inline Uint16 GetJoystickFirmwareVersion(SDL_Joystick* joystick) { return SDL_GetJoystickFirmwareVersion(joystick); }

//! @copydoc SDL_GetJoystickSerial()
inline const char* GetJoystickSerial(SDL_Joystick* joystick) { return SDL_GetJoystickSerial(joystick); }

//! @copydoc SDL_GetJoystickType()
inline SDL_JoystickType GetJoystickType(SDL_Joystick* joystick) { return SDL_GetJoystickType(joystick); }

//! @copydoc SDL_GetJoystickGUIDInfo()
inline void GetJoystickGUIDInfo(SDL_GUID guid, Uint16* vendor, Uint16* product, Uint16* version, Uint16* crc16) { SDL_GetJoystickGUIDInfo(guid, vendor, product, version, crc16); }

//! @copydoc SDL_JoystickConnected()
inline void JoystickConnected(SDL_Joystick* joystick) { auto _ret = SDL_JoystickConnected(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetJoystickID()
inline SDL_JoystickID GetJoystickID(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickID(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumJoystickAxes()
inline int GetNumJoystickAxes(SDL_Joystick* joystick) { auto _ret = SDL_GetNumJoystickAxes(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumJoystickBalls()
inline int GetNumJoystickBalls(SDL_Joystick* joystick) { auto _ret = SDL_GetNumJoystickBalls(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumJoystickHats()
inline int GetNumJoystickHats(SDL_Joystick* joystick) { auto _ret = SDL_GetNumJoystickHats(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumJoystickButtons()
inline int GetNumJoystickButtons(SDL_Joystick* joystick) { auto _ret = SDL_GetNumJoystickButtons(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetJoystickEventsEnabled()
inline void SetJoystickEventsEnabled(bool enabled) { SDL_SetJoystickEventsEnabled(enabled); }

//! @copydoc SDL_JoystickEventsEnabled()
inline bool JoystickEventsEnabled() { return SDL_JoystickEventsEnabled(); }

//! @copydoc SDL_UpdateJoysticks()
inline void UpdateJoysticks() { SDL_UpdateJoysticks(); }

//! @copydoc SDL_GetJoystickAxis()
inline Sint16 GetJoystickAxis(SDL_Joystick* joystick, int axis) { auto _ret = SDL_GetJoystickAxis(joystick, axis); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickAxisInitialState()
inline bool GetJoystickAxisInitialState(SDL_Joystick* joystick, int axis, Sint16* state) { return SDL_GetJoystickAxisInitialState(joystick, axis, state); }

//! @copydoc SDL_GetJoystickBall()
inline void GetJoystickBall(SDL_Joystick* joystick, int ball, int* dx, int* dy) { auto _ret = SDL_GetJoystickBall(joystick, ball, dx, dy); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetJoystickHat()
inline Uint8 GetJoystickHat(SDL_Joystick* joystick, int hat) { return SDL_GetJoystickHat(joystick, hat); }

//! @copydoc SDL_GetJoystickButton()
inline bool GetJoystickButton(SDL_Joystick* joystick, int button) { return SDL_GetJoystickButton(joystick, button); }

//! @copydoc SDL_RumbleJoystick()
inline bool RumbleJoystick(SDL_Joystick* joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms) { return SDL_RumbleJoystick(joystick, low_frequency_rumble, high_frequency_rumble, duration_ms); }

//! @copydoc SDL_RumbleJoystickTriggers()
inline void RumbleJoystickTriggers(SDL_Joystick* joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms) { auto _ret = SDL_RumbleJoystickTriggers(joystick, left_rumble, right_rumble, duration_ms); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetJoystickLED()
inline void SetJoystickLED(SDL_Joystick* joystick, Uint8 red, Uint8 green, Uint8 blue) { auto _ret = SDL_SetJoystickLED(joystick, red, green, blue); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SendJoystickEffect()
inline void SendJoystickEffect(SDL_Joystick* joystick, const void* data, int size) { auto _ret = SDL_SendJoystickEffect(joystick, data, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CloseJoystick()
inline void CloseJoystick(SDL_Joystick* joystick) { SDL_CloseJoystick(joystick); }

//! @copydoc SDL_GetJoystickConnectionState()
inline SDL_JoystickConnectionState GetJoystickConnectionState(SDL_Joystick* joystick) { auto _ret = SDL_GetJoystickConnectionState(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetJoystickPowerInfo()
inline SDL_PowerState GetJoystickPowerInfo(SDL_Joystick* joystick, int* percent) { auto _ret = SDL_GetJoystickPowerInfo(joystick, percent); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_AddGamepadMapping()
inline int AddGamepadMapping(const char* mapping) { auto _ret = SDL_AddGamepadMapping(mapping); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_AddGamepadMappingsFromIO()
inline int AddGamepadMappingsFromIO(SDL_IOStream* src, bool closeio) { auto _ret = SDL_AddGamepadMappingsFromIO(src, closeio); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_AddGamepadMappingsFromFile()
inline int AddGamepadMappingsFromFile(const char* file) { auto _ret = SDL_AddGamepadMappingsFromFile(file); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ReloadGamepadMappings()
inline void ReloadGamepadMappings() { auto _ret = SDL_ReloadGamepadMappings(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetGamepadMappings()
inline char** GetGamepadMappings(int* count) { auto _ret = SDL_GetGamepadMappings(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadMappingForGUID()
inline char* GetGamepadMappingForGUID(SDL_GUID guid) { auto _ret = SDL_GetGamepadMappingForGUID(guid); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadMapping()
inline char* GetGamepadMapping(SDL_Gamepad* gamepad) { auto _ret = SDL_GetGamepadMapping(gamepad); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetGamepadMapping()
inline void SetGamepadMapping(SDL_JoystickID instance_id, const char* mapping) { auto _ret = SDL_SetGamepadMapping(instance_id, mapping); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HasGamepad()
inline bool HasGamepad() { return SDL_HasGamepad(); }

//! @copydoc SDL_GetGamepads()
inline SDL_JoystickID* GetGamepads(int* count) { auto _ret = SDL_GetGamepads(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IsGamepad()
inline bool IsGamepad(SDL_JoystickID instance_id) { return SDL_IsGamepad(instance_id); }

//! @copydoc SDL_GetGamepadNameForID()
inline const char* GetGamepadNameForID(SDL_JoystickID instance_id) { auto _ret = SDL_GetGamepadNameForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadPathForID()
inline const char* GetGamepadPathForID(SDL_JoystickID instance_id) { auto _ret = SDL_GetGamepadPathForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadPlayerIndexForID()
inline int GetGamepadPlayerIndexForID(SDL_JoystickID instance_id) { return SDL_GetGamepadPlayerIndexForID(instance_id); }

//! @copydoc SDL_GetGamepadGUIDForID()
inline SDL_GUID GetGamepadGUIDForID(SDL_JoystickID instance_id) { return SDL_GetGamepadGUIDForID(instance_id); }

//! @copydoc SDL_GetGamepadVendorForID()
inline Uint16 GetGamepadVendorForID(SDL_JoystickID instance_id) { return SDL_GetGamepadVendorForID(instance_id); }

//! @copydoc SDL_GetGamepadProductForID()
inline Uint16 GetGamepadProductForID(SDL_JoystickID instance_id) { return SDL_GetGamepadProductForID(instance_id); }

//! @copydoc SDL_GetGamepadProductVersionForID()
inline Uint16 GetGamepadProductVersionForID(SDL_JoystickID instance_id) { return SDL_GetGamepadProductVersionForID(instance_id); }

//! @copydoc SDL_GetGamepadTypeForID()
inline SDL_GamepadType GetGamepadTypeForID(SDL_JoystickID instance_id) { return SDL_GetGamepadTypeForID(instance_id); }

//! @copydoc SDL_GetRealGamepadTypeForID()
inline SDL_GamepadType GetRealGamepadTypeForID(SDL_JoystickID instance_id) { return SDL_GetRealGamepadTypeForID(instance_id); }

//! @copydoc SDL_GetGamepadMappingForID()
inline char* GetGamepadMappingForID(SDL_JoystickID instance_id) { return SDL_GetGamepadMappingForID(instance_id); }

//! @copydoc SDL_OpenGamepad()
inline SDL_Gamepad* OpenGamepad(SDL_JoystickID instance_id) { auto _ret = SDL_OpenGamepad(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadFromID()
inline SDL_Gamepad* GetGamepadFromID(SDL_JoystickID instance_id) { auto _ret = SDL_GetGamepadFromID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadFromPlayerIndex()
inline SDL_Gamepad* GetGamepadFromPlayerIndex(int player_index) { return SDL_GetGamepadFromPlayerIndex(player_index); }

//! @copydoc SDL_GetGamepadProperties()
inline SDL_PropertiesID GetGamepadProperties(SDL_Gamepad* gamepad) { auto _ret = SDL_GetGamepadProperties(gamepad); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadID()
inline SDL_JoystickID GetGamepadID(SDL_Gamepad* gamepad) { auto _ret = SDL_GetGamepadID(gamepad); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadName()
inline const char* GetGamepadName(SDL_Gamepad* gamepad) { return SDL_GetGamepadName(gamepad); }

//! @copydoc SDL_GetGamepadPath()
inline const char* GetGamepadPath(SDL_Gamepad* gamepad) { return SDL_GetGamepadPath(gamepad); }

//! @copydoc SDL_GetGamepadType()
inline SDL_GamepadType GetGamepadType(SDL_Gamepad* gamepad) { return SDL_GetGamepadType(gamepad); }

//! @copydoc SDL_GetRealGamepadType()
inline SDL_GamepadType GetRealGamepadType(SDL_Gamepad* gamepad) { return SDL_GetRealGamepadType(gamepad); }

//! @copydoc SDL_GetGamepadPlayerIndex()
inline int GetGamepadPlayerIndex(SDL_Gamepad* gamepad) { return SDL_GetGamepadPlayerIndex(gamepad); }

//! @copydoc SDL_SetGamepadPlayerIndex()
inline void SetGamepadPlayerIndex(SDL_Gamepad* gamepad, int player_index) { auto _ret = SDL_SetGamepadPlayerIndex(gamepad, player_index); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetGamepadVendor()
inline Uint16 GetGamepadVendor(SDL_Gamepad* gamepad) { return SDL_GetGamepadVendor(gamepad); }

//! @copydoc SDL_GetGamepadProduct()
inline Uint16 GetGamepadProduct(SDL_Gamepad* gamepad) { return SDL_GetGamepadProduct(gamepad); }

//! @copydoc SDL_GetGamepadProductVersion()
inline Uint16 GetGamepadProductVersion(SDL_Gamepad* gamepad) { return SDL_GetGamepadProductVersion(gamepad); }

//! @copydoc SDL_GetGamepadFirmwareVersion()
inline Uint16 GetGamepadFirmwareVersion(SDL_Gamepad* gamepad) { return SDL_GetGamepadFirmwareVersion(gamepad); }

//! @copydoc SDL_GetGamepadSerial()
inline const char* GetGamepadSerial(SDL_Gamepad* gamepad) { return SDL_GetGamepadSerial(gamepad); }

//! @copydoc SDL_GetGamepadSteamHandle()
inline Uint64 GetGamepadSteamHandle(SDL_Gamepad* gamepad) { return SDL_GetGamepadSteamHandle(gamepad); }

//! @copydoc SDL_GetGamepadConnectionState()
inline SDL_JoystickConnectionState GetGamepadConnectionState(SDL_Gamepad* gamepad) { auto _ret = SDL_GetGamepadConnectionState(gamepad); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadPowerInfo()
inline SDL_PowerState GetGamepadPowerInfo(SDL_Gamepad* gamepad, int* percent) { return SDL_GetGamepadPowerInfo(gamepad, percent); }

//! @copydoc SDL_GamepadConnected()
inline bool GamepadConnected(SDL_Gamepad* gamepad) { return SDL_GamepadConnected(gamepad); }

//! @copydoc SDL_GetGamepadJoystick()
inline SDL_Joystick* GetGamepadJoystick(SDL_Gamepad* gamepad) { auto _ret = SDL_GetGamepadJoystick(gamepad); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetGamepadEventsEnabled()
inline void SetGamepadEventsEnabled(bool enabled) { SDL_SetGamepadEventsEnabled(enabled); }

//! @copydoc SDL_GamepadEventsEnabled()
inline bool GamepadEventsEnabled() { return SDL_GamepadEventsEnabled(); }

//! @copydoc SDL_GetGamepadBindings()
inline SDL_GamepadBinding** GetGamepadBindings(SDL_Gamepad* gamepad, int* count) { auto _ret = SDL_GetGamepadBindings(gamepad, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_UpdateGamepads()
inline void UpdateGamepads() { SDL_UpdateGamepads(); }

//! @copydoc SDL_GetGamepadTypeFromString()
inline SDL_GamepadType GetGamepadTypeFromString(const char* str) { return SDL_GetGamepadTypeFromString(str); }

//! @copydoc SDL_GetGamepadStringForType()
inline const char* GetGamepadStringForType(SDL_GamepadType type) { return SDL_GetGamepadStringForType(type); }

//! @copydoc SDL_GetGamepadAxisFromString()
inline SDL_GamepadAxis GetGamepadAxisFromString(const char* str) { return SDL_GetGamepadAxisFromString(str); }

//! @copydoc SDL_GetGamepadStringForAxis()
inline const char* GetGamepadStringForAxis(SDL_GamepadAxis axis) { return SDL_GetGamepadStringForAxis(axis); }

//! @copydoc SDL_GamepadHasAxis()
inline bool GamepadHasAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { return SDL_GamepadHasAxis(gamepad, axis); }

//! @copydoc SDL_GetGamepadAxis()
inline Sint16 GetGamepadAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { auto _ret = SDL_GetGamepadAxis(gamepad, axis); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetGamepadButtonFromString()
inline SDL_GamepadButton GetGamepadButtonFromString(const char* str) { return SDL_GetGamepadButtonFromString(str); }

//! @copydoc SDL_GetGamepadStringForButton()
inline const char* GetGamepadStringForButton(SDL_GamepadButton button) { return SDL_GetGamepadStringForButton(button); }

//! @copydoc SDL_GamepadHasButton()
inline bool GamepadHasButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL_GamepadHasButton(gamepad, button); }

//! @copydoc SDL_GetGamepadButton()
inline bool GetGamepadButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL_GetGamepadButton(gamepad, button); }

//! @copydoc SDL_GetGamepadButtonLabelForType()
inline SDL_GamepadButtonLabel GetGamepadButtonLabelForType(SDL_GamepadType type, SDL_GamepadButton button) { return SDL_GetGamepadButtonLabelForType(type, button); }

//! @copydoc SDL_GetGamepadButtonLabel()
inline SDL_GamepadButtonLabel GetGamepadButtonLabel(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL_GetGamepadButtonLabel(gamepad, button); }

//! @copydoc SDL_GetNumGamepadTouchpads()
inline int GetNumGamepadTouchpads(SDL_Gamepad* gamepad) { return SDL_GetNumGamepadTouchpads(gamepad); }

//! @copydoc SDL_GetNumGamepadTouchpadFingers()
inline int GetNumGamepadTouchpadFingers(SDL_Gamepad* gamepad, int touchpad) { return SDL_GetNumGamepadTouchpadFingers(gamepad, touchpad); }

//! @copydoc SDL_GetGamepadTouchpadFinger()
inline void GetGamepadTouchpadFinger(SDL_Gamepad* gamepad, int touchpad, int finger, bool* down, float* x, float* y, float* pressure) { auto _ret = SDL_GetGamepadTouchpadFinger(gamepad, touchpad, finger, down, x, y, pressure); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GamepadHasSensor()
inline bool GamepadHasSensor(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL_GamepadHasSensor(gamepad, type); }

//! @copydoc SDL_SetGamepadSensorEnabled()
inline void SetGamepadSensorEnabled(SDL_Gamepad* gamepad, SDL_SensorType type, bool enabled) { auto _ret = SDL_SetGamepadSensorEnabled(gamepad, type, enabled); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GamepadSensorEnabled()
inline bool GamepadSensorEnabled(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL_GamepadSensorEnabled(gamepad, type); }

//! @copydoc SDL_GetGamepadSensorDataRate()
inline float GetGamepadSensorDataRate(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL_GetGamepadSensorDataRate(gamepad, type); }

//! @copydoc SDL_GetGamepadSensorData()
inline void GetGamepadSensorData(SDL_Gamepad* gamepad, SDL_SensorType type, float* data, int num_values) { auto _ret = SDL_GetGamepadSensorData(gamepad, type, data, num_values); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RumbleGamepad()
inline void RumbleGamepad(SDL_Gamepad* gamepad, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms) { auto _ret = SDL_RumbleGamepad(gamepad, low_frequency_rumble, high_frequency_rumble, duration_ms); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RumbleGamepadTriggers()
inline void RumbleGamepadTriggers(SDL_Gamepad* gamepad, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms) { auto _ret = SDL_RumbleGamepadTriggers(gamepad, left_rumble, right_rumble, duration_ms); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetGamepadLED()
inline void SetGamepadLED(SDL_Gamepad* gamepad, Uint8 red, Uint8 green, Uint8 blue) { auto _ret = SDL_SetGamepadLED(gamepad, red, green, blue); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SendGamepadEffect()
inline void SendGamepadEffect(SDL_Gamepad* gamepad, const void* data, int size) { auto _ret = SDL_SendGamepadEffect(gamepad, data, size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CloseGamepad()
inline void CloseGamepad(SDL_Gamepad* gamepad) { SDL_CloseGamepad(gamepad); }

//! @copydoc SDL_GetGamepadAppleSFSymbolsNameForButton()
inline const char* GetGamepadAppleSFSymbolsNameForButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL_GetGamepadAppleSFSymbolsNameForButton(gamepad, button); }

//! @copydoc SDL_GetGamepadAppleSFSymbolsNameForAxis()
inline const char* GetGamepadAppleSFSymbolsNameForAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { return SDL_GetGamepadAppleSFSymbolsNameForAxis(gamepad, axis); }

//! @copydoc SDL_HasKeyboard()
inline bool HasKeyboard() { return SDL_HasKeyboard(); }

//! @copydoc SDL_GetKeyboards()
inline SDL_KeyboardID* GetKeyboards(int* count) { auto _ret = SDL_GetKeyboards(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetKeyboardNameForID()
inline const char* GetKeyboardNameForID(SDL_KeyboardID instance_id) { auto _ret = SDL_GetKeyboardNameForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetKeyboardFocus()
inline SDL_Window* GetKeyboardFocus() { return SDL_GetKeyboardFocus(); }

//! @copydoc SDL_GetKeyboardState()
inline const bool* GetKeyboardState(int* numkeys) { return SDL_GetKeyboardState(numkeys); }

//! @copydoc SDL_ResetKeyboard()
inline void ResetKeyboard() { SDL_ResetKeyboard(); }

//! @copydoc SDL_GetModState()
inline SDL_Keymod GetModState() { return SDL_GetModState(); }

//! @copydoc SDL_SetModState()
inline void SetModState(SDL_Keymod modstate) { SDL_SetModState(modstate); }

//! @copydoc SDL_GetKeyFromScancode()
inline SDL_Keycode GetKeyFromScancode(SDL_Scancode scancode, SDL_Keymod modstate, bool key_event) { return SDL_GetKeyFromScancode(scancode, modstate, key_event); }

//! @copydoc SDL_GetScancodeFromKey()
inline SDL_Scancode GetScancodeFromKey(SDL_Keycode key, SDL_Keymod* modstate) { return SDL_GetScancodeFromKey(key, modstate); }

//! @copydoc SDL_SetScancodeName()
inline void SetScancodeName(SDL_Scancode scancode, const char* name) { auto _ret = SDL_SetScancodeName(scancode, name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetScancodeName()
inline const char* GetScancodeName(SDL_Scancode scancode) { return SDL_GetScancodeName(scancode); }

//! @copydoc SDL_GetScancodeFromName()
inline SDL_Scancode GetScancodeFromName(const char* name) { auto _ret = SDL_GetScancodeFromName(name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetKeyName()
inline const char* GetKeyName(SDL_Keycode key) { return SDL_GetKeyName(key); }

//! @copydoc SDL_GetKeyFromName()
inline SDL_Keycode GetKeyFromName(const char* name) { auto _ret = SDL_GetKeyFromName(name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_StartTextInput()
inline void StartTextInput(SDL_Window* window) { auto _ret = SDL_StartTextInput(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_StartTextInputWithProperties()
inline void StartTextInputWithProperties(SDL_Window* window, SDL_PropertiesID props) { auto _ret = SDL_StartTextInputWithProperties(window, props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_TextInputActive()
inline bool TextInputActive(SDL_Window* window) { return SDL_TextInputActive(window); }

//! @copydoc SDL_StopTextInput()
inline void StopTextInput(SDL_Window* window) { auto _ret = SDL_StopTextInput(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ClearComposition()
inline void ClearComposition(SDL_Window* window) { auto _ret = SDL_ClearComposition(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextInputArea()
inline void SetTextInputArea(SDL_Window* window, const SDL_Rect* rect, int cursor) { auto _ret = SDL_SetTextInputArea(window, rect, cursor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextInputArea()
inline void GetTextInputArea(SDL_Window* window, SDL_Rect* rect, int* cursor) { auto _ret = SDL_GetTextInputArea(window, rect, cursor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HasScreenKeyboardSupport()
inline bool HasScreenKeyboardSupport() { return SDL_HasScreenKeyboardSupport(); }

//! @copydoc SDL_ScreenKeyboardShown()
inline bool ScreenKeyboardShown(SDL_Window* window) { return SDL_ScreenKeyboardShown(window); }

//! @copydoc SDL_HasMouse()
inline bool HasMouse() { return SDL_HasMouse(); }

//! @copydoc SDL_GetMice()
inline SDL_MouseID* GetMice(int* count) { auto _ret = SDL_GetMice(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetMouseNameForID()
inline const char* GetMouseNameForID(SDL_MouseID instance_id) { auto _ret = SDL_GetMouseNameForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetMouseFocus()
inline SDL_Window* GetMouseFocus() { return SDL_GetMouseFocus(); }

//! @copydoc SDL_GetMouseState()
inline SDL_MouseButtonFlags GetMouseState(float* x, float* y) { return SDL_GetMouseState(x, y); }

//! @copydoc SDL_GetGlobalMouseState()
inline SDL_MouseButtonFlags GetGlobalMouseState(float* x, float* y) { return SDL_GetGlobalMouseState(x, y); }

//! @copydoc SDL_GetRelativeMouseState()
inline SDL_MouseButtonFlags GetRelativeMouseState(float* x, float* y) { return SDL_GetRelativeMouseState(x, y); }

//! @copydoc SDL_WarpMouseInWindow()
inline void WarpMouseInWindow(SDL_Window* window, float x, float y) { SDL_WarpMouseInWindow(window, x, y); }

//! @copydoc SDL_WarpMouseGlobal()
inline void WarpMouseGlobal(float x, float y) { auto _ret = SDL_WarpMouseGlobal(x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetWindowRelativeMouseMode()
inline void SetWindowRelativeMouseMode(SDL_Window* window, bool enabled) { auto _ret = SDL_SetWindowRelativeMouseMode(window, enabled); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetWindowRelativeMouseMode()
inline bool GetWindowRelativeMouseMode(SDL_Window* window) { return SDL_GetWindowRelativeMouseMode(window); }

//! @copydoc SDL_CaptureMouse()
inline void CaptureMouse(bool enabled) { auto _ret = SDL_CaptureMouse(enabled); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateCursor()
inline SDL_Cursor* CreateCursor(const Uint8* data, const Uint8* mask, int w, int h, int hot_x, int hot_y) { auto _ret = SDL_CreateCursor(data, mask, w, h, hot_x, hot_y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateColorCursor()
inline SDL_Cursor* CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y) { auto _ret = SDL_CreateColorCursor(surface, hot_x, hot_y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateSystemCursor()
inline SDL_Cursor* CreateSystemCursor(SDL_SystemCursor id) { auto _ret = SDL_CreateSystemCursor(id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetCursor()
inline void SetCursor(SDL_Cursor* cursor) { auto _ret = SDL_SetCursor(cursor); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetCursor()
inline SDL_Cursor* GetCursor() { return SDL_GetCursor(); }

//! @copydoc SDL_GetDefaultCursor()
inline SDL_Cursor* GetDefaultCursor() { auto _ret = SDL_GetDefaultCursor(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroyCursor()
inline void DestroyCursor(SDL_Cursor* cursor) { SDL_DestroyCursor(cursor); }

//! @copydoc SDL_ShowCursor()
inline void ShowCursor() { auto _ret = SDL_ShowCursor(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HideCursor()
inline void HideCursor() { auto _ret = SDL_HideCursor(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CursorVisible()
inline bool CursorVisible() { return SDL_CursorVisible(); }

//! @copydoc SDL_GetTouchDevices()
inline SDL_TouchID* GetTouchDevices(int* count) { auto _ret = SDL_GetTouchDevices(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetTouchDeviceName()
inline const char* GetTouchDeviceName(SDL_TouchID touchID) { auto _ret = SDL_GetTouchDeviceName(touchID); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetTouchDeviceType()
inline SDL_TouchDeviceType GetTouchDeviceType(SDL_TouchID touchID) { return SDL_GetTouchDeviceType(touchID); }

//! @copydoc SDL_GetTouchFingers()
inline SDL_Finger** GetTouchFingers(SDL_TouchID touchID, int* count) { auto _ret = SDL_GetTouchFingers(touchID, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_PumpEvents()
inline void PumpEvents() { SDL_PumpEvents(); }

//! @copydoc SDL_PeepEvents()
inline int PeepEvents(SDL_Event* events, int numevents, SDL_EventAction action, Uint32 minType, Uint32 maxType) { auto _ret = SDL_PeepEvents(events, numevents, action, minType, maxType); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_HasEvent()
inline bool HasEvent(Uint32 type) { return SDL_HasEvent(type); }

//! @copydoc SDL_HasEvents()
inline bool HasEvents(Uint32 minType, Uint32 maxType) { return SDL_HasEvents(minType, maxType); }

//! @copydoc SDL_FlushEvent()
inline void FlushEvent(Uint32 type) { SDL_FlushEvent(type); }

//! @copydoc SDL_FlushEvents()
inline void FlushEvents(Uint32 minType, Uint32 maxType) { SDL_FlushEvents(minType, maxType); }

//! @copydoc SDL_PollEvent()
inline bool PollEvent(SDL_Event* event) { return SDL_PollEvent(event); }

//! @copydoc SDL_WaitEvent()
inline void WaitEvent(SDL_Event* event) { auto _ret = SDL_WaitEvent(event); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitEventTimeout()
inline bool WaitEventTimeout(SDL_Event* event, Sint32 timeoutMS) { return SDL_WaitEventTimeout(event, timeoutMS); }

//! @copydoc SDL_PushEvent()
inline void PushEvent(SDL_Event* event) { auto _ret = SDL_PushEvent(event); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetEventFilter()
inline void SetEventFilter(SDL_EventFilter filter, void* userdata) { SDL_SetEventFilter(filter, userdata); }

//! @copydoc SDL_GetEventFilter()
inline bool GetEventFilter(SDL_EventFilter* filter, void** userdata) { return SDL_GetEventFilter(filter, userdata); }

//! @copydoc SDL_AddEventWatch()
inline void AddEventWatch(SDL_EventFilter filter, void* userdata) { auto _ret = SDL_AddEventWatch(filter, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RemoveEventWatch()
inline void RemoveEventWatch(SDL_EventFilter filter, void* userdata) { SDL_RemoveEventWatch(filter, userdata); }

//! @copydoc SDL_FilterEvents()
inline void FilterEvents(SDL_EventFilter filter, void* userdata) { SDL_FilterEvents(filter, userdata); }

//! @copydoc SDL_SetEventEnabled()
inline void SetEventEnabled(Uint32 type, bool enabled) { SDL_SetEventEnabled(type, enabled); }

//! @copydoc SDL_EventEnabled()
inline bool EventEnabled(Uint32 type) { return SDL_EventEnabled(type); }

//! @copydoc SDL_RegisterEvents()
inline Uint32 RegisterEvents(int numevents) { return SDL_RegisterEvents(numevents); }

//! @copydoc SDL_GetWindowFromEvent()
inline SDL_Window* GetWindowFromEvent(const SDL_Event* event) { return SDL_GetWindowFromEvent(event); }

//! @copydoc SDL_GetBasePath()
inline const char* GetBasePath() { auto _ret = SDL_GetBasePath(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetPrefPath()
inline char* GetPrefPath(const char* org, const char* app) { return SDL_GetPrefPath(org, app); }

//! @copydoc SDL_GetUserFolder()
inline const char* GetUserFolder(SDL_Folder folder) { auto _ret = SDL_GetUserFolder(folder); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateDirectory()
inline void CreateDirectory(const char* path) { auto _ret = SDL_CreateDirectory(path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_EnumerateDirectory()
inline void EnumerateDirectory(const char* path, SDL_EnumerateDirectoryCallback callback, void* userdata) { auto _ret = SDL_EnumerateDirectory(path, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RemovePath()
inline void RemovePath(const char* path) { auto _ret = SDL_RemovePath(path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenamePath()
inline void RenamePath(const char* oldpath, const char* newpath) { auto _ret = SDL_RenamePath(oldpath, newpath); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CopyFile()
inline void CopyFile(const char* oldpath, const char* newpath) { auto _ret = SDL_CopyFile(oldpath, newpath); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetPathInfo()
inline void GetPathInfo(const char* path, SDL_PathInfo* info) { auto _ret = SDL_GetPathInfo(path, info); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GlobDirectory()
inline char** GlobDirectory(const char* path, const char* pattern, SDL::GlobFlags flags, int* count) { auto _ret = SDL_GlobDirectory(path, pattern, flags, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetCurrentDirectory()
inline char* GetCurrentDirectory() { return SDL_GetCurrentDirectory(); }

//! @copydoc SDL_GPUSupportsShaderFormats()
inline bool GPUSupportsShaderFormats(SDL_GPUShaderFormat format_flags, const char* name) { return SDL_GPUSupportsShaderFormats(format_flags, name); }

//! @copydoc SDL_GPUSupportsProperties()
inline bool GPUSupportsProperties(SDL_PropertiesID props) { return SDL_GPUSupportsProperties(props); }

//! @copydoc SDL_CreateGPUDevice()
inline SDL_GPUDevice* CreateGPUDevice(SDL_GPUShaderFormat format_flags, bool debug_mode, const char* name) { auto _ret = SDL_CreateGPUDevice(format_flags, debug_mode, name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUDeviceWithProperties()
inline SDL_GPUDevice* CreateGPUDeviceWithProperties(SDL_PropertiesID props) { auto _ret = SDL_CreateGPUDeviceWithProperties(props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_DestroyGPUDevice()
inline void DestroyGPUDevice(SDL_GPUDevice* device) { SDL_DestroyGPUDevice(device); }

//! @copydoc SDL_GetNumGPUDrivers()
inline int GetNumGPUDrivers() { return SDL_GetNumGPUDrivers(); }

//! @copydoc SDL_GetGPUDriver()
inline const char* GetGPUDriver(int index) { return SDL_GetGPUDriver(index); }

//! @copydoc SDL_GetGPUDeviceDriver()
inline const char* GetGPUDeviceDriver(SDL_GPUDevice* device) { return SDL_GetGPUDeviceDriver(device); }

//! @copydoc SDL_GetGPUShaderFormats()
inline SDL_GPUShaderFormat GetGPUShaderFormats(SDL_GPUDevice* device) { return SDL_GetGPUShaderFormats(device); }

//! @copydoc SDL_CreateGPUComputePipeline()
inline SDL_GPUComputePipeline* CreateGPUComputePipeline(SDL_GPUDevice* device, const SDL_GPUComputePipelineCreateInfo* createinfo) { auto _ret = SDL_CreateGPUComputePipeline(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUGraphicsPipeline()
inline SDL_GPUGraphicsPipeline* CreateGPUGraphicsPipeline(SDL_GPUDevice* device, const SDL_GPUGraphicsPipelineCreateInfo* createinfo) { auto _ret = SDL_CreateGPUGraphicsPipeline(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUSampler()
inline SDL_GPUSampler* CreateGPUSampler(SDL_GPUDevice* device, const SDL_GPUSamplerCreateInfo* createinfo) { auto _ret = SDL_CreateGPUSampler(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUShader()
inline SDL_GPUShader* CreateGPUShader(SDL_GPUDevice* device, const SDL_GPUShaderCreateInfo* createinfo) { auto _ret = SDL_CreateGPUShader(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUTexture()
inline SDL_GPUTexture* CreateGPUTexture(SDL_GPUDevice* device, const SDL_GPUTextureCreateInfo* createinfo) { auto _ret = SDL_CreateGPUTexture(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUBuffer()
inline SDL_GPUBuffer* CreateGPUBuffer(SDL_GPUDevice* device, const SDL_GPUBufferCreateInfo* createinfo) { auto _ret = SDL_CreateGPUBuffer(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateGPUTransferBuffer()
inline SDL_GPUTransferBuffer* CreateGPUTransferBuffer(SDL_GPUDevice* device, const SDL_GPUTransferBufferCreateInfo* createinfo) { auto _ret = SDL_CreateGPUTransferBuffer(device, createinfo); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetGPUBufferName()
inline void SetGPUBufferName(SDL_GPUDevice* device, SDL_GPUBuffer* buffer, const char* text) { SDL_SetGPUBufferName(device, buffer, text); }

//! @copydoc SDL_SetGPUTextureName()
inline void SetGPUTextureName(SDL_GPUDevice* device, SDL_GPUTexture* texture, const char* text) { SDL_SetGPUTextureName(device, texture, text); }

//! @copydoc SDL_InsertGPUDebugLabel()
inline void InsertGPUDebugLabel(SDL_GPUCommandBuffer* command_buffer, const char* text) { SDL_InsertGPUDebugLabel(command_buffer, text); }

//! @copydoc SDL_PushGPUDebugGroup()
inline void PushGPUDebugGroup(SDL_GPUCommandBuffer* command_buffer, const char* name) { SDL_PushGPUDebugGroup(command_buffer, name); }

//! @copydoc SDL_PopGPUDebugGroup()
inline void PopGPUDebugGroup(SDL_GPUCommandBuffer* command_buffer) { SDL_PopGPUDebugGroup(command_buffer); }

//! @copydoc SDL_ReleaseGPUTexture()
inline void ReleaseGPUTexture(SDL_GPUDevice* device, SDL_GPUTexture* texture) { SDL_ReleaseGPUTexture(device, texture); }

//! @copydoc SDL_ReleaseGPUSampler()
inline void ReleaseGPUSampler(SDL_GPUDevice* device, SDL_GPUSampler* sampler) { SDL_ReleaseGPUSampler(device, sampler); }

//! @copydoc SDL_ReleaseGPUBuffer()
inline void ReleaseGPUBuffer(SDL_GPUDevice* device, SDL_GPUBuffer* buffer) { SDL_ReleaseGPUBuffer(device, buffer); }

//! @copydoc SDL_ReleaseGPUTransferBuffer()
inline void ReleaseGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer) { SDL_ReleaseGPUTransferBuffer(device, transfer_buffer); }

//! @copydoc SDL_ReleaseGPUComputePipeline()
inline void ReleaseGPUComputePipeline(SDL_GPUDevice* device, SDL_GPUComputePipeline* compute_pipeline) { SDL_ReleaseGPUComputePipeline(device, compute_pipeline); }

//! @copydoc SDL_ReleaseGPUShader()
inline void ReleaseGPUShader(SDL_GPUDevice* device, SDL_GPUShader* shader) { SDL_ReleaseGPUShader(device, shader); }

//! @copydoc SDL_ReleaseGPUGraphicsPipeline()
inline void ReleaseGPUGraphicsPipeline(SDL_GPUDevice* device, SDL_GPUGraphicsPipeline* graphics_pipeline) { SDL_ReleaseGPUGraphicsPipeline(device, graphics_pipeline); }

//! @copydoc SDL_AcquireGPUCommandBuffer()
inline SDL_GPUCommandBuffer* AcquireGPUCommandBuffer(SDL_GPUDevice* device) { auto _ret = SDL_AcquireGPUCommandBuffer(device); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_PushGPUVertexUniformData()
inline void PushGPUVertexUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL_PushGPUVertexUniformData(command_buffer, slot_index, data, length); }

//! @copydoc SDL_PushGPUFragmentUniformData()
inline void PushGPUFragmentUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL_PushGPUFragmentUniformData(command_buffer, slot_index, data, length); }

//! @copydoc SDL_PushGPUComputeUniformData()
inline void PushGPUComputeUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL_PushGPUComputeUniformData(command_buffer, slot_index, data, length); }

//! @copydoc SDL_BeginGPURenderPass()
inline SDL_GPURenderPass* BeginGPURenderPass(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUColorTargetInfo* color_target_infos, Uint32 num_color_targets, const SDL_GPUDepthStencilTargetInfo* depth_stencil_target_info) { return SDL_BeginGPURenderPass(command_buffer, color_target_infos, num_color_targets, depth_stencil_target_info); }

//! @copydoc SDL_BindGPUGraphicsPipeline()
inline void BindGPUGraphicsPipeline(SDL_GPURenderPass* render_pass, SDL_GPUGraphicsPipeline* graphics_pipeline) { SDL_BindGPUGraphicsPipeline(render_pass, graphics_pipeline); }

//! @copydoc SDL_SetGPUViewport()
inline void SetGPUViewport(SDL_GPURenderPass* render_pass, const SDL_GPUViewport* viewport) { SDL_SetGPUViewport(render_pass, viewport); }

//! @copydoc SDL_SetGPUScissor()
inline void SetGPUScissor(SDL_GPURenderPass* render_pass, const SDL_Rect* scissor) { SDL_SetGPUScissor(render_pass, scissor); }

//! @copydoc SDL_SetGPUBlendConstants()
inline void SetGPUBlendConstants(SDL_GPURenderPass* render_pass, SDL_FColor blend_constants) { SDL_SetGPUBlendConstants(render_pass, blend_constants); }

//! @copydoc SDL_SetGPUStencilReference()
inline void SetGPUStencilReference(SDL_GPURenderPass* render_pass, Uint8 reference) { SDL_SetGPUStencilReference(render_pass, reference); }

//! @copydoc SDL_BindGPUVertexBuffers()
inline void BindGPUVertexBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUBufferBinding* bindings, Uint32 num_bindings) { SDL_BindGPUVertexBuffers(render_pass, first_slot, bindings, num_bindings); }

//! @copydoc SDL_BindGPUIndexBuffer()
inline void BindGPUIndexBuffer(SDL_GPURenderPass* render_pass, const SDL_GPUBufferBinding* binding, SDL_GPUIndexElementSize index_element_size) { SDL_BindGPUIndexBuffer(render_pass, binding, index_element_size); }

//! @copydoc SDL_BindGPUVertexSamplers()
inline void BindGPUVertexSamplers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL_BindGPUVertexSamplers(render_pass, first_slot, texture_sampler_bindings, num_bindings); }

//! @copydoc SDL_BindGPUVertexStorageTextures()
inline void BindGPUVertexStorageTextures(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL_BindGPUVertexStorageTextures(render_pass, first_slot, storage_textures, num_bindings); }

//! @copydoc SDL_BindGPUVertexStorageBuffers()
inline void BindGPUVertexStorageBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL_BindGPUVertexStorageBuffers(render_pass, first_slot, storage_buffers, num_bindings); }

//! @copydoc SDL_BindGPUFragmentSamplers()
inline void BindGPUFragmentSamplers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL_BindGPUFragmentSamplers(render_pass, first_slot, texture_sampler_bindings, num_bindings); }

//! @copydoc SDL_BindGPUFragmentStorageTextures()
inline void BindGPUFragmentStorageTextures(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL_BindGPUFragmentStorageTextures(render_pass, first_slot, storage_textures, num_bindings); }

//! @copydoc SDL_BindGPUFragmentStorageBuffers()
inline void BindGPUFragmentStorageBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL_BindGPUFragmentStorageBuffers(render_pass, first_slot, storage_buffers, num_bindings); }

//! @copydoc SDL_DrawGPUIndexedPrimitives()
inline void DrawGPUIndexedPrimitives(SDL_GPURenderPass* render_pass, Uint32 num_indices, Uint32 num_instances, Uint32 first_index, Sint32 vertex_offset, Uint32 first_instance) { SDL_DrawGPUIndexedPrimitives(render_pass, num_indices, num_instances, first_index, vertex_offset, first_instance); }

//! @copydoc SDL_DrawGPUPrimitives()
inline void DrawGPUPrimitives(SDL_GPURenderPass* render_pass, Uint32 num_vertices, Uint32 num_instances, Uint32 first_vertex, Uint32 first_instance) { SDL_DrawGPUPrimitives(render_pass, num_vertices, num_instances, first_vertex, first_instance); }

//! @copydoc SDL_DrawGPUPrimitivesIndirect()
inline void DrawGPUPrimitivesIndirect(SDL_GPURenderPass* render_pass, SDL_GPUBuffer* buffer, Uint32 offset, Uint32 draw_count) { SDL_DrawGPUPrimitivesIndirect(render_pass, buffer, offset, draw_count); }

//! @copydoc SDL_DrawGPUIndexedPrimitivesIndirect()
inline void DrawGPUIndexedPrimitivesIndirect(SDL_GPURenderPass* render_pass, SDL_GPUBuffer* buffer, Uint32 offset, Uint32 draw_count) { SDL_DrawGPUIndexedPrimitivesIndirect(render_pass, buffer, offset, draw_count); }

//! @copydoc SDL_EndGPURenderPass()
inline void EndGPURenderPass(SDL_GPURenderPass* render_pass) { SDL_EndGPURenderPass(render_pass); }

//! @copydoc SDL_BeginGPUComputePass()
inline SDL_GPUComputePass* BeginGPUComputePass(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUStorageTextureReadWriteBinding* storage_texture_bindings, Uint32 num_storage_texture_bindings, const SDL_GPUStorageBufferReadWriteBinding* storage_buffer_bindings, Uint32 num_storage_buffer_bindings) { return SDL_BeginGPUComputePass(command_buffer, storage_texture_bindings, num_storage_texture_bindings, storage_buffer_bindings, num_storage_buffer_bindings); }

//! @copydoc SDL_BindGPUComputePipeline()
inline void BindGPUComputePipeline(SDL_GPUComputePass* compute_pass, SDL_GPUComputePipeline* compute_pipeline) { SDL_BindGPUComputePipeline(compute_pass, compute_pipeline); }

//! @copydoc SDL_BindGPUComputeSamplers()
inline void BindGPUComputeSamplers(SDL_GPUComputePass* compute_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL_BindGPUComputeSamplers(compute_pass, first_slot, texture_sampler_bindings, num_bindings); }

//! @copydoc SDL_BindGPUComputeStorageTextures()
inline void BindGPUComputeStorageTextures(SDL_GPUComputePass* compute_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL_BindGPUComputeStorageTextures(compute_pass, first_slot, storage_textures, num_bindings); }

//! @copydoc SDL_BindGPUComputeStorageBuffers()
inline void BindGPUComputeStorageBuffers(SDL_GPUComputePass* compute_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL_BindGPUComputeStorageBuffers(compute_pass, first_slot, storage_buffers, num_bindings); }

//! @copydoc SDL_DispatchGPUCompute()
inline void DispatchGPUCompute(SDL_GPUComputePass* compute_pass, Uint32 groupcount_x, Uint32 groupcount_y, Uint32 groupcount_z) { SDL_DispatchGPUCompute(compute_pass, groupcount_x, groupcount_y, groupcount_z); }

//! @copydoc SDL_DispatchGPUComputeIndirect()
inline void DispatchGPUComputeIndirect(SDL_GPUComputePass* compute_pass, SDL_GPUBuffer* buffer, Uint32 offset) { SDL_DispatchGPUComputeIndirect(compute_pass, buffer, offset); }

//! @copydoc SDL_EndGPUComputePass()
inline void EndGPUComputePass(SDL_GPUComputePass* compute_pass) { SDL_EndGPUComputePass(compute_pass); }

//! @copydoc SDL_MapGPUTransferBuffer()
inline void* MapGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer, bool cycle) { auto _ret = SDL_MapGPUTransferBuffer(device, transfer_buffer, cycle); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_UnmapGPUTransferBuffer()
inline void UnmapGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer) { SDL_UnmapGPUTransferBuffer(device, transfer_buffer); }

//! @copydoc SDL_BeginGPUCopyPass()
inline SDL_GPUCopyPass* BeginGPUCopyPass(SDL_GPUCommandBuffer* command_buffer) { return SDL_BeginGPUCopyPass(command_buffer); }

//! @copydoc SDL_UploadToGPUTexture()
inline void UploadToGPUTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureTransferInfo* source, const SDL_GPUTextureRegion* destination, bool cycle) { SDL_UploadToGPUTexture(copy_pass, source, destination, cycle); }

//! @copydoc SDL_UploadToGPUBuffer()
inline void UploadToGPUBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUTransferBufferLocation* source, const SDL_GPUBufferRegion* destination, bool cycle) { SDL_UploadToGPUBuffer(copy_pass, source, destination, cycle); }

//! @copydoc SDL_CopyGPUTextureToTexture()
inline void CopyGPUTextureToTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureLocation* source, const SDL_GPUTextureLocation* destination, Uint32 w, Uint32 h, Uint32 d, bool cycle) { SDL_CopyGPUTextureToTexture(copy_pass, source, destination, w, h, d, cycle); }

//! @copydoc SDL_CopyGPUBufferToBuffer()
inline void CopyGPUBufferToBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUBufferLocation* source, const SDL_GPUBufferLocation* destination, Uint32 size, bool cycle) { SDL_CopyGPUBufferToBuffer(copy_pass, source, destination, size, cycle); }

//! @copydoc SDL_DownloadFromGPUTexture()
inline void DownloadFromGPUTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureRegion* source, const SDL_GPUTextureTransferInfo* destination) { SDL_DownloadFromGPUTexture(copy_pass, source, destination); }

//! @copydoc SDL_DownloadFromGPUBuffer()
inline void DownloadFromGPUBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUBufferRegion* source, const SDL_GPUTransferBufferLocation* destination) { SDL_DownloadFromGPUBuffer(copy_pass, source, destination); }

//! @copydoc SDL_EndGPUCopyPass()
inline void EndGPUCopyPass(SDL_GPUCopyPass* copy_pass) { SDL_EndGPUCopyPass(copy_pass); }

//! @copydoc SDL_GenerateMipmapsForGPUTexture()
inline void GenerateMipmapsForGPUTexture(SDL_GPUCommandBuffer* command_buffer, SDL_GPUTexture* texture) { SDL_GenerateMipmapsForGPUTexture(command_buffer, texture); }

//! @copydoc SDL_BlitGPUTexture()
inline void BlitGPUTexture(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUBlitInfo* info) { SDL_BlitGPUTexture(command_buffer, info); }

//! @copydoc SDL_WindowSupportsGPUSwapchainComposition()
inline bool WindowSupportsGPUSwapchainComposition(SDL_GPUDevice* device, SDL_Window* window, SDL_GPUSwapchainComposition swapchain_composition) { return SDL_WindowSupportsGPUSwapchainComposition(device, window, swapchain_composition); }

//! @copydoc SDL_WindowSupportsGPUPresentMode()
inline bool WindowSupportsGPUPresentMode(SDL_GPUDevice* device, SDL_Window* window, SDL_GPUPresentMode present_mode) { return SDL_WindowSupportsGPUPresentMode(device, window, present_mode); }

//! @copydoc SDL_ClaimWindowForGPUDevice()
inline void ClaimWindowForGPUDevice(SDL_GPUDevice* device, SDL_Window* window) { auto _ret = SDL_ClaimWindowForGPUDevice(device, window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReleaseWindowFromGPUDevice()
inline void ReleaseWindowFromGPUDevice(SDL_GPUDevice* device, SDL_Window* window) { SDL_ReleaseWindowFromGPUDevice(device, window); }

//! @copydoc SDL_SetGPUSwapchainParameters()
inline void SetGPUSwapchainParameters(SDL_GPUDevice* device, SDL_Window* window, SDL_GPUSwapchainComposition swapchain_composition, SDL_GPUPresentMode present_mode) { auto _ret = SDL_SetGPUSwapchainParameters(device, window, swapchain_composition, present_mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetGPUAllowedFramesInFlight()
inline void SetGPUAllowedFramesInFlight(SDL_GPUDevice* device, Uint32 allowed_frames_in_flight) { auto _ret = SDL_SetGPUAllowedFramesInFlight(device, allowed_frames_in_flight); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetGPUSwapchainTextureFormat()
inline SDL_GPUTextureFormat GetGPUSwapchainTextureFormat(SDL_GPUDevice* device, SDL_Window* window) { return SDL_GetGPUSwapchainTextureFormat(device, window); }

//! @copydoc SDL_AcquireGPUSwapchainTexture()
inline void AcquireGPUSwapchainTexture(SDL_GPUCommandBuffer* command_buffer, SDL_Window* window, SDL_GPUTexture** swapchain_texture, Uint32* swapchain_texture_width, Uint32* swapchain_texture_height) { auto _ret = SDL_AcquireGPUSwapchainTexture(command_buffer, window, swapchain_texture, swapchain_texture_width, swapchain_texture_height); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitForGPUSwapchain()
inline void WaitForGPUSwapchain(SDL_GPUDevice* device, SDL_Window* window) { auto _ret = SDL_WaitForGPUSwapchain(device, window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitAndAcquireGPUSwapchainTexture()
inline void WaitAndAcquireGPUSwapchainTexture(SDL_GPUCommandBuffer* command_buffer, SDL_Window* window, SDL_GPUTexture** swapchain_texture, Uint32* swapchain_texture_width, Uint32* swapchain_texture_height) { auto _ret = SDL_WaitAndAcquireGPUSwapchainTexture(command_buffer, window, swapchain_texture, swapchain_texture_width, swapchain_texture_height); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SubmitGPUCommandBuffer()
inline void SubmitGPUCommandBuffer(SDL_GPUCommandBuffer* command_buffer) { auto _ret = SDL_SubmitGPUCommandBuffer(command_buffer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SubmitGPUCommandBufferAndAcquireFence()
inline SDL_GPUFence* SubmitGPUCommandBufferAndAcquireFence(SDL_GPUCommandBuffer* command_buffer) { auto _ret = SDL_SubmitGPUCommandBufferAndAcquireFence(command_buffer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CancelGPUCommandBuffer()
inline void CancelGPUCommandBuffer(SDL_GPUCommandBuffer* command_buffer) { auto _ret = SDL_CancelGPUCommandBuffer(command_buffer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitForGPUIdle()
inline void WaitForGPUIdle(SDL_GPUDevice* device) { auto _ret = SDL_WaitForGPUIdle(device); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitForGPUFences()
inline void WaitForGPUFences(SDL_GPUDevice* device, bool wait_all, SDL_GPUFence** fences, Uint32 num_fences) { auto _ret = SDL_WaitForGPUFences(device, wait_all, fences, num_fences); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_QueryGPUFence()
inline bool QueryGPUFence(SDL_GPUDevice* device, SDL_GPUFence* fence) { return SDL_QueryGPUFence(device, fence); }

//! @copydoc SDL_ReleaseGPUFence()
inline void ReleaseGPUFence(SDL_GPUDevice* device, SDL_GPUFence* fence) { SDL_ReleaseGPUFence(device, fence); }

//! @copydoc SDL_GPUTextureFormatTexelBlockSize()
inline Uint32 GPUTextureFormatTexelBlockSize(SDL_GPUTextureFormat format) { return SDL_GPUTextureFormatTexelBlockSize(format); }

//! @copydoc SDL_GPUTextureSupportsFormat()
inline bool GPUTextureSupportsFormat(SDL_GPUDevice* device, SDL_GPUTextureFormat format, SDL_GPUTextureType type, SDL::GPUTextureUsageFlags usage) { return SDL_GPUTextureSupportsFormat(device, format, type, usage); }

//! @copydoc SDL_GPUTextureSupportsSampleCount()
inline bool GPUTextureSupportsSampleCount(SDL_GPUDevice* device, SDL_GPUTextureFormat format, SDL_GPUSampleCount sample_count) { return SDL_GPUTextureSupportsSampleCount(device, format, sample_count); }

//! @copydoc SDL_CalculateGPUTextureFormatSize()
inline Uint32 CalculateGPUTextureFormatSize(SDL_GPUTextureFormat format, Uint32 width, Uint32 height, Uint32 depth_or_layer_count) { return SDL_CalculateGPUTextureFormatSize(format, width, height, depth_or_layer_count); }

//! @copydoc SDL_GetHaptics()
inline SDL_HapticID* GetHaptics(int* count) { auto _ret = SDL_GetHaptics(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetHapticNameForID()
inline const char* GetHapticNameForID(SDL_HapticID instance_id) { auto _ret = SDL_GetHapticNameForID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_OpenHaptic()
inline SDL_Haptic* OpenHaptic(SDL_HapticID instance_id) { auto _ret = SDL_OpenHaptic(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetHapticFromID()
inline SDL_Haptic* GetHapticFromID(SDL_HapticID instance_id) { auto _ret = SDL_GetHapticFromID(instance_id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetHapticID()
inline SDL_HapticID GetHapticID(SDL_Haptic* haptic) { auto _ret = SDL_GetHapticID(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetHapticName()
inline const char* GetHapticName(SDL_Haptic* haptic) { auto _ret = SDL_GetHapticName(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IsMouseHaptic()
inline bool IsMouseHaptic() { return SDL_IsMouseHaptic(); }

//! @copydoc SDL_OpenHapticFromMouse()
inline SDL_Haptic* OpenHapticFromMouse() { auto _ret = SDL_OpenHapticFromMouse(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_IsJoystickHaptic()
inline bool IsJoystickHaptic(SDL_Joystick* joystick) { return SDL_IsJoystickHaptic(joystick); }

//! @copydoc SDL_OpenHapticFromJoystick()
inline SDL_Haptic* OpenHapticFromJoystick(SDL_Joystick* joystick) { auto _ret = SDL_OpenHapticFromJoystick(joystick); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CloseHaptic()
inline void CloseHaptic(SDL_Haptic* haptic) { SDL_CloseHaptic(haptic); }

//! @copydoc SDL_GetMaxHapticEffects()
inline int GetMaxHapticEffects(SDL_Haptic* haptic) { auto _ret = SDL_GetMaxHapticEffects(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetMaxHapticEffectsPlaying()
inline int GetMaxHapticEffectsPlaying(SDL_Haptic* haptic) { auto _ret = SDL_GetMaxHapticEffectsPlaying(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetHapticFeatures()
inline Uint32 GetHapticFeatures(SDL_Haptic* haptic) { auto _ret = SDL_GetHapticFeatures(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetNumHapticAxes()
inline int GetNumHapticAxes(SDL_Haptic* haptic) { auto _ret = SDL_GetNumHapticAxes(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_HapticEffectSupported()
inline bool HapticEffectSupported(SDL_Haptic* haptic, const SDL_HapticEffect* effect) { return SDL_HapticEffectSupported(haptic, effect); }

//! @copydoc SDL_CreateHapticEffect()
inline int CreateHapticEffect(SDL_Haptic* haptic, const SDL_HapticEffect* effect) { auto _ret = SDL_CreateHapticEffect(haptic, effect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_UpdateHapticEffect()
inline void UpdateHapticEffect(SDL_Haptic* haptic, int effect, const SDL_HapticEffect* data) { auto _ret = SDL_UpdateHapticEffect(haptic, effect, data); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RunHapticEffect()
inline void RunHapticEffect(SDL_Haptic* haptic, int effect, Uint32 iterations) { auto _ret = SDL_RunHapticEffect(haptic, effect, iterations); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_StopHapticEffect()
inline void StopHapticEffect(SDL_Haptic* haptic, int effect) { auto _ret = SDL_StopHapticEffect(haptic, effect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyHapticEffect()
inline void DestroyHapticEffect(SDL_Haptic* haptic, int effect) { SDL_DestroyHapticEffect(haptic, effect); }

//! @copydoc SDL_GetHapticEffectStatus()
inline bool GetHapticEffectStatus(SDL_Haptic* haptic, int effect) { return SDL_GetHapticEffectStatus(haptic, effect); }

//! @copydoc SDL_SetHapticGain()
inline void SetHapticGain(SDL_Haptic* haptic, int gain) { auto _ret = SDL_SetHapticGain(haptic, gain); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetHapticAutocenter()
inline void SetHapticAutocenter(SDL_Haptic* haptic, int autocenter) { auto _ret = SDL_SetHapticAutocenter(haptic, autocenter); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PauseHaptic()
inline void PauseHaptic(SDL_Haptic* haptic) { auto _ret = SDL_PauseHaptic(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ResumeHaptic()
inline void ResumeHaptic(SDL_Haptic* haptic) { auto _ret = SDL_ResumeHaptic(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_StopHapticEffects()
inline void StopHapticEffects(SDL_Haptic* haptic) { auto _ret = SDL_StopHapticEffects(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_HapticRumbleSupported()
inline bool HapticRumbleSupported(SDL_Haptic* haptic) { return SDL_HapticRumbleSupported(haptic); }

//! @copydoc SDL_InitHapticRumble()
inline void InitHapticRumble(SDL_Haptic* haptic) { auto _ret = SDL_InitHapticRumble(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_PlayHapticRumble()
inline void PlayHapticRumble(SDL_Haptic* haptic, float strength, Uint32 length) { auto _ret = SDL_PlayHapticRumble(haptic, strength, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_StopHapticRumble()
inline void StopHapticRumble(SDL_Haptic* haptic) { auto _ret = SDL_StopHapticRumble(haptic); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_hid_init()
inline int hid_init() { auto _ret = SDL_hid_init(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_exit()
inline int hid_exit() { auto _ret = SDL_hid_exit(); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_device_change_count()
inline Uint32 hid_device_change_count() { return SDL_hid_device_change_count(); }

//! @copydoc SDL_hid_enumerate()
inline SDL_hid_device_info* hid_enumerate(unsigned short vendor_id, unsigned short product_id) { return SDL_hid_enumerate(vendor_id, product_id); }

//! @copydoc SDL_hid_free_enumeration()
inline void hid_free_enumeration(SDL_hid_device_info* devs) { SDL_hid_free_enumeration(devs); }

//! @copydoc SDL_hid_open()
inline SDL_hid_device* hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t* serial_number) { auto _ret = SDL_hid_open(vendor_id, product_id, serial_number); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_open_path()
inline SDL_hid_device* hid_open_path(const char* path) { auto _ret = SDL_hid_open_path(path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_write()
inline int hid_write(SDL_hid_device* dev, const unsigned char* data, size_t length) { auto _ret = SDL_hid_write(dev, data, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_read_timeout()
inline int hid_read_timeout(SDL_hid_device* dev, unsigned char* data, size_t length, int milliseconds) { auto _ret = SDL_hid_read_timeout(dev, data, length, milliseconds); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_read()
inline int hid_read(SDL_hid_device* dev, unsigned char* data, size_t length) { auto _ret = SDL_hid_read(dev, data, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_set_nonblocking()
inline int hid_set_nonblocking(SDL_hid_device* dev, int nonblock) { auto _ret = SDL_hid_set_nonblocking(dev, nonblock); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_send_feature_report()
inline int hid_send_feature_report(SDL_hid_device* dev, const unsigned char* data, size_t length) { auto _ret = SDL_hid_send_feature_report(dev, data, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_feature_report()
inline int hid_get_feature_report(SDL_hid_device* dev, unsigned char* data, size_t length) { auto _ret = SDL_hid_get_feature_report(dev, data, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_input_report()
inline int hid_get_input_report(SDL_hid_device* dev, unsigned char* data, size_t length) { auto _ret = SDL_hid_get_input_report(dev, data, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_close()
inline int hid_close(SDL_hid_device* dev) { auto _ret = SDL_hid_close(dev); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_manufacturer_string()
inline int hid_get_manufacturer_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { auto _ret = SDL_hid_get_manufacturer_string(dev, string, maxlen); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_product_string()
inline int hid_get_product_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { auto _ret = SDL_hid_get_product_string(dev, string, maxlen); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_serial_number_string()
inline int hid_get_serial_number_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { auto _ret = SDL_hid_get_serial_number_string(dev, string, maxlen); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_indexed_string()
inline int hid_get_indexed_string(SDL_hid_device* dev, int string_index, wchar_t* string, size_t maxlen) { auto _ret = SDL_hid_get_indexed_string(dev, string_index, string, maxlen); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_device_info()
inline SDL_hid_device_info* hid_get_device_info(SDL_hid_device* dev) { auto _ret = SDL_hid_get_device_info(dev); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_get_report_descriptor()
inline int hid_get_report_descriptor(SDL_hid_device* dev, unsigned char* buf, size_t buf_size) { auto _ret = SDL_hid_get_report_descriptor(dev, buf, buf_size); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_hid_ble_scan()
inline void hid_ble_scan(bool active) { SDL_hid_ble_scan(active); }

//! @copydoc SDL_SetHintWithPriority()
inline void SetHintWithPriority(const char* name, const char* value, SDL_HintPriority priority) { auto _ret = SDL_SetHintWithPriority(name, value, priority); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetHint()
inline void SetHint(const char* name, const char* value) { auto _ret = SDL_SetHint(name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ResetHint()
inline void ResetHint(const char* name) { auto _ret = SDL_ResetHint(name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ResetHints()
inline void ResetHints() { SDL_ResetHints(); }

//! @copydoc SDL_GetHint()
inline const char* GetHint(const char* name) { return SDL_GetHint(name); }

//! @copydoc SDL_GetHintBoolean()
inline bool GetHintBoolean(const char* name, bool default_value) { return SDL_GetHintBoolean(name, default_value); }

//! @copydoc SDL_AddHintCallback()
inline void AddHintCallback(const char* name, SDL_HintCallback callback, void* userdata) { auto _ret = SDL_AddHintCallback(name, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RemoveHintCallback()
inline void RemoveHintCallback(const char* name, SDL_HintCallback callback, void* userdata) { SDL_RemoveHintCallback(name, callback, userdata); }

//! @copydoc SDL_Init()
inline void Init(SDL::InitFlags flags) { auto _ret = SDL_Init(flags); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_InitSubSystem()
inline void InitSubSystem(SDL::InitFlags flags) { auto _ret = SDL_InitSubSystem(flags); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_QuitSubSystem()
inline void QuitSubSystem(SDL::InitFlags flags) { SDL_QuitSubSystem(flags); }

//! @copydoc SDL_WasInit()
inline SDL::InitFlags WasInit(SDL::InitFlags flags) { return (SDL::InitFlags) SDL_WasInit(flags); }

//! @copydoc SDL_Quit()
inline void Quit() { SDL_Quit(); }

//! @copydoc SDL_IsMainThread()
inline bool IsMainThread() { return SDL_IsMainThread(); }

//! @copydoc SDL_RunOnMainThread()
inline void RunOnMainThread(SDL_MainThreadCallback callback, void* userdata, bool wait_complete) { auto _ret = SDL_RunOnMainThread(callback, userdata, wait_complete); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAppMetadata()
inline void SetAppMetadata(const char* appname, const char* appversion, const char* appidentifier) { auto _ret = SDL_SetAppMetadata(appname, appversion, appidentifier); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetAppMetadataProperty()
inline void SetAppMetadataProperty(const char* name, const char* value) { auto _ret = SDL_SetAppMetadataProperty(name, value); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetAppMetadataProperty()
inline const char* GetAppMetadataProperty(const char* name) { return SDL_GetAppMetadataProperty(name); }

//! @copydoc SDL_LoadObject()
inline SDL_SharedObject* LoadObject(const char* sofile) { auto _ret = SDL_LoadObject(sofile); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_LoadFunction()
inline SDL_FunctionPointer LoadFunction(SDL_SharedObject* handle, const char* name) { auto _ret = SDL_LoadFunction(handle, name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_UnloadObject()
inline void UnloadObject(SDL_SharedObject* handle) { SDL_UnloadObject(handle); }

//! @copydoc SDL_GetPreferredLocales()
inline SDL_Locale** GetPreferredLocales(int* count) { auto _ret = SDL_GetPreferredLocales(count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetLogPriorities()
inline void SetLogPriorities(SDL_LogPriority priority) { SDL_SetLogPriorities(priority); }

//! @copydoc SDL_SetLogPriority()
inline void SetLogPriority(int category, SDL_LogPriority priority) { SDL_SetLogPriority(category, priority); }

//! @copydoc SDL_GetLogPriority()
inline SDL_LogPriority GetLogPriority(int category) { return SDL_GetLogPriority(category); }

//! @copydoc SDL_ResetLogPriorities()
inline void ResetLogPriorities() { SDL_ResetLogPriorities(); }

//! @copydoc SDL_SetLogPriorityPrefix()
inline void SetLogPriorityPrefix(SDL_LogPriority priority, const char* prefix) { auto _ret = SDL_SetLogPriorityPrefix(priority, prefix); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LogMessageV()
inline void LogMessageV(int category, SDL_LogPriority priority, const char* fmt, va_list ap) { SDL_LogMessageV(category, priority, fmt, ap); }

//! @copydoc SDL_GetDefaultLogOutputFunction()
inline SDL_LogOutputFunction GetDefaultLogOutputFunction() { return SDL_GetDefaultLogOutputFunction(); }

//! @copydoc SDL_GetLogOutputFunction()
inline void GetLogOutputFunction(SDL_LogOutputFunction* callback, void** userdata) { SDL_GetLogOutputFunction(callback, userdata); }

//! @copydoc SDL_SetLogOutputFunction()
inline void SetLogOutputFunction(SDL_LogOutputFunction callback, void* userdata) { SDL_SetLogOutputFunction(callback, userdata); }

//! @copydoc SDL_ShowMessageBox()
inline void ShowMessageBox(const SDL_MessageBoxData* messageboxdata, int* buttonid) { auto _ret = SDL_ShowMessageBox(messageboxdata, buttonid); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ShowSimpleMessageBox()
inline void ShowSimpleMessageBox(SDL::MessageBoxFlags flags, const char* title, const char* message, SDL_Window* window) { auto _ret = SDL_ShowSimpleMessageBox(flags, title, message, window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_Metal_CreateView()
inline SDL_MetalView Metal_CreateView(SDL_Window* window) { return SDL_Metal_CreateView(window); }

//! @copydoc SDL_Metal_DestroyView()
inline void Metal_DestroyView(SDL_MetalView view) { SDL_Metal_DestroyView(view); }

//! @copydoc SDL_Metal_GetLayer()
inline void* Metal_GetLayer(SDL_MetalView view) { return SDL_Metal_GetLayer(view); }

//! @copydoc SDL_OpenURL()
inline void OpenURL(const char* url) { auto _ret = SDL_OpenURL(url); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetPlatform()
inline const char* GetPlatform() { return SDL_GetPlatform(); }

//! @copydoc SDL_CreateProcess()
inline SDL_Process* CreateProcess(const char** args, bool pipe_stdio) { return SDL_CreateProcess(args, pipe_stdio); }

//! @copydoc SDL_CreateProcessWithProperties()
inline SDL_Process* CreateProcessWithProperties(SDL_PropertiesID props) { return SDL_CreateProcessWithProperties(props); }

//! @copydoc SDL_GetProcessProperties()
inline SDL_PropertiesID GetProcessProperties(SDL_Process* process) { auto _ret = SDL_GetProcessProperties(process); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_ReadProcess()
inline void* ReadProcess(SDL_Process* process, size_t* datasize, int* exitcode) { auto _ret = SDL_ReadProcess(process, datasize, exitcode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetProcessInput()
inline SDL_IOStream* GetProcessInput(SDL_Process* process) { auto _ret = SDL_GetProcessInput(process); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetProcessOutput()
inline SDL_IOStream* GetProcessOutput(SDL_Process* process) { auto _ret = SDL_GetProcessOutput(process); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_KillProcess()
inline void KillProcess(SDL_Process* process, bool force) { auto _ret = SDL_KillProcess(process, force); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WaitProcess()
inline bool WaitProcess(SDL_Process* process, bool block, int* exitcode) { return SDL_WaitProcess(process, block, exitcode); }

//! @copydoc SDL_DestroyProcess()
inline void DestroyProcess(SDL_Process* process) { SDL_DestroyProcess(process); }

//! @copydoc SDL_GetNumRenderDrivers()
inline int GetNumRenderDrivers() { return SDL_GetNumRenderDrivers(); }

//! @copydoc SDL_GetRenderDriver()
inline const char* GetRenderDriver(int index) { return SDL_GetRenderDriver(index); }

//! @copydoc SDL_CreateWindowAndRenderer()
inline void CreateWindowAndRenderer(const char* title, int width, int height, SDL::WindowFlags window_flags, SDL_Window** window, SDL_Renderer** renderer) { auto _ret = SDL_CreateWindowAndRenderer(title, width, height, window_flags, window, renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateRenderer()
inline SDL_Renderer* CreateRenderer(SDL_Window* window, const char* name) { auto _ret = SDL_CreateRenderer(window, name); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateRendererWithProperties()
inline SDL_Renderer* CreateRendererWithProperties(SDL_PropertiesID props) { auto _ret = SDL_CreateRendererWithProperties(props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateSoftwareRenderer()
inline SDL_Renderer* CreateSoftwareRenderer(SDL_Surface* surface) { auto _ret = SDL_CreateSoftwareRenderer(surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRenderer()
inline SDL_Renderer* GetRenderer(SDL_Window* window) { auto _ret = SDL_GetRenderer(window); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRenderWindow()
inline SDL_Window* GetRenderWindow(SDL_Renderer* renderer) { auto _ret = SDL_GetRenderWindow(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRendererName()
inline const char* GetRendererName(SDL_Renderer* renderer) { auto _ret = SDL_GetRendererName(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRendererProperties()
inline SDL_PropertiesID GetRendererProperties(SDL_Renderer* renderer) { auto _ret = SDL_GetRendererProperties(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRenderOutputSize()
inline void GetRenderOutputSize(SDL_Renderer* renderer, int* w, int* h) { auto _ret = SDL_GetRenderOutputSize(renderer, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetCurrentRenderOutputSize()
inline void GetCurrentRenderOutputSize(SDL_Renderer* renderer, int* w, int* h) { auto _ret = SDL_GetCurrentRenderOutputSize(renderer, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateTexture()
inline SDL_Texture* CreateTexture(SDL_Renderer* renderer, SDL_PixelFormat format, SDL_TextureAccess access, int w, int h) { auto _ret = SDL_CreateTexture(renderer, format, access, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateTextureFromSurface()
inline SDL_Texture* CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface) { auto _ret = SDL_CreateTextureFromSurface(renderer, surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CreateTextureWithProperties()
inline SDL_Texture* CreateTextureWithProperties(SDL_Renderer* renderer, SDL_PropertiesID props) { auto _ret = SDL_CreateTextureWithProperties(renderer, props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetTextureProperties()
inline SDL_PropertiesID GetTextureProperties(SDL_Texture* texture) { auto _ret = SDL_GetTextureProperties(texture); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetRendererFromTexture()
inline SDL_Renderer* GetRendererFromTexture(SDL_Texture* texture) { auto _ret = SDL_GetRendererFromTexture(texture); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetTextureSize()
inline void GetTextureSize(SDL_Texture* texture, float* w, float* h) { auto _ret = SDL_GetTextureSize(texture, w, h); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureColorMod()
inline void SetTextureColorMod(SDL_Texture* texture, Uint8 r, Uint8 g, Uint8 b) { auto _ret = SDL_SetTextureColorMod(texture, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureColorModFloat()
inline void SetTextureColorModFloat(SDL_Texture* texture, float r, float g, float b) { auto _ret = SDL_SetTextureColorModFloat(texture, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureColorMod()
inline void GetTextureColorMod(SDL_Texture* texture, Uint8* r, Uint8* g, Uint8* b) { auto _ret = SDL_GetTextureColorMod(texture, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureColorModFloat()
inline void GetTextureColorModFloat(SDL_Texture* texture, float* r, float* g, float* b) { auto _ret = SDL_GetTextureColorModFloat(texture, r, g, b); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureAlphaMod()
inline void SetTextureAlphaMod(SDL_Texture* texture, Uint8 alpha) { auto _ret = SDL_SetTextureAlphaMod(texture, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureAlphaModFloat()
inline void SetTextureAlphaModFloat(SDL_Texture* texture, float alpha) { auto _ret = SDL_SetTextureAlphaModFloat(texture, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureAlphaMod()
inline void GetTextureAlphaMod(SDL_Texture* texture, Uint8* alpha) { auto _ret = SDL_GetTextureAlphaMod(texture, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureAlphaModFloat()
inline void GetTextureAlphaModFloat(SDL_Texture* texture, float* alpha) { auto _ret = SDL_GetTextureAlphaModFloat(texture, alpha); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureBlendMode()
inline void SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode) { auto _ret = SDL_SetTextureBlendMode(texture, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureBlendMode()
inline void GetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode* blendMode) { auto _ret = SDL_GetTextureBlendMode(texture, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetTextureScaleMode()
inline void SetTextureScaleMode(SDL_Texture* texture, SDL_ScaleMode scaleMode) { auto _ret = SDL_SetTextureScaleMode(texture, scaleMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetTextureScaleMode()
inline void GetTextureScaleMode(SDL_Texture* texture, SDL_ScaleMode* scaleMode) { auto _ret = SDL_GetTextureScaleMode(texture, scaleMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UpdateTexture()
inline void UpdateTexture(SDL_Texture* texture, const SDL_Rect* rect, const void* pixels, int pitch) { auto _ret = SDL_UpdateTexture(texture, rect, pixels, pitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UpdateYUVTexture()
inline void UpdateYUVTexture(SDL_Texture* texture, const SDL_Rect* rect, const Uint8* Yplane, int Ypitch, const Uint8* Uplane, int Upitch, const Uint8* Vplane, int Vpitch) { auto _ret = SDL_UpdateYUVTexture(texture, rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UpdateNVTexture()
inline void UpdateNVTexture(SDL_Texture* texture, const SDL_Rect* rect, const Uint8* Yplane, int Ypitch, const Uint8* UVplane, int UVpitch) { auto _ret = SDL_UpdateNVTexture(texture, rect, Yplane, Ypitch, UVplane, UVpitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LockTexture()
inline void LockTexture(SDL_Texture* texture, const SDL_Rect* rect, void** pixels, int* pitch) { auto _ret = SDL_LockTexture(texture, rect, pixels, pitch); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_LockTextureToSurface()
inline void LockTextureToSurface(SDL_Texture* texture, const SDL_Rect* rect, SDL_Surface** surface) { auto _ret = SDL_LockTextureToSurface(texture, rect, surface); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_UnlockTexture()
inline void UnlockTexture(SDL_Texture* texture) { SDL_UnlockTexture(texture); }

//! @copydoc SDL_SetRenderTarget()
inline void SetRenderTarget(SDL_Renderer* renderer, SDL_Texture* texture) { auto _ret = SDL_SetRenderTarget(renderer, texture); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderTarget()
inline SDL_Texture* GetRenderTarget(SDL_Renderer* renderer) { return SDL_GetRenderTarget(renderer); }

//! @copydoc SDL_SetRenderLogicalPresentation()
inline void SetRenderLogicalPresentation(SDL_Renderer* renderer, int w, int h, SDL_RendererLogicalPresentation mode) { auto _ret = SDL_SetRenderLogicalPresentation(renderer, w, h, mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderLogicalPresentation()
inline void GetRenderLogicalPresentation(SDL_Renderer* renderer, int* w, int* h, SDL_RendererLogicalPresentation* mode) { auto _ret = SDL_GetRenderLogicalPresentation(renderer, w, h, mode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderLogicalPresentationRect()
inline void GetRenderLogicalPresentationRect(SDL_Renderer* renderer, SDL_FRect* rect) { auto _ret = SDL_GetRenderLogicalPresentationRect(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderCoordinatesFromWindow()
inline void RenderCoordinatesFromWindow(SDL_Renderer* renderer, float window_x, float window_y, float* x, float* y) { auto _ret = SDL_RenderCoordinatesFromWindow(renderer, window_x, window_y, x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderCoordinatesToWindow()
inline void RenderCoordinatesToWindow(SDL_Renderer* renderer, float x, float y, float* window_x, float* window_y) { auto _ret = SDL_RenderCoordinatesToWindow(renderer, x, y, window_x, window_y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ConvertEventToRenderCoordinates()
inline void ConvertEventToRenderCoordinates(SDL_Renderer* renderer, SDL_Event* event) { auto _ret = SDL_ConvertEventToRenderCoordinates(renderer, event); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderViewport()
inline void SetRenderViewport(SDL_Renderer* renderer, const SDL_Rect* rect) { auto _ret = SDL_SetRenderViewport(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderViewport()
inline void GetRenderViewport(SDL_Renderer* renderer, SDL_Rect* rect) { auto _ret = SDL_GetRenderViewport(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderViewportSet()
inline bool RenderViewportSet(SDL_Renderer* renderer) { return SDL_RenderViewportSet(renderer); }

//! @copydoc SDL_GetRenderSafeArea()
inline void GetRenderSafeArea(SDL_Renderer* renderer, SDL_Rect* rect) { auto _ret = SDL_GetRenderSafeArea(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderClipRect()
inline void SetRenderClipRect(SDL_Renderer* renderer, const SDL_Rect* rect) { auto _ret = SDL_SetRenderClipRect(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderClipRect()
inline void GetRenderClipRect(SDL_Renderer* renderer, SDL_Rect* rect) { auto _ret = SDL_GetRenderClipRect(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderClipEnabled()
inline void RenderClipEnabled(SDL_Renderer* renderer) { auto _ret = SDL_RenderClipEnabled(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderScale()
inline void SetRenderScale(SDL_Renderer* renderer, float scaleX, float scaleY) { auto _ret = SDL_SetRenderScale(renderer, scaleX, scaleY); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderScale()
inline void GetRenderScale(SDL_Renderer* renderer, float* scaleX, float* scaleY) { auto _ret = SDL_GetRenderScale(renderer, scaleX, scaleY); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderDrawColor()
inline void SetRenderDrawColor(SDL_Renderer* renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a) { auto _ret = SDL_SetRenderDrawColor(renderer, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderDrawColorFloat()
inline void SetRenderDrawColorFloat(SDL_Renderer* renderer, float r, float g, float b, float a) { auto _ret = SDL_SetRenderDrawColorFloat(renderer, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderDrawColor()
inline void GetRenderDrawColor(SDL_Renderer* renderer, Uint8* r, Uint8* g, Uint8* b, Uint8* a) { auto _ret = SDL_GetRenderDrawColor(renderer, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderDrawColorFloat()
inline void GetRenderDrawColorFloat(SDL_Renderer* renderer, float* r, float* g, float* b, float* a) { auto _ret = SDL_GetRenderDrawColorFloat(renderer, r, g, b, a); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderColorScale()
inline void SetRenderColorScale(SDL_Renderer* renderer, float scale) { auto _ret = SDL_SetRenderColorScale(renderer, scale); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderColorScale()
inline void GetRenderColorScale(SDL_Renderer* renderer, float* scale) { auto _ret = SDL_GetRenderColorScale(renderer, scale); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderDrawBlendMode()
inline void SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode) { auto _ret = SDL_SetRenderDrawBlendMode(renderer, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderDrawBlendMode()
inline void GetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode* blendMode) { auto _ret = SDL_GetRenderDrawBlendMode(renderer, blendMode); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderClear()
inline void RenderClear(SDL_Renderer* renderer) { auto _ret = SDL_RenderClear(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderPoint()
inline void RenderPoint(SDL_Renderer* renderer, float x, float y) { auto _ret = SDL_RenderPoint(renderer, x, y); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderPoints()
inline void RenderPoints(SDL_Renderer* renderer, const SDL_FPoint* points, int count) { auto _ret = SDL_RenderPoints(renderer, points, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderLine()
inline void RenderLine(SDL_Renderer* renderer, float x1, float y1, float x2, float y2) { auto _ret = SDL_RenderLine(renderer, x1, y1, x2, y2); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderLines()
inline void RenderLines(SDL_Renderer* renderer, const SDL_FPoint* points, int count) { auto _ret = SDL_RenderLines(renderer, points, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderRect()
inline void RenderRect(SDL_Renderer* renderer, const SDL_FRect* rect) { auto _ret = SDL_RenderRect(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderRects()
inline void RenderRects(SDL_Renderer* renderer, const SDL_FRect* rects, int count) { auto _ret = SDL_RenderRects(renderer, rects, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderFillRect()
inline void RenderFillRect(SDL_Renderer* renderer, const SDL_FRect* rect) { auto _ret = SDL_RenderFillRect(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderFillRects()
inline void RenderFillRects(SDL_Renderer* renderer, const SDL_FRect* rects, int count) { auto _ret = SDL_RenderFillRects(renderer, rects, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderTexture()
inline void RenderTexture(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_FRect* srcrect, const SDL_FRect* dstrect) { auto _ret = SDL_RenderTexture(renderer, texture, srcrect, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderTextureRotated()
inline void RenderTextureRotated(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_FRect* srcrect, const SDL_FRect* dstrect, double angle, const SDL_FPoint* center, SDL_FlipMode flip) { auto _ret = SDL_RenderTextureRotated(renderer, texture, srcrect, dstrect, angle, center, flip); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderTextureAffine()
inline void RenderTextureAffine(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_FRect* srcrect, const SDL_FPoint* origin, const SDL_FPoint* right, const SDL_FPoint* down) { auto _ret = SDL_RenderTextureAffine(renderer, texture, srcrect, origin, right, down); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderTextureTiled()
inline void RenderTextureTiled(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_FRect* srcrect, float scale, const SDL_FRect* dstrect) { auto _ret = SDL_RenderTextureTiled(renderer, texture, srcrect, scale, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderTexture9Grid()
inline void RenderTexture9Grid(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_FRect* srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, const SDL_FRect* dstrect) { auto _ret = SDL_RenderTexture9Grid(renderer, texture, srcrect, left_width, right_width, top_height, bottom_height, scale, dstrect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderGeometry()
inline void RenderGeometry(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Vertex* vertices, int num_vertices, const int* indices, int num_indices) { auto _ret = SDL_RenderGeometry(renderer, texture, vertices, num_vertices, indices, num_indices); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderGeometryRaw()
inline void RenderGeometryRaw(SDL_Renderer* renderer, SDL_Texture* texture, const float* xy, int xy_stride, const SDL_FColor* color, int color_stride, const float* uv, int uv_stride, int num_vertices, const void* indices, int num_indices, int size_indices) { auto _ret = SDL_RenderGeometryRaw(renderer, texture, xy, xy_stride, color, color_stride, uv, uv_stride, num_vertices, indices, num_indices, size_indices); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderReadPixels()
inline SDL_Surface* RenderReadPixels(SDL_Renderer* renderer, const SDL_Rect* rect) { auto _ret = SDL_RenderReadPixels(renderer, rect); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_RenderPresent()
inline void RenderPresent(SDL_Renderer* renderer) { auto _ret = SDL_RenderPresent(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DestroyTexture()
inline void DestroyTexture(SDL_Texture* texture) { SDL_DestroyTexture(texture); }

//! @copydoc SDL_DestroyRenderer()
inline void DestroyRenderer(SDL_Renderer* renderer) { SDL_DestroyRenderer(renderer); }

//! @copydoc SDL_FlushRenderer()
inline void FlushRenderer(SDL_Renderer* renderer) { auto _ret = SDL_FlushRenderer(renderer); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderMetalLayer()
inline void* GetRenderMetalLayer(SDL_Renderer* renderer) { return SDL_GetRenderMetalLayer(renderer); }

//! @copydoc SDL_GetRenderMetalCommandEncoder()
inline void* GetRenderMetalCommandEncoder(SDL_Renderer* renderer) { return SDL_GetRenderMetalCommandEncoder(renderer); }

//! @copydoc SDL_AddVulkanRenderSemaphores()
inline void AddVulkanRenderSemaphores(SDL_Renderer* renderer, Uint32 wait_stage_mask, Sint64 wait_semaphore, Sint64 signal_semaphore) { auto _ret = SDL_AddVulkanRenderSemaphores(renderer, wait_stage_mask, wait_semaphore, signal_semaphore); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_SetRenderVSync()
inline void SetRenderVSync(SDL_Renderer* renderer, int vsync) { auto _ret = SDL_SetRenderVSync(renderer, vsync); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetRenderVSync()
inline void GetRenderVSync(SDL_Renderer* renderer, int* vsync) { auto _ret = SDL_GetRenderVSync(renderer, vsync); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenderDebugText()
inline void RenderDebugText(SDL_Renderer* renderer, float x, float y, const char* str) { auto _ret = SDL_RenderDebugText(renderer, x, y, str); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_OpenTitleStorage()
inline SDL_Storage* OpenTitleStorage(const char* override, SDL_PropertiesID props) { auto _ret = SDL_OpenTitleStorage(override, props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_OpenUserStorage()
inline SDL_Storage* OpenUserStorage(const char* org, const char* app, SDL_PropertiesID props) { auto _ret = SDL_OpenUserStorage(org, app, props); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_OpenFileStorage()
inline SDL_Storage* OpenFileStorage(const char* path) { auto _ret = SDL_OpenFileStorage(path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_OpenStorage()
inline SDL_Storage* OpenStorage(const SDL_StorageInterface* iface, void* userdata) { auto _ret = SDL_OpenStorage(iface, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_CloseStorage()
inline void CloseStorage(SDL_Storage* storage) { auto _ret = SDL_CloseStorage(storage); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_StorageReady()
inline bool StorageReady(SDL_Storage* storage) { return SDL_StorageReady(storage); }

//! @copydoc SDL_GetStorageFileSize()
inline void GetStorageFileSize(SDL_Storage* storage, const char* path, Uint64* length) { auto _ret = SDL_GetStorageFileSize(storage, path, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_ReadStorageFile()
inline void ReadStorageFile(SDL_Storage* storage, const char* path, void* destination, Uint64 length) { auto _ret = SDL_ReadStorageFile(storage, path, destination, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_WriteStorageFile()
inline void WriteStorageFile(SDL_Storage* storage, const char* path, const void* source, Uint64 length) { auto _ret = SDL_WriteStorageFile(storage, path, source, length); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateStorageDirectory()
inline void CreateStorageDirectory(SDL_Storage* storage, const char* path) { auto _ret = SDL_CreateStorageDirectory(storage, path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_EnumerateStorageDirectory()
inline void EnumerateStorageDirectory(SDL_Storage* storage, const char* path, SDL_EnumerateDirectoryCallback callback, void* userdata) { auto _ret = SDL_EnumerateStorageDirectory(storage, path, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RemoveStoragePath()
inline void RemoveStoragePath(SDL_Storage* storage, const char* path) { auto _ret = SDL_RemoveStoragePath(storage, path); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_RenameStoragePath()
inline void RenameStoragePath(SDL_Storage* storage, const char* oldpath, const char* newpath) { auto _ret = SDL_RenameStoragePath(storage, oldpath, newpath); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CopyStorageFile()
inline void CopyStorageFile(SDL_Storage* storage, const char* oldpath, const char* newpath) { auto _ret = SDL_CopyStorageFile(storage, oldpath, newpath); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetStoragePathInfo()
inline void GetStoragePathInfo(SDL_Storage* storage, const char* path, SDL_PathInfo* info) { auto _ret = SDL_GetStoragePathInfo(storage, path, info); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetStorageSpaceRemaining()
inline Uint64 GetStorageSpaceRemaining(SDL_Storage* storage) { return SDL_GetStorageSpaceRemaining(storage); }

//! @copydoc SDL_GlobStorageDirectory()
inline char** GlobStorageDirectory(SDL_Storage* storage, const char* path, const char* pattern, SDL::GlobFlags flags, int* count) { auto _ret = SDL_GlobStorageDirectory(storage, path, pattern, flags, count); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_SetX11EventHook()
inline void SetX11EventHook(SDL_X11EventHook callback, void* userdata) { SDL_SetX11EventHook(callback, userdata); }

//! @copydoc SDL_IsTablet()
inline bool IsTablet() { return SDL_IsTablet(); }

//! @copydoc SDL_IsTV()
inline bool IsTV() { return SDL_IsTV(); }

//! @copydoc SDL_GetSandbox()
inline SDL_Sandbox GetSandbox() { return SDL_GetSandbox(); }

//! @copydoc SDL_OnApplicationWillTerminate()
inline void OnApplicationWillTerminate() { SDL_OnApplicationWillTerminate(); }

//! @copydoc SDL_OnApplicationDidReceiveMemoryWarning()
inline void OnApplicationDidReceiveMemoryWarning() { SDL_OnApplicationDidReceiveMemoryWarning(); }

//! @copydoc SDL_OnApplicationWillEnterBackground()
inline void OnApplicationWillEnterBackground() { SDL_OnApplicationWillEnterBackground(); }

//! @copydoc SDL_OnApplicationDidEnterBackground()
inline void OnApplicationDidEnterBackground() { SDL_OnApplicationDidEnterBackground(); }

//! @copydoc SDL_OnApplicationWillEnterForeground()
inline void OnApplicationWillEnterForeground() { SDL_OnApplicationWillEnterForeground(); }

//! @copydoc SDL_OnApplicationDidEnterForeground()
inline void OnApplicationDidEnterForeground() { SDL_OnApplicationDidEnterForeground(); }

//! @copydoc SDL_GetDateTimeLocalePreferences()
inline void GetDateTimeLocalePreferences(SDL_DateFormat* dateFormat, SDL_TimeFormat* timeFormat) { auto _ret = SDL_GetDateTimeLocalePreferences(dateFormat, timeFormat); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_GetCurrentTime()
inline void GetCurrentTime(SDL_Time* ticks) { auto _ret = SDL_GetCurrentTime(ticks); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_TimeToDateTime()
inline void TimeToDateTime(SDL_Time ticks, SDL_DateTime* dt, bool localTime) { auto _ret = SDL_TimeToDateTime(ticks, dt, localTime); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_DateTimeToTime()
inline void DateTimeToTime(const SDL_DateTime* dt, SDL_Time* ticks) { auto _ret = SDL_DateTimeToTime(dt, ticks); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_TimeToWindows()
inline void TimeToWindows(SDL_Time ticks, Uint32* dwLowDateTime, Uint32* dwHighDateTime) { SDL_TimeToWindows(ticks, dwLowDateTime, dwHighDateTime); }

//! @copydoc SDL_TimeFromWindows()
inline SDL_Time TimeFromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime) { return SDL_TimeFromWindows(dwLowDateTime, dwHighDateTime); }

//! @copydoc SDL_GetDaysInMonth()
inline int GetDaysInMonth(int year, int month) { auto _ret = SDL_GetDaysInMonth(year, month); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDayOfYear()
inline int GetDayOfYear(int year, int month, int day) { auto _ret = SDL_GetDayOfYear(year, month, day); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetDayOfWeek()
inline int GetDayOfWeek(int year, int month, int day) { auto _ret = SDL_GetDayOfWeek(year, month, day); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_GetTicks()
inline Uint64 GetTicks() { return SDL_GetTicks(); }

//! @copydoc SDL_GetTicksNS()
inline Uint64 GetTicksNS() { return SDL_GetTicksNS(); }

//! @copydoc SDL_GetPerformanceCounter()
inline Uint64 GetPerformanceCounter() { return SDL_GetPerformanceCounter(); }

//! @copydoc SDL_GetPerformanceFrequency()
inline Uint64 GetPerformanceFrequency() { return SDL_GetPerformanceFrequency(); }

//! @copydoc SDL_Delay()
inline void Delay(Uint32 ms) { SDL_Delay(ms); }

//! @copydoc SDL_DelayNS()
inline void DelayNS(Uint64 ns) { SDL_DelayNS(ns); }

//! @copydoc SDL_DelayPrecise()
inline void DelayPrecise(Uint64 ns) { SDL_DelayPrecise(ns); }

//! @copydoc SDL_AddTimer()
inline SDL_TimerID AddTimer(Uint32 interval, SDL_TimerCallback callback, void* userdata) { auto _ret = SDL_AddTimer(interval, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_AddTimerNS()
inline SDL_TimerID AddTimerNS(Uint64 interval, SDL_NSTimerCallback callback, void* userdata) { auto _ret = SDL_AddTimerNS(interval, callback, userdata); if (!_ret) throw SDL::Error(SDL::raw::GetError()); return _ret; }

//! @copydoc SDL_RemoveTimer()
inline void RemoveTimer(SDL_TimerID id) { auto _ret = SDL_RemoveTimer(id); if (!_ret) throw SDL::Error(SDL::raw::GetError()); }

//! @copydoc SDL_CreateTray()
inline SDL_Tray* CreateTray(SDL_Surface* icon, const char* tooltip) { return SDL_CreateTray(icon, tooltip); }

//! @copydoc SDL_SetTrayIcon()
inline void SetTrayIcon(SDL_Tray* tray, SDL_Surface* icon) { SDL_SetTrayIcon(tray, icon); }

//! @copydoc SDL_SetTrayTooltip()
inline void SetTrayTooltip(SDL_Tray* tray, const char* tooltip) { SDL_SetTrayTooltip(tray, tooltip); }

//! @copydoc SDL_CreateTrayMenu()
inline SDL_TrayMenu* CreateTrayMenu(SDL_Tray* tray) { return SDL_CreateTrayMenu(tray); }

//! @copydoc SDL_CreateTraySubmenu()
inline SDL_TrayMenu* CreateTraySubmenu(SDL_TrayEntry* entry) { return SDL_CreateTraySubmenu(entry); }

//! @copydoc SDL_GetTrayMenu()
inline SDL_TrayMenu* GetTrayMenu(SDL_Tray* tray) { return SDL_GetTrayMenu(tray); }

//! @copydoc SDL_GetTraySubmenu()
inline SDL_TrayMenu* GetTraySubmenu(SDL_TrayEntry* entry) { return SDL_GetTraySubmenu(entry); }

//! @copydoc SDL_GetTrayEntries()
inline const SDL_TrayEntry** GetTrayEntries(SDL_TrayMenu* menu, int* size) { return SDL_GetTrayEntries(menu, size); }

//! @copydoc SDL_RemoveTrayEntry()
inline void RemoveTrayEntry(SDL_TrayEntry* entry) { SDL_RemoveTrayEntry(entry); }

//! @copydoc SDL_InsertTrayEntryAt()
inline SDL_TrayEntry* InsertTrayEntryAt(SDL_TrayMenu* menu, int pos, const char* label, SDL::TrayEntryFlags flags) { return SDL_InsertTrayEntryAt(menu, pos, label, flags); }

//! @copydoc SDL_SetTrayEntryLabel()
inline void SetTrayEntryLabel(SDL_TrayEntry* entry, const char* label) { SDL_SetTrayEntryLabel(entry, label); }

//! @copydoc SDL_GetTrayEntryLabel()
inline const char* GetTrayEntryLabel(SDL_TrayEntry* entry) { return SDL_GetTrayEntryLabel(entry); }

//! @copydoc SDL_SetTrayEntryChecked()
inline void SetTrayEntryChecked(SDL_TrayEntry* entry, bool checked) { SDL_SetTrayEntryChecked(entry, checked); }

//! @copydoc SDL_GetTrayEntryChecked()
inline bool GetTrayEntryChecked(SDL_TrayEntry* entry) { return SDL_GetTrayEntryChecked(entry); }

//! @copydoc SDL_SetTrayEntryEnabled()
inline void SetTrayEntryEnabled(SDL_TrayEntry* entry, bool enabled) { SDL_SetTrayEntryEnabled(entry, enabled); }

//! @copydoc SDL_GetTrayEntryEnabled()
inline bool GetTrayEntryEnabled(SDL_TrayEntry* entry) { return SDL_GetTrayEntryEnabled(entry); }

//! @copydoc SDL_SetTrayEntryCallback()
inline void SetTrayEntryCallback(SDL_TrayEntry* entry, SDL_TrayCallback callback, void* userdata) { SDL_SetTrayEntryCallback(entry, callback, userdata); }

//! @copydoc SDL_ClickTrayEntry()
inline void ClickTrayEntry(SDL_TrayEntry* entry) { SDL_ClickTrayEntry(entry); }

//! @copydoc SDL_DestroyTray()
inline void DestroyTray(SDL_Tray* tray) { SDL_DestroyTray(tray); }

//! @copydoc SDL_GetTrayEntryParent()
inline SDL_TrayMenu* GetTrayEntryParent(SDL_TrayEntry* entry) { return SDL_GetTrayEntryParent(entry); }

//! @copydoc SDL_GetTrayMenuParentEntry()
inline SDL_TrayEntry* GetTrayMenuParentEntry(SDL_TrayMenu* menu) { return SDL_GetTrayMenuParentEntry(menu); }

//! @copydoc SDL_GetTrayMenuParentTray()
inline SDL_Tray* GetTrayMenuParentTray(SDL_TrayMenu* menu) { return SDL_GetTrayMenuParentTray(menu); }

//! @copydoc SDL_UpdateTrays()
inline void UpdateTrays() { SDL_UpdateTrays(); }

//! @copydoc SDL_GetVersion()
inline int GetVersion() { return SDL_GetVersion(); }

//! @copydoc SDL_GetRevision()
inline const char* GetRevision() { return SDL_GetRevision(); }

}

class Window
{
    SDL_Window* _ptr;
    bool _block_destroy;
    Window(SDL_Window* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Window> Create(std::string& title, int w, int h, SDL::WindowFlags flags) { return get(SDL::raw::CreateWindow(title.c_str(), w, h, flags)); }

    Window(const Window&) = delete;
    ~Window() { if (!_block_destroy) SDL::raw::DestroyWindow(_ptr); }
    Window& operator=(const Window&) = delete;

    inline SDL_DisplayID GetDisplayFor() const { return SDL::raw::GetDisplayForWindow(_ptr); }
    inline float GetPixelDensity() const { return SDL::raw::GetWindowPixelDensity(_ptr); }
    inline float GetDisplayScale() const { return SDL::raw::GetWindowDisplayScale(_ptr); }
    inline void SetFullscreenMode(const SDL_DisplayMode* mode) const { SDL::raw::SetWindowFullscreenMode(_ptr, mode); }
    inline const SDL_DisplayMode* GetFullscreenMode() const { return SDL::raw::GetWindowFullscreenMode(_ptr); }
    inline void* GetICCProfile(size_t* size) const { return SDL::raw::GetWindowICCProfile(_ptr, size); }
    inline SDL_PixelFormat GetPixelFormat() const { return SDL::raw::GetWindowPixelFormat(_ptr); }
    inline std::shared_ptr<SDL::Window> CreatePopup(int offset_x, int offset_y, int w, int h, SDL::WindowFlags flags) const { return SDL::Window::get(SDL::raw::CreatePopupWindow(_ptr, offset_x, offset_y, w, h, flags)); }
    inline SDL_WindowID GetID() const { return SDL::raw::GetWindowID(_ptr); }
    inline std::shared_ptr<SDL::Window> GetParent() const { return SDL::Window::get(SDL::raw::GetWindowParent(_ptr)); }
    inline SDL_PropertiesID GetProperties() const { return SDL::raw::GetWindowProperties(_ptr); }
    inline SDL::WindowFlags GetFlags() const { return (SDL::WindowFlags) SDL::raw::GetWindowFlags(_ptr); }
    inline void SetTitle(std::string& title) const { SDL::raw::SetWindowTitle(_ptr, title.c_str()); }
    inline std::string GetTitle() const { return SDL::raw::GetWindowTitle(_ptr); }
    inline void SetIcon(std::shared_ptr<SDL::Surface> icon) const { SDL::raw::SetWindowIcon(_ptr, icon->get()); }
    inline void SetPosition(int x, int y) const { SDL::raw::SetWindowPosition(_ptr, x, y); }
    inline SDL::Point GetPosition() const { SDL::Point _p = {}; SDL::raw::GetWindowPosition(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetSize(int w, int h) const { SDL::raw::SetWindowSize(_ptr, w, h); }
    inline SDL::Point GetSize() const { SDL::Point _p = {}; SDL::raw::GetWindowSize(_ptr, &_p.x, &_p.y); return _p; }
    inline SDL::Rect GetSafeArea() const { SDL_Rect _out; SDL::raw::GetWindowSafeArea(_ptr, &_out); return _out; }
    inline void SetAspectRatio(float min_aspect, float max_aspect) const { SDL::raw::SetWindowAspectRatio(_ptr, min_aspect, max_aspect); }
    inline SDL::FPoint GetAspectRatio() const { SDL::FPoint _p = {}; SDL::raw::GetWindowAspectRatio(_ptr, &_p.x, &_p.y); return _p; }
    inline SDL::Rect GetBordersSize() const { SDL::Rect _r = {}; SDL::raw::GetWindowBordersSize(_ptr, &_r.x, &_r.y, &_r.w, &_r.h); return _r; }
    inline SDL::Point GetSizeInPixels() const { SDL::Point _p = {}; SDL::raw::GetWindowSizeInPixels(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetMinimumSize(int min_w, int min_h) const { SDL::raw::SetWindowMinimumSize(_ptr, min_w, min_h); }
    inline SDL::Point GetMinimumSize() const { SDL::Point _p = {}; SDL::raw::GetWindowMinimumSize(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetMaximumSize(int max_w, int max_h) const { SDL::raw::SetWindowMaximumSize(_ptr, max_w, max_h); }
    inline SDL::Point GetMaximumSize() const { SDL::Point _p = {}; SDL::raw::GetWindowMaximumSize(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetBordered(bool bordered) const { SDL::raw::SetWindowBordered(_ptr, bordered); }
    inline void SetResizable(bool resizable) const { SDL::raw::SetWindowResizable(_ptr, resizable); }
    inline void SetAlwaysOnTop(bool on_top) const { SDL::raw::SetWindowAlwaysOnTop(_ptr, on_top); }
    inline void Show() const { SDL::raw::ShowWindow(_ptr); }
    inline void Hide() const { SDL::raw::HideWindow(_ptr); }
    inline void Raise() const { SDL::raw::RaiseWindow(_ptr); }
    inline void Maximize() const { SDL::raw::MaximizeWindow(_ptr); }
    inline void Minimize() const { SDL::raw::MinimizeWindow(_ptr); }
    inline void Restore() const { SDL::raw::RestoreWindow(_ptr); }
    inline void SetFullscreen(bool fullscreen) const { SDL::raw::SetWindowFullscreen(_ptr, fullscreen); }
    inline bool Sync() const { return SDL::raw::SyncWindow(_ptr); }
    inline bool HasSurface() const { return SDL::raw::WindowHasSurface(_ptr); }
    inline std::shared_ptr<SDL::Surface> GetSurface() const { return SDL::Surface::get(SDL::raw::GetWindowSurface(_ptr)); }
    inline void SetSurfaceVSync(int vsync) const { SDL::raw::SetWindowSurfaceVSync(_ptr, vsync); }
    inline int GetSurfaceVSync() const { int _out; SDL::raw::GetWindowSurfaceVSync(_ptr, &_out); return _out; }
    inline void UpdateSurface() const { SDL::raw::UpdateWindowSurface(_ptr); }
    inline void UpdateSurfaceRects(const SDL::Rect& rects, int numrects) const { SDL::raw::UpdateWindowSurfaceRects(_ptr, &rects, numrects); }
    inline void DestroySurface() const { SDL::raw::DestroyWindowSurface(_ptr); }
    inline void SetKeyboardGrab(bool grabbed) const { SDL::raw::SetWindowKeyboardGrab(_ptr, grabbed); }
    inline void SetMouseGrab(bool grabbed) const { SDL::raw::SetWindowMouseGrab(_ptr, grabbed); }
    inline bool GetKeyboardGrab() const { return SDL::raw::GetWindowKeyboardGrab(_ptr); }
    inline bool GetMouseGrab() const { return SDL::raw::GetWindowMouseGrab(_ptr); }
    inline void SetMouseRect(const SDL::Rect& rect) const { SDL::raw::SetWindowMouseRect(_ptr, &rect); }
    inline const SDL::Rect& GetMouseRect() const { return *SDL::raw::GetWindowMouseRect(_ptr); }
    inline void SetOpacity(float opacity) const { SDL::raw::SetWindowOpacity(_ptr, opacity); }
    inline float GetOpacity() const { return SDL::raw::GetWindowOpacity(_ptr); }
    inline void SetParent(std::shared_ptr<SDL::Window> parent) const { SDL::raw::SetWindowParent(_ptr, parent->get()); }
    inline void SetModal(bool modal) const { SDL::raw::SetWindowModal(_ptr, modal); }
    inline void SetFocusable(bool focusable) const { SDL::raw::SetWindowFocusable(_ptr, focusable); }
    inline void ShowSystemMenu(int x, int y) const { SDL::raw::ShowWindowSystemMenu(_ptr, x, y); }
    inline void SetHitTest(SDL_HitTest callback, void* callback_data) const { SDL::raw::SetWindowHitTest(_ptr, callback, callback_data); }
    inline void SetShape(std::shared_ptr<SDL::Surface> shape) const { SDL::raw::SetWindowShape(_ptr, shape->get()); }
    inline void Flash(SDL_FlashOperation operation) const { SDL::raw::FlashWindow(_ptr, operation); }
    inline SDL_GLContext GL_CreateContext() const { return SDL::raw::GL_CreateContext(_ptr); }
    inline void GL_MakeCurrent(SDL_GLContext context) const { SDL::raw::GL_MakeCurrent(_ptr, context); }
    inline SDL_EGLSurface EGL_GetSurface() const { return SDL::raw::EGL_GetWindowSurface(_ptr); }
    inline void GL_Swap() const { SDL::raw::GL_SwapWindow(_ptr); }
    inline void StartTextInput() const { SDL::raw::StartTextInput(_ptr); }
    inline void StartTextInputWithProperties(SDL_PropertiesID props) const { SDL::raw::StartTextInputWithProperties(_ptr, props); }
    inline bool TextInputActive() const { return SDL::raw::TextInputActive(_ptr); }
    inline void StopTextInput() const { SDL::raw::StopTextInput(_ptr); }
    inline void ClearComposition() const { SDL::raw::ClearComposition(_ptr); }
    inline void SetTextInputArea(const SDL::Rect& rect, int cursor) const { SDL::raw::SetTextInputArea(_ptr, &rect, cursor); }
    inline void GetTextInputArea(SDL::Rect& rect, int* cursor) const { SDL::raw::GetTextInputArea(_ptr, &rect, cursor); }
    inline bool ScreenKeyboardShown() const { return SDL::raw::ScreenKeyboardShown(_ptr); }
    inline void WarpMouseIn(float x, float y) const { SDL::raw::WarpMouseInWindow(_ptr, x, y); }
    inline void SetRelativeMouseMode(bool enabled) const { SDL::raw::SetWindowRelativeMouseMode(_ptr, enabled); }
    inline bool GetRelativeMouseMode() const { return SDL::raw::GetWindowRelativeMouseMode(_ptr); }
    inline SDL_MetalView Metal_CreateView() const { return SDL::raw::Metal_CreateView(_ptr); }
    inline std::shared_ptr<SDL::Renderer> CreateRenderer(std::string& name) const { return SDL::Renderer::get(SDL::raw::CreateRenderer(_ptr, name.c_str())); }
    inline std::shared_ptr<SDL::Renderer> GetRenderer() const { return SDL::Renderer::get(SDL::raw::GetRenderer(_ptr)); }

    inline SDL_Window* get() const { return _ptr; }

    static inline std::shared_ptr<Window> get(SDL_Window* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Window> obj(new Window(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Window*, std::weak_ptr<Window>> _ptrs;
};

class Renderer
{
    SDL_Renderer* _ptr;
    bool _block_destroy;
    Renderer(SDL_Renderer* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Renderer> Create(std::shared_ptr<SDL::Window> window, std::string& name) { return get(SDL::raw::CreateRenderer(window->get(), name.c_str())); }

    Renderer(const Renderer&) = delete;
    ~Renderer() { if (!_block_destroy) SDL::raw::DestroyRenderer(_ptr); }
    Renderer& operator=(const Renderer&) = delete;

    inline std::shared_ptr<SDL::Window> GetRenderWindow() const { return SDL::Window::get(SDL::raw::GetRenderWindow(_ptr)); }
    inline std::string GetName() const { return SDL::raw::GetRendererName(_ptr); }
    inline SDL_PropertiesID GetProperties() const { return SDL::raw::GetRendererProperties(_ptr); }
    inline SDL::Point GetRenderOutputSize() const { SDL::Point _p = {}; SDL::raw::GetRenderOutputSize(_ptr, &_p.x, &_p.y); return _p; }
    inline SDL::Point GetCurrentRenderOutputSize() const { SDL::Point _p = {}; SDL::raw::GetCurrentRenderOutputSize(_ptr, &_p.x, &_p.y); return _p; }
    inline std::shared_ptr<SDL::Texture> CreateTexture(SDL_PixelFormat format, SDL_TextureAccess access, int w, int h) const { return SDL::Texture::get(SDL::raw::CreateTexture(_ptr, format, access, w, h)); }
    inline std::shared_ptr<SDL::Texture> CreateTextureFromSurface(std::shared_ptr<SDL::Surface> surface) const { return SDL::Texture::get(SDL::raw::CreateTextureFromSurface(_ptr, surface->get())); }
    inline std::shared_ptr<SDL::Texture> CreateTextureWithProperties(SDL_PropertiesID props) const { return SDL::Texture::get(SDL::raw::CreateTextureWithProperties(_ptr, props)); }
    inline void SetRenderTarget(std::shared_ptr<SDL::Texture> texture) const { SDL::raw::SetRenderTarget(_ptr, texture->get()); }
    inline std::shared_ptr<SDL::Texture> GetRenderTarget() const { return SDL::Texture::get(SDL::raw::GetRenderTarget(_ptr)); }
    inline void SetRenderLogicalPresentation(int w, int h, SDL_RendererLogicalPresentation mode) const { SDL::raw::SetRenderLogicalPresentation(_ptr, w, h, mode); }
    inline void GetRenderLogicalPresentation(int* w, int* h, SDL_RendererLogicalPresentation* mode) const { SDL::raw::GetRenderLogicalPresentation(_ptr, w, h, mode); }
    inline SDL::FRect GetRenderLogicalPresentationRect() const { SDL_FRect _out; SDL::raw::GetRenderLogicalPresentationRect(_ptr, &_out); return _out; }
    inline void RenderCoordinatesFromWindow(float window_x, float window_y, float* x, float* y) const { SDL::raw::RenderCoordinatesFromWindow(_ptr, window_x, window_y, x, y); }
    inline void RenderCoordinatesToWindow(float x, float y, float* window_x, float* window_y) const { SDL::raw::RenderCoordinatesToWindow(_ptr, x, y, window_x, window_y); }
    inline void ConvertEventToRenderCoordinates(SDL_Event* event) const { SDL::raw::ConvertEventToRenderCoordinates(_ptr, event); }
    inline void SetRenderViewport(const SDL::Rect& rect) const { SDL::raw::SetRenderViewport(_ptr, &rect); }
    inline SDL::Rect GetRenderViewport() const { SDL_Rect _out; SDL::raw::GetRenderViewport(_ptr, &_out); return _out; }
    inline bool RenderViewportSet() const { return SDL::raw::RenderViewportSet(_ptr); }
    inline SDL::Rect GetRenderSafeArea() const { SDL_Rect _out; SDL::raw::GetRenderSafeArea(_ptr, &_out); return _out; }
    inline void SetRenderClipRect(const SDL::Rect& rect) const { SDL::raw::SetRenderClipRect(_ptr, &rect); }
    inline SDL::Rect GetRenderClipRect() const { SDL_Rect _out; SDL::raw::GetRenderClipRect(_ptr, &_out); return _out; }
    inline void RenderClipEnabled() const { SDL::raw::RenderClipEnabled(_ptr); }
    inline void SetRenderScale(float scaleX, float scaleY) const { SDL::raw::SetRenderScale(_ptr, scaleX, scaleY); }
    inline SDL::FPoint GetRenderScale() const { SDL::FPoint _p = {}; SDL::raw::GetRenderScale(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetRenderDrawColor(Uint8 r, Uint8 g, Uint8 b, Uint8 a) const { SDL::raw::SetRenderDrawColor(_ptr, r, g, b, a); }
    inline void SetRenderDrawColorFloat(float r, float g, float b, float a) const { SDL::raw::SetRenderDrawColorFloat(_ptr, r, g, b, a); }
    inline void GetRenderDrawColor(Uint8* r, Uint8* g, Uint8* b, Uint8* a) const { SDL::raw::GetRenderDrawColor(_ptr, r, g, b, a); }
    inline SDL::FRect GetRenderDrawColorFloat() const { SDL::FRect _r = {}; SDL::raw::GetRenderDrawColorFloat(_ptr, &_r.x, &_r.y, &_r.w, &_r.h); return _r; }
    inline void SetRenderColorScale(float scale) const { SDL::raw::SetRenderColorScale(_ptr, scale); }
    inline float GetRenderColorScale() const { float _out; SDL::raw::GetRenderColorScale(_ptr, &_out); return _out; }
    inline void SetRenderDrawBlendMode(SDL_BlendMode blendMode) const { SDL::raw::SetRenderDrawBlendMode(_ptr, blendMode); }
    inline SDL_BlendMode GetRenderDrawBlendMode() const { SDL_BlendMode _out; SDL::raw::GetRenderDrawBlendMode(_ptr, &_out); return _out; }
    inline void RenderClear() const { SDL::raw::RenderClear(_ptr); }
    inline void RenderPoint(float x, float y) const { SDL::raw::RenderPoint(_ptr, x, y); }
    inline void RenderPoints(const SDL::FPoint& points, int count) const { SDL::raw::RenderPoints(_ptr, &points, count); }
    inline void RenderLine(float x1, float y1, float x2, float y2) const { SDL::raw::RenderLine(_ptr, x1, y1, x2, y2); }
    inline void RenderLines(const SDL::FPoint& points, int count) const { SDL::raw::RenderLines(_ptr, &points, count); }
    inline void RenderRect(const SDL::FRect& rect) const { SDL::raw::RenderRect(_ptr, &rect); }
    inline void RenderRects(const SDL::FRect& rects, int count) const { SDL::raw::RenderRects(_ptr, &rects, count); }
    inline void RenderFillRect(const SDL::FRect& rect) const { SDL::raw::RenderFillRect(_ptr, &rect); }
    inline void RenderFillRects(const SDL::FRect& rects, int count) const { SDL::raw::RenderFillRects(_ptr, &rects, count); }
    inline void RenderTexture(std::shared_ptr<SDL::Texture> texture, const SDL::FRect& srcrect, const SDL::FRect& dstrect) const { SDL::raw::RenderTexture(_ptr, texture->get(), &srcrect, &dstrect); }
    inline void RenderTextureRotated(std::shared_ptr<SDL::Texture> texture, const SDL::FRect& srcrect, const SDL::FRect& dstrect, double angle, const SDL::FPoint& center, SDL_FlipMode flip) const { SDL::raw::RenderTextureRotated(_ptr, texture->get(), &srcrect, &dstrect, angle, &center, flip); }
    inline void RenderTextureAffine(std::shared_ptr<SDL::Texture> texture, const SDL::FRect& srcrect, const SDL::FPoint& origin, const SDL::FPoint& right, const SDL::FPoint& down) const { SDL::raw::RenderTextureAffine(_ptr, texture->get(), &srcrect, &origin, &right, &down); }
    inline void RenderTextureTiled(std::shared_ptr<SDL::Texture> texture, const SDL::FRect& srcrect, float scale, const SDL::FRect& dstrect) const { SDL::raw::RenderTextureTiled(_ptr, texture->get(), &srcrect, scale, &dstrect); }
    inline void RenderTexture9Grid(std::shared_ptr<SDL::Texture> texture, const SDL::FRect& srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, const SDL::FRect& dstrect) const { SDL::raw::RenderTexture9Grid(_ptr, texture->get(), &srcrect, left_width, right_width, top_height, bottom_height, scale, &dstrect); }
    inline void RenderGeometry(std::shared_ptr<SDL::Texture> texture, const SDL_Vertex* vertices, int num_vertices, const int* indices, int num_indices) const { SDL::raw::RenderGeometry(_ptr, texture->get(), vertices, num_vertices, indices, num_indices); }
    inline void RenderGeometryRaw(std::shared_ptr<SDL::Texture> texture, const float* xy, int xy_stride, const SDL_FColor* color, int color_stride, const float* uv, int uv_stride, int num_vertices, const void* indices, int num_indices, int size_indices) const { SDL::raw::RenderGeometryRaw(_ptr, texture->get(), xy, xy_stride, color, color_stride, uv, uv_stride, num_vertices, indices, num_indices, size_indices); }
    inline std::shared_ptr<SDL::Surface> RenderReadPixels(const SDL::Rect& rect) const { return SDL::Surface::get(SDL::raw::RenderReadPixels(_ptr, &rect)); }
    inline void RenderPresent() const { SDL::raw::RenderPresent(_ptr); }
    inline void Flush() const { SDL::raw::FlushRenderer(_ptr); }
    inline void* GetRenderMetalLayer() const { return SDL::raw::GetRenderMetalLayer(_ptr); }
    inline void* GetRenderMetalCommandEncoder() const { return SDL::raw::GetRenderMetalCommandEncoder(_ptr); }
    inline void AddVulkanRenderSemaphores(Uint32 wait_stage_mask, Sint64 wait_semaphore, Sint64 signal_semaphore) const { SDL::raw::AddVulkanRenderSemaphores(_ptr, wait_stage_mask, wait_semaphore, signal_semaphore); }
    inline void SetRenderVSync(int vsync) const { SDL::raw::SetRenderVSync(_ptr, vsync); }
    inline int GetRenderVSync() const { int _out; SDL::raw::GetRenderVSync(_ptr, &_out); return _out; }
    inline void RenderDebugText(float x, float y, std::string& str) const { SDL::raw::RenderDebugText(_ptr, x, y, str.c_str()); }

    inline SDL_Renderer* get() const { return _ptr; }

    static inline std::shared_ptr<Renderer> get(SDL_Renderer* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Renderer> obj(new Renderer(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Renderer*, std::weak_ptr<Renderer>> _ptrs;
};

class Surface
{
    SDL_Surface* _ptr;
    bool _block_destroy;
    Surface(SDL_Surface* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Surface> Create(int width, int height, SDL_PixelFormat format) { return get(SDL::raw::CreateSurface(width, height, format)); }
    static inline std::shared_ptr<Surface> Create(int width, int height, SDL_PixelFormat format, void* pixels, int pitch) { return get(SDL::raw::CreateSurfaceFrom(width, height, format, pixels, pitch)); }

    Surface(const Surface&) = delete;
    ~Surface() { if (!_block_destroy) SDL::raw::DestroySurface(_ptr); }
    Surface& operator=(const Surface&) = delete;

    inline SDL_PropertiesID GetProperties() const { return SDL::raw::GetSurfaceProperties(_ptr); }
    inline void SetColorspace(SDL_Colorspace colorspace) const { SDL::raw::SetSurfaceColorspace(_ptr, colorspace); }
    inline SDL_Colorspace GetColorspace() const { return SDL::raw::GetSurfaceColorspace(_ptr); }
    inline std::shared_ptr<SDL::Palette> CreatePalette() const { return SDL::Palette::get(SDL::raw::CreateSurfacePalette(_ptr)); }
    inline void SetPalette(std::shared_ptr<SDL::Palette> palette) const { SDL::raw::SetSurfacePalette(_ptr, palette->get()); }
    inline std::shared_ptr<SDL::Palette> GetPalette() const { return SDL::Palette::get(SDL::raw::GetSurfacePalette(_ptr)); }
    inline void AddAlternateImage(std::shared_ptr<SDL::Surface> image) const { SDL::raw::AddSurfaceAlternateImage(_ptr, image->get()); }
    inline bool HasAlternateImages() const { return SDL::raw::SurfaceHasAlternateImages(_ptr); }
    inline std::vector<std::shared_ptr<SDL::Surface>> GetImages() const { int _count; std::vector<std::shared_ptr<SDL::Surface>> _items; auto _ret = SDL::raw::GetSurfaceImages(_ptr, &_count); for (int i = 0; i < _count; i++) _items.push_back(SDL::Surface::get(_ret[i])); return _items; }
    inline void RemoveAlternateImages() const { SDL::raw::RemoveSurfaceAlternateImages(_ptr); }
    inline void Lock() const { SDL::raw::LockSurface(_ptr); }
    inline void Unlock() const { SDL::raw::UnlockSurface(_ptr); }
    inline void SaveBMP_IO(SDL_IOStream* dst, bool closeio) const { SDL::raw::SaveBMP_IO(_ptr, dst, closeio); }
    inline void SaveBMP(std::string& file) const { SDL::raw::SaveBMP(_ptr, file.c_str()); }
    inline void SetRLE(bool enabled) const { SDL::raw::SetSurfaceRLE(_ptr, enabled); }
    inline bool HasRLE() const { return SDL::raw::SurfaceHasRLE(_ptr); }
    inline void SetColorKey(bool enabled, Uint32 key) const { SDL::raw::SetSurfaceColorKey(_ptr, enabled, key); }
    inline bool HasColorKey() const { return SDL::raw::SurfaceHasColorKey(_ptr); }
    inline Uint32 GetColorKey() const { Uint32 _out; SDL::raw::GetSurfaceColorKey(_ptr, &_out); return _out; }
    inline void SetColorMod(Uint8 r, Uint8 g, Uint8 b) const { SDL::raw::SetSurfaceColorMod(_ptr, r, g, b); }
    inline void GetColorMod(Uint8* r, Uint8* g, Uint8* b) const { SDL::raw::GetSurfaceColorMod(_ptr, r, g, b); }
    inline void SetAlphaMod(Uint8 alpha) const { SDL::raw::SetSurfaceAlphaMod(_ptr, alpha); }
    inline Uint8 GetAlphaMod() const { Uint8 _out; SDL::raw::GetSurfaceAlphaMod(_ptr, &_out); return _out; }
    inline void SetBlendMode(SDL_BlendMode blendMode) const { SDL::raw::SetSurfaceBlendMode(_ptr, blendMode); }
    inline SDL_BlendMode GetBlendMode() const { SDL_BlendMode _out; SDL::raw::GetSurfaceBlendMode(_ptr, &_out); return _out; }
    inline bool SetClipRect(const SDL::Rect& rect) const { return SDL::raw::SetSurfaceClipRect(_ptr, &rect); }
    inline SDL::Rect GetClipRect() const { SDL_Rect _out; SDL::raw::GetSurfaceClipRect(_ptr, &_out); return _out; }
    inline void Flip(SDL_FlipMode flip) const { SDL::raw::FlipSurface(_ptr, flip); }
    inline std::shared_ptr<SDL::Surface> Duplicate() const { return SDL::Surface::get(SDL::raw::DuplicateSurface(_ptr)); }
    inline std::shared_ptr<SDL::Surface> Scale(int width, int height, SDL_ScaleMode scaleMode) const { return SDL::Surface::get(SDL::raw::ScaleSurface(_ptr, width, height, scaleMode)); }
    inline std::shared_ptr<SDL::Surface> Convert(SDL_PixelFormat format) const { return SDL::Surface::get(SDL::raw::ConvertSurface(_ptr, format)); }
    inline std::shared_ptr<SDL::Surface> ConvertAndColorspace(SDL_PixelFormat format, std::shared_ptr<SDL::Palette> palette, SDL_Colorspace colorspace, SDL_PropertiesID props) const { return SDL::Surface::get(SDL::raw::ConvertSurfaceAndColorspace(_ptr, format, palette->get(), colorspace, props)); }
    inline void PremultiplyAlpha(bool linear) const { SDL::raw::PremultiplySurfaceAlpha(_ptr, linear); }
    inline void Clear(float r, float g, float b, float a) const { SDL::raw::ClearSurface(_ptr, r, g, b, a); }
    inline void FillRect(const SDL::Rect& rect, Uint32 color) const { SDL::raw::FillSurfaceRect(_ptr, &rect, color); }
    inline void FillRects(const SDL::Rect& rects, int count, Uint32 color) const { SDL::raw::FillSurfaceRects(_ptr, &rects, count, color); }
    inline void Blit(const SDL::Rect& srcrect, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect) const { SDL::raw::BlitSurface(_ptr, &srcrect, dst->get(), &dstrect); }
    inline void BlitUnchecked(const SDL::Rect& srcrect, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect) const { SDL::raw::BlitSurfaceUnchecked(_ptr, &srcrect, dst->get(), &dstrect); }
    inline void BlitScaled(const SDL::Rect& srcrect, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect, SDL_ScaleMode scaleMode) const { SDL::raw::BlitSurfaceScaled(_ptr, &srcrect, dst->get(), &dstrect, scaleMode); }
    inline void BlitUncheckedScaled(const SDL::Rect& srcrect, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect, SDL_ScaleMode scaleMode) const { SDL::raw::BlitSurfaceUncheckedScaled(_ptr, &srcrect, dst->get(), &dstrect, scaleMode); }
    inline void BlitTiled(const SDL::Rect& srcrect, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect) const { SDL::raw::BlitSurfaceTiled(_ptr, &srcrect, dst->get(), &dstrect); }
    inline void BlitTiledWithScale(const SDL::Rect& srcrect, float scale, SDL_ScaleMode scaleMode, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect) const { SDL::raw::BlitSurfaceTiledWithScale(_ptr, &srcrect, scale, scaleMode, dst->get(), &dstrect); }
    inline void Blit9Grid(const SDL::Rect& srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, SDL_ScaleMode scaleMode, std::shared_ptr<SDL::Surface> dst, const SDL::Rect& dstrect) const { SDL::raw::BlitSurface9Grid(_ptr, &srcrect, left_width, right_width, top_height, bottom_height, scale, scaleMode, dst->get(), &dstrect); }
    inline Uint32 MapRGB(Uint8 r, Uint8 g, Uint8 b) const { return SDL::raw::MapSurfaceRGB(_ptr, r, g, b); }
    inline Uint32 MapRGBA(Uint8 r, Uint8 g, Uint8 b, Uint8 a) const { return SDL::raw::MapSurfaceRGBA(_ptr, r, g, b, a); }
    inline void ReadPixel(int x, int y, Uint8* r, Uint8* g, Uint8* b, Uint8* a) const { SDL::raw::ReadSurfacePixel(_ptr, x, y, r, g, b, a); }
    inline void ReadPixelFloat(int x, int y, float* r, float* g, float* b, float* a) const { SDL::raw::ReadSurfacePixelFloat(_ptr, x, y, r, g, b, a); }
    inline void WritePixel(int x, int y, Uint8 r, Uint8 g, Uint8 b, Uint8 a) const { SDL::raw::WriteSurfacePixel(_ptr, x, y, r, g, b, a); }
    inline void WritePixelFloat(int x, int y, float r, float g, float b, float a) const { SDL::raw::WriteSurfacePixelFloat(_ptr, x, y, r, g, b, a); }
    inline SDL_Cursor* CreateColorCursor(int hot_x, int hot_y) const { return SDL::raw::CreateColorCursor(_ptr, hot_x, hot_y); }
    inline std::shared_ptr<SDL::Renderer> CreateSoftwareRenderer() const { return SDL::Renderer::get(SDL::raw::CreateSoftwareRenderer(_ptr)); }
    inline std::shared_ptr<SDL::Tray> CreateTray(std::string& tooltip) const { return SDL::Tray::get(SDL::raw::CreateTray(_ptr, tooltip.c_str())); }

    inline SDL_Surface* get() const { return _ptr; }

    static inline std::shared_ptr<Surface> get(SDL_Surface* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Surface> obj(new Surface(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Surface*, std::weak_ptr<Surface>> _ptrs;
};

class Texture
{
    SDL_Texture* _ptr;
    bool _block_destroy;
    Texture(SDL_Texture* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Texture> Create(std::shared_ptr<SDL::Renderer> renderer, SDL_PixelFormat format, SDL_TextureAccess access, int w, int h) { return get(SDL::raw::CreateTexture(renderer->get(), format, access, w, h)); }
    static inline std::shared_ptr<Texture> Create(std::shared_ptr<SDL::Renderer> renderer, std::shared_ptr<SDL::Surface> surface) { return get(SDL::raw::CreateTextureFromSurface(renderer->get(), surface->get())); }
    static inline std::shared_ptr<Texture> Create(std::shared_ptr<SDL::Renderer> renderer, SDL_PropertiesID props) { return get(SDL::raw::CreateTextureWithProperties(renderer->get(), props)); }

    Texture(const Texture&) = delete;
    ~Texture() { if (!_block_destroy) SDL::raw::DestroyTexture(_ptr); }
    Texture& operator=(const Texture&) = delete;

    inline SDL_PropertiesID GetProperties() const { return SDL::raw::GetTextureProperties(_ptr); }
    inline std::shared_ptr<SDL::Renderer> GetRendererFrom() const { return SDL::Renderer::get(SDL::raw::GetRendererFromTexture(_ptr)); }
    inline SDL::FPoint GetSize() const { SDL::FPoint _p = {}; SDL::raw::GetTextureSize(_ptr, &_p.x, &_p.y); return _p; }
    inline void SetColorMod(Uint8 r, Uint8 g, Uint8 b) const { SDL::raw::SetTextureColorMod(_ptr, r, g, b); }
    inline void SetColorModFloat(float r, float g, float b) const { SDL::raw::SetTextureColorModFloat(_ptr, r, g, b); }
    inline void GetColorMod(Uint8* r, Uint8* g, Uint8* b) const { SDL::raw::GetTextureColorMod(_ptr, r, g, b); }
    inline void GetColorModFloat(float* r, float* g, float* b) const { SDL::raw::GetTextureColorModFloat(_ptr, r, g, b); }
    inline void SetAlphaMod(Uint8 alpha) const { SDL::raw::SetTextureAlphaMod(_ptr, alpha); }
    inline void SetAlphaModFloat(float alpha) const { SDL::raw::SetTextureAlphaModFloat(_ptr, alpha); }
    inline Uint8 GetAlphaMod() const { Uint8 _out; SDL::raw::GetTextureAlphaMod(_ptr, &_out); return _out; }
    inline float GetAlphaModFloat() const { float _out; SDL::raw::GetTextureAlphaModFloat(_ptr, &_out); return _out; }
    inline void SetBlendMode(SDL_BlendMode blendMode) const { SDL::raw::SetTextureBlendMode(_ptr, blendMode); }
    inline SDL_BlendMode GetBlendMode() const { SDL_BlendMode _out; SDL::raw::GetTextureBlendMode(_ptr, &_out); return _out; }
    inline void SetScaleMode(SDL_ScaleMode scaleMode) const { SDL::raw::SetTextureScaleMode(_ptr, scaleMode); }
    inline SDL_ScaleMode GetScaleMode() const { SDL_ScaleMode _out; SDL::raw::GetTextureScaleMode(_ptr, &_out); return _out; }
    inline void Update(const SDL::Rect& rect, const void* pixels, int pitch) const { SDL::raw::UpdateTexture(_ptr, &rect, pixels, pitch); }
    inline void UpdateYUV(const SDL::Rect& rect, const Uint8* Yplane, int Ypitch, const Uint8* Uplane, int Upitch, const Uint8* Vplane, int Vpitch) const { SDL::raw::UpdateYUVTexture(_ptr, &rect, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch); }
    inline void UpdateNV(const SDL::Rect& rect, const Uint8* Yplane, int Ypitch, const Uint8* UVplane, int UVpitch) const { SDL::raw::UpdateNVTexture(_ptr, &rect, Yplane, Ypitch, UVplane, UVpitch); }
    inline void Lock(const SDL::Rect& rect, void** pixels, int* pitch) const { SDL::raw::LockTexture(_ptr, &rect, pixels, pitch); }
    inline std::shared_ptr<SDL::Surface> LockToSurface(const SDL::Rect& rect) const { SDL_Surface* _out; SDL::raw::LockTextureToSurface(get(), &rect, &_out); return SDL::Surface::get(_out, true); }
    inline void Unlock() const { SDL::raw::UnlockTexture(_ptr); }

    inline SDL_Texture* get() const { return _ptr; }

    static inline std::shared_ptr<Texture> get(SDL_Texture* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Texture> obj(new Texture(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Texture*, std::weak_ptr<Texture>> _ptrs;
};

class Palette
{
    SDL_Palette* _ptr;
    bool _block_destroy;
    Palette(SDL_Palette* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Palette> Create(int ncolors) { return get(SDL::raw::CreatePalette(ncolors)); }
    static inline std::shared_ptr<Palette> Create(std::shared_ptr<SDL::Surface> surface) { return get(SDL::raw::CreateSurfacePalette(surface->get())); }

    Palette(const Palette&) = delete;
    ~Palette() { if (!_block_destroy) SDL::raw::DestroyPalette(_ptr); }
    Palette& operator=(const Palette&) = delete;

    inline void SetColors(const SDL_Color* colors, int firstcolor, int ncolors) const { SDL::raw::SetPaletteColors(_ptr, colors, firstcolor, ncolors); }

    inline SDL_Palette* get() const { return _ptr; }

    static inline std::shared_ptr<Palette> get(SDL_Palette* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Palette> obj(new Palette(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Palette*, std::weak_ptr<Palette>> _ptrs;
};

class Tray
{
    SDL_Tray* _ptr;
    bool _block_destroy;
    Tray(SDL_Tray* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<Tray> Create(std::shared_ptr<SDL::Surface> icon, std::string& tooltip) { return get(SDL::raw::CreateTray(icon->get(), tooltip.c_str())); }

    Tray(const Tray&) = delete;
    ~Tray() { if (!_block_destroy) SDL::raw::DestroyTray(_ptr); }
    Tray& operator=(const Tray&) = delete;

    inline void SetIcon(std::shared_ptr<SDL::Surface> icon) const { SDL::raw::SetTrayIcon(_ptr, icon->get()); }
    inline void SetTooltip(std::string& tooltip) const { SDL::raw::SetTrayTooltip(_ptr, tooltip.c_str()); }
    inline std::shared_ptr<SDL::TrayMenu> CreateMenu() const { return SDL::TrayMenu::get(SDL::raw::CreateTrayMenu(_ptr)); }
    inline std::shared_ptr<SDL::TrayMenu> GetMenu() const { return SDL::TrayMenu::get(SDL::raw::GetTrayMenu(_ptr)); }

    inline SDL_Tray* get() const { return _ptr; }

    static inline std::shared_ptr<Tray> get(SDL_Tray* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<Tray> obj(new Tray(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_Tray*, std::weak_ptr<Tray>> _ptrs;
};

class TrayMenu
{
    SDL_TrayMenu* _ptr;
    bool _block_destroy;
    TrayMenu(SDL_TrayMenu* ptr, bool block_destroy) : _ptr(ptr), _block_destroy(block_destroy) { }
public:
    static inline std::shared_ptr<TrayMenu> Create(std::shared_ptr<SDL::Tray> tray) { return get(SDL::raw::CreateTrayMenu(tray->get())); }

    TrayMenu(const TrayMenu&) = delete;
    TrayMenu& operator=(const TrayMenu&) = delete;

    inline const SDL_TrayEntry** GetTrayEntries(int* size) const { return SDL::raw::GetTrayEntries(_ptr, size); }
    inline SDL_TrayEntry* InsertTrayEntryAt(int pos, std::string& label, SDL::TrayEntryFlags flags) const { return SDL::raw::InsertTrayEntryAt(_ptr, pos, label.c_str(), flags); }
    inline SDL_TrayEntry* GetParentEntry() const { return SDL::raw::GetTrayMenuParentEntry(_ptr); }
    inline std::shared_ptr<SDL::Tray> GetParentTray() const { return SDL::Tray::get(SDL::raw::GetTrayMenuParentTray(_ptr)); }

    inline SDL_TrayMenu* get() const { return _ptr; }

    static inline std::shared_ptr<TrayMenu> get(SDL_TrayMenu* ptr, bool block_destroy = false)
    {
        auto& entry = _ptrs[ptr];
        if (!entry.expired()) return entry.lock();
        std::shared_ptr<TrayMenu> obj(new TrayMenu(ptr, block_destroy));
        entry = obj;
        return obj;
    }
private:
    static std::unordered_map<SDL_TrayMenu*, std::weak_ptr<TrayMenu>> _ptrs;
};
inline SDL_AssertState ReportAssertion(SDL_AssertData* data, std::string& func, std::string& file, int line) { return SDL::raw::ReportAssertion(data, func.c_str(), file.c_str(), line); }
inline void SetAssertionHandler(SDL_AssertionHandler handler, void* userdata) { SDL::raw::SetAssertionHandler(handler, userdata); }
inline SDL_AssertionHandler GetDefaultAssertionHandler() { return SDL::raw::GetDefaultAssertionHandler(); }
inline SDL_AssertionHandler GetAssertionHandler(void** puserdata) { return SDL::raw::GetAssertionHandler(puserdata); }
inline const SDL_AssertData* GetAssertionReport() { return SDL::raw::GetAssertionReport(); }
inline void ResetAssertionReport() { SDL::raw::ResetAssertionReport(); }
inline SDL_AsyncIO* AsyncIOFromFile(std::string& file, std::string& mode) { return SDL::raw::AsyncIOFromFile(file.c_str(), mode.c_str()); }
inline Sint64 GetAsyncIOSize(SDL_AsyncIO* asyncio) { return SDL::raw::GetAsyncIOSize(asyncio); }
inline void ReadAsyncIO(SDL_AsyncIO* asyncio, void* ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue* queue, void* userdata) { SDL::raw::ReadAsyncIO(asyncio, ptr, offset, size, queue, userdata); }
inline void WriteAsyncIO(SDL_AsyncIO* asyncio, void* ptr, Uint64 offset, Uint64 size, SDL_AsyncIOQueue* queue, void* userdata) { SDL::raw::WriteAsyncIO(asyncio, ptr, offset, size, queue, userdata); }
inline void CloseAsyncIO(SDL_AsyncIO* asyncio, bool flush, SDL_AsyncIOQueue* queue, void* userdata) { SDL::raw::CloseAsyncIO(asyncio, flush, queue, userdata); }
inline SDL_AsyncIOQueue* CreateAsyncIOQueue() { return SDL::raw::CreateAsyncIOQueue(); }
inline void DestroyAsyncIOQueue(SDL_AsyncIOQueue* queue) { SDL::raw::DestroyAsyncIOQueue(queue); }
inline bool GetAsyncIOResult(SDL_AsyncIOQueue* queue, SDL_AsyncIOOutcome* outcome) { return SDL::raw::GetAsyncIOResult(queue, outcome); }
inline bool WaitAsyncIOResult(SDL_AsyncIOQueue* queue, SDL_AsyncIOOutcome* outcome, Sint32 timeoutMS) { return SDL::raw::WaitAsyncIOResult(queue, outcome, timeoutMS); }
inline void SignalAsyncIOQueue(SDL_AsyncIOQueue* queue) { SDL::raw::SignalAsyncIOQueue(queue); }
inline void LoadFileAsync(std::string& file, SDL_AsyncIOQueue* queue, void* userdata) { SDL::raw::LoadFileAsync(file.c_str(), queue, userdata); }
inline bool TryLockSpinlock(SDL_SpinLock* lock) { return SDL::raw::TryLockSpinlock(lock); }
inline void LockSpinlock(SDL_SpinLock* lock) { SDL::raw::LockSpinlock(lock); }
inline void UnlockSpinlock(SDL_SpinLock* lock) { SDL::raw::UnlockSpinlock(lock); }
inline void MemoryBarrierReleaseFunction() { SDL::raw::MemoryBarrierReleaseFunction(); }
inline void MemoryBarrierAcquireFunction() { SDL::raw::MemoryBarrierAcquireFunction(); }
inline bool CompareAndSwapAtomicInt(SDL_AtomicInt* a, int oldval, int newval) { return SDL::raw::CompareAndSwapAtomicInt(a, oldval, newval); }
inline int SetAtomicInt(SDL_AtomicInt* a, int v) { return SDL::raw::SetAtomicInt(a, v); }
inline int GetAtomicInt(SDL_AtomicInt* a) { return SDL::raw::GetAtomicInt(a); }
inline int AddAtomicInt(SDL_AtomicInt* a, int v) { return SDL::raw::AddAtomicInt(a, v); }
inline bool CompareAndSwapAtomicU32(SDL_AtomicU32* a, Uint32 oldval, Uint32 newval) { return SDL::raw::CompareAndSwapAtomicU32(a, oldval, newval); }
inline Uint32 SetAtomicU32(SDL_AtomicU32* a, Uint32 v) { return SDL::raw::SetAtomicU32(a, v); }
inline Uint32 GetAtomicU32(SDL_AtomicU32* a) { return SDL::raw::GetAtomicU32(a); }
inline bool CompareAndSwapAtomicPointer(void** a, void* oldval, void* newval) { return SDL::raw::CompareAndSwapAtomicPointer(a, oldval, newval); }
inline void* SetAtomicPointer(void** a, void* v) { return SDL::raw::SetAtomicPointer(a, v); }
inline void* GetAtomicPointer(void** a) { return SDL::raw::GetAtomicPointer(a); }
inline Uint16 Swap16(Uint16 x) { return SDL::raw::Swap16(x); }
inline Uint32 Swap32(Uint32 x) { return SDL::raw::Swap32(x); }
inline Uint64 Swap64(Uint64 x) { return SDL::raw::Swap64(x); }
inline float SwapFloat(float x) { return SDL::raw::SwapFloat(x); }
inline bool SetErrorV(std::string& fmt, va_list ap) { return SDL::raw::SetErrorV(fmt.c_str(), ap); }
inline bool OutOfMemory() { return SDL::raw::OutOfMemory(); }
inline std::string GetError() { return SDL::raw::GetError(); }
inline bool ClearError() { return SDL::raw::ClearError(); }
inline SDL_PropertiesID GetGlobalProperties() { return SDL::raw::GetGlobalProperties(); }
inline SDL_PropertiesID CreateProperties() { return SDL::raw::CreateProperties(); }
inline void CopyProperties(SDL_PropertiesID src, SDL_PropertiesID dst) { SDL::raw::CopyProperties(src, dst); }
inline void LockProperties(SDL_PropertiesID props) { SDL::raw::LockProperties(props); }
inline void UnlockProperties(SDL_PropertiesID props) { SDL::raw::UnlockProperties(props); }
inline void SetPointerPropertyWithCleanup(SDL_PropertiesID props, std::string& name, void* value, SDL_CleanupPropertyCallback cleanup, void* userdata) { SDL::raw::SetPointerPropertyWithCleanup(props, name.c_str(), value, cleanup, userdata); }
inline void SetPointerProperty(SDL_PropertiesID props, std::string& name, void* value) { SDL::raw::SetPointerProperty(props, name.c_str(), value); }
inline void SetStringProperty(SDL_PropertiesID props, std::string& name, std::string& value) { SDL::raw::SetStringProperty(props, name.c_str(), value.c_str()); }
inline void SetNumberProperty(SDL_PropertiesID props, std::string& name, Sint64 value) { SDL::raw::SetNumberProperty(props, name.c_str(), value); }
inline void SetFloatProperty(SDL_PropertiesID props, std::string& name, float value) { SDL::raw::SetFloatProperty(props, name.c_str(), value); }
inline void SetBooleanProperty(SDL_PropertiesID props, std::string& name, bool value) { SDL::raw::SetBooleanProperty(props, name.c_str(), value); }
inline bool HasProperty(SDL_PropertiesID props, std::string& name) { return SDL::raw::HasProperty(props, name.c_str()); }
inline SDL_PropertyType GetPropertyType(SDL_PropertiesID props, std::string& name) { return SDL::raw::GetPropertyType(props, name.c_str()); }
inline void* GetPointerProperty(SDL_PropertiesID props, std::string& name, void* default_value) { return SDL::raw::GetPointerProperty(props, name.c_str(), default_value); }
inline std::string GetStringProperty(SDL_PropertiesID props, std::string& name, std::string& default_value) { return SDL::raw::GetStringProperty(props, name.c_str(), default_value.c_str()); }
inline Sint64 GetNumberProperty(SDL_PropertiesID props, std::string& name, Sint64 default_value) { return SDL::raw::GetNumberProperty(props, name.c_str(), default_value); }
inline float GetFloatProperty(SDL_PropertiesID props, std::string& name, float default_value) { return SDL::raw::GetFloatProperty(props, name.c_str(), default_value); }
inline bool GetBooleanProperty(SDL_PropertiesID props, std::string& name, bool default_value) { return SDL::raw::GetBooleanProperty(props, name.c_str(), default_value); }
inline void ClearProperty(SDL_PropertiesID props, std::string& name) { SDL::raw::ClearProperty(props, name.c_str()); }
inline void EnumerateProperties(SDL_PropertiesID props, SDL_EnumeratePropertiesCallback callback, void* userdata) { SDL::raw::EnumerateProperties(props, callback, userdata); }
inline void DestroyProperties(SDL_PropertiesID props) { SDL::raw::DestroyProperties(props); }
inline SDL_Thread* CreateThreadRuntime(SDL_ThreadFunction fn, std::string& name, void* data, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread) { return SDL::raw::CreateThreadRuntime(fn, name.c_str(), data, pfnBeginThread, pfnEndThread); }
inline SDL_Thread* CreateThreadWithPropertiesRuntime(SDL_PropertiesID props, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread) { return SDL::raw::CreateThreadWithPropertiesRuntime(props, pfnBeginThread, pfnEndThread); }
inline std::string GetThreadName(SDL_Thread* thread) { return SDL::raw::GetThreadName(thread); }
inline SDL_ThreadID GetCurrentThreadID() { return SDL::raw::GetCurrentThreadID(); }
inline SDL_ThreadID GetThreadID(SDL_Thread* thread) { return SDL::raw::GetThreadID(thread); }
inline void SetCurrentThreadPriority(SDL_ThreadPriority priority) { SDL::raw::SetCurrentThreadPriority(priority); }
inline void WaitThread(SDL_Thread* thread, int* status) { SDL::raw::WaitThread(thread, status); }
inline SDL_ThreadState GetThreadState(SDL_Thread* thread) { return SDL::raw::GetThreadState(thread); }
inline void DetachThread(SDL_Thread* thread) { SDL::raw::DetachThread(thread); }
inline void* GetTLS(SDL_TLSID* id) { return SDL::raw::GetTLS(id); }
inline void SetTLS(SDL_TLSID* id, const void* value, SDL_TLSDestructorCallback destructor) { SDL::raw::SetTLS(id, value, destructor); }
inline void CleanupTLS() { SDL::raw::CleanupTLS(); }
inline SDL_Mutex* CreateMutex() { return SDL::raw::CreateMutex(); }
inline void LockMutex(SDL_Mutex* mutex) { SDL::raw::LockMutex(mutex); }
inline bool TryLockMutex(SDL_Mutex* mutex) { return SDL::raw::TryLockMutex(mutex); }
inline void UnlockMutex(SDL_Mutex* mutex) { SDL::raw::UnlockMutex(mutex); }
inline void DestroyMutex(SDL_Mutex* mutex) { SDL::raw::DestroyMutex(mutex); }
inline SDL_RWLock* CreateRWLock() { return SDL::raw::CreateRWLock(); }
inline void LockRWLockForReading(SDL_RWLock* rwlock) { SDL::raw::LockRWLockForReading(rwlock); }
inline void LockRWLockForWriting(SDL_RWLock* rwlock) { SDL::raw::LockRWLockForWriting(rwlock); }
inline bool TryLockRWLockForReading(SDL_RWLock* rwlock) { return SDL::raw::TryLockRWLockForReading(rwlock); }
inline bool TryLockRWLockForWriting(SDL_RWLock* rwlock) { return SDL::raw::TryLockRWLockForWriting(rwlock); }
inline void UnlockRWLock(SDL_RWLock* rwlock) { SDL::raw::UnlockRWLock(rwlock); }
inline void DestroyRWLock(SDL_RWLock* rwlock) { SDL::raw::DestroyRWLock(rwlock); }
inline SDL_Semaphore* CreateSemaphore(Uint32 initial_value) { return SDL::raw::CreateSemaphore(initial_value); }
inline void DestroySemaphore(SDL_Semaphore* sem) { SDL::raw::DestroySemaphore(sem); }
inline void WaitSemaphore(SDL_Semaphore* sem) { SDL::raw::WaitSemaphore(sem); }
inline bool TryWaitSemaphore(SDL_Semaphore* sem) { return SDL::raw::TryWaitSemaphore(sem); }
inline bool WaitSemaphoreTimeout(SDL_Semaphore* sem, Sint32 timeoutMS) { return SDL::raw::WaitSemaphoreTimeout(sem, timeoutMS); }
inline void SignalSemaphore(SDL_Semaphore* sem) { SDL::raw::SignalSemaphore(sem); }
inline Uint32 GetSemaphoreValue(SDL_Semaphore* sem) { return SDL::raw::GetSemaphoreValue(sem); }
inline SDL_Condition* CreateCondition() { return SDL::raw::CreateCondition(); }
inline void DestroyCondition(SDL_Condition* cond) { SDL::raw::DestroyCondition(cond); }
inline void SignalCondition(SDL_Condition* cond) { SDL::raw::SignalCondition(cond); }
inline void BroadcastCondition(SDL_Condition* cond) { SDL::raw::BroadcastCondition(cond); }
inline void WaitCondition(SDL_Condition* cond, SDL_Mutex* mutex) { SDL::raw::WaitCondition(cond, mutex); }
inline bool WaitConditionTimeout(SDL_Condition* cond, SDL_Mutex* mutex, Sint32 timeoutMS) { return SDL::raw::WaitConditionTimeout(cond, mutex, timeoutMS); }
inline bool ShouldInit(SDL_InitState* state) { return SDL::raw::ShouldInit(state); }
inline bool ShouldQuit(SDL_InitState* state) { return SDL::raw::ShouldQuit(state); }
inline void SetInitialized(SDL_InitState* state, bool initialized) { SDL::raw::SetInitialized(state, initialized); }
inline SDL_IOStream* IOFromFile(std::string& file, std::string& mode) { return SDL::raw::IOFromFile(file.c_str(), mode.c_str()); }
inline SDL_IOStream* IOFromMem(void* mem, size_t size) { return SDL::raw::IOFromMem(mem, size); }
inline SDL_IOStream* IOFromConstMem(const void* mem, size_t size) { return SDL::raw::IOFromConstMem(mem, size); }
inline SDL_IOStream* IOFromDynamicMem() { return SDL::raw::IOFromDynamicMem(); }
inline SDL_IOStream* OpenIO(const SDL_IOStreamInterface* iface, void* userdata) { return SDL::raw::OpenIO(iface, userdata); }
inline void CloseIO(SDL_IOStream* context) { SDL::raw::CloseIO(context); }
inline SDL_PropertiesID GetIOProperties(SDL_IOStream* context) { return SDL::raw::GetIOProperties(context); }
inline SDL_IOStatus GetIOStatus(SDL_IOStream* context) { return SDL::raw::GetIOStatus(context); }
inline Sint64 GetIOSize(SDL_IOStream* context) { return SDL::raw::GetIOSize(context); }
inline Sint64 SeekIO(SDL_IOStream* context, Sint64 offset, SDL_IOWhence whence) { return SDL::raw::SeekIO(context, offset, whence); }
inline Sint64 TellIO(SDL_IOStream* context) { return SDL::raw::TellIO(context); }
inline size_t ReadIO(SDL_IOStream* context, void* ptr, size_t size) { return SDL::raw::ReadIO(context, ptr, size); }
inline size_t WriteIO(SDL_IOStream* context, const void* ptr, size_t size) { return SDL::raw::WriteIO(context, ptr, size); }
inline size_t IOvprintf(SDL_IOStream* context, std::string& fmt, va_list ap) { return SDL::raw::IOvprintf(context, fmt.c_str(), ap); }
inline void FlushIO(SDL_IOStream* context) { SDL::raw::FlushIO(context); }
inline void* LoadFile_IO(SDL_IOStream* src, size_t* datasize, bool closeio) { return SDL::raw::LoadFile_IO(src, datasize, closeio); }
inline void* LoadFile(std::string& file, size_t* datasize) { return SDL::raw::LoadFile(file.c_str(), datasize); }
inline void SaveFile_IO(SDL_IOStream* src, const void* data, size_t datasize, bool closeio) { SDL::raw::SaveFile_IO(src, data, datasize, closeio); }
inline void SaveFile(std::string& file, const void* data, size_t datasize) { SDL::raw::SaveFile(file.c_str(), data, datasize); }
inline void ReadU8(SDL_IOStream* src, Uint8* value) { SDL::raw::ReadU8(src, value); }
inline void ReadS8(SDL_IOStream* src, Sint8* value) { SDL::raw::ReadS8(src, value); }
inline void ReadU16LE(SDL_IOStream* src, Uint16* value) { SDL::raw::ReadU16LE(src, value); }
inline void ReadS16LE(SDL_IOStream* src, Sint16* value) { SDL::raw::ReadS16LE(src, value); }
inline void ReadU16BE(SDL_IOStream* src, Uint16* value) { SDL::raw::ReadU16BE(src, value); }
inline void ReadS16BE(SDL_IOStream* src, Sint16* value) { SDL::raw::ReadS16BE(src, value); }
inline void ReadU32LE(SDL_IOStream* src, Uint32* value) { SDL::raw::ReadU32LE(src, value); }
inline void ReadS32LE(SDL_IOStream* src, Sint32* value) { SDL::raw::ReadS32LE(src, value); }
inline void ReadU32BE(SDL_IOStream* src, Uint32* value) { SDL::raw::ReadU32BE(src, value); }
inline void ReadS32BE(SDL_IOStream* src, Sint32* value) { SDL::raw::ReadS32BE(src, value); }
inline void ReadU64LE(SDL_IOStream* src, Uint64* value) { SDL::raw::ReadU64LE(src, value); }
inline void ReadS64LE(SDL_IOStream* src, Sint64* value) { SDL::raw::ReadS64LE(src, value); }
inline void ReadU64BE(SDL_IOStream* src, Uint64* value) { SDL::raw::ReadU64BE(src, value); }
inline void ReadS64BE(SDL_IOStream* src, Sint64* value) { SDL::raw::ReadS64BE(src, value); }
inline void WriteU8(SDL_IOStream* dst, Uint8 value) { SDL::raw::WriteU8(dst, value); }
inline void WriteS8(SDL_IOStream* dst, Sint8 value) { SDL::raw::WriteS8(dst, value); }
inline void WriteU16LE(SDL_IOStream* dst, Uint16 value) { SDL::raw::WriteU16LE(dst, value); }
inline void WriteS16LE(SDL_IOStream* dst, Sint16 value) { SDL::raw::WriteS16LE(dst, value); }
inline void WriteU16BE(SDL_IOStream* dst, Uint16 value) { SDL::raw::WriteU16BE(dst, value); }
inline void WriteS16BE(SDL_IOStream* dst, Sint16 value) { SDL::raw::WriteS16BE(dst, value); }
inline void WriteU32LE(SDL_IOStream* dst, Uint32 value) { SDL::raw::WriteU32LE(dst, value); }
inline void WriteS32LE(SDL_IOStream* dst, Sint32 value) { SDL::raw::WriteS32LE(dst, value); }
inline void WriteU32BE(SDL_IOStream* dst, Uint32 value) { SDL::raw::WriteU32BE(dst, value); }
inline void WriteS32BE(SDL_IOStream* dst, Sint32 value) { SDL::raw::WriteS32BE(dst, value); }
inline void WriteU64LE(SDL_IOStream* dst, Uint64 value) { SDL::raw::WriteU64LE(dst, value); }
inline void WriteS64LE(SDL_IOStream* dst, Sint64 value) { SDL::raw::WriteS64LE(dst, value); }
inline void WriteU64BE(SDL_IOStream* dst, Uint64 value) { SDL::raw::WriteU64BE(dst, value); }
inline void WriteS64BE(SDL_IOStream* dst, Sint64 value) { SDL::raw::WriteS64BE(dst, value); }
inline int GetNumAudioDrivers() { return SDL::raw::GetNumAudioDrivers(); }
inline std::string GetAudioDriver(int index) { return SDL::raw::GetAudioDriver(index); }
inline std::string GetCurrentAudioDriver() { return SDL::raw::GetCurrentAudioDriver(); }
inline std::vector<SDL_AudioDeviceID> GetAudioPlaybackDevices() { int _count; std::vector<SDL_AudioDeviceID> _items; auto _ret = SDL::raw::GetAudioPlaybackDevices(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::vector<SDL_AudioDeviceID> GetAudioRecordingDevices() { int _count; std::vector<SDL_AudioDeviceID> _items; auto _ret = SDL::raw::GetAudioRecordingDevices(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetAudioDeviceName(SDL_AudioDeviceID devid) { return SDL::raw::GetAudioDeviceName(devid); }
inline void GetAudioDeviceFormat(SDL_AudioDeviceID devid, SDL_AudioSpec* spec, int* sample_frames) { SDL::raw::GetAudioDeviceFormat(devid, spec, sample_frames); }
inline std::vector<int> GetAudioDeviceChannelMap(SDL_AudioDeviceID devid) { int _count; std::vector<int> _items; auto _ret = SDL::raw::GetAudioDeviceChannelMap(devid, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline SDL_AudioDeviceID OpenAudioDevice(SDL_AudioDeviceID devid, const SDL_AudioSpec* spec) { return SDL::raw::OpenAudioDevice(devid, spec); }
inline bool IsAudioDevicePhysical(SDL_AudioDeviceID devid) { return SDL::raw::IsAudioDevicePhysical(devid); }
inline bool IsAudioDevicePlayback(SDL_AudioDeviceID devid) { return SDL::raw::IsAudioDevicePlayback(devid); }
inline void PauseAudioDevice(SDL_AudioDeviceID dev) { SDL::raw::PauseAudioDevice(dev); }
inline void ResumeAudioDevice(SDL_AudioDeviceID dev) { SDL::raw::ResumeAudioDevice(dev); }
inline bool AudioDevicePaused(SDL_AudioDeviceID dev) { return SDL::raw::AudioDevicePaused(dev); }
inline float GetAudioDeviceGain(SDL_AudioDeviceID devid) { return SDL::raw::GetAudioDeviceGain(devid); }
inline void SetAudioDeviceGain(SDL_AudioDeviceID devid, float gain) { SDL::raw::SetAudioDeviceGain(devid, gain); }
inline void CloseAudioDevice(SDL_AudioDeviceID devid) { SDL::raw::CloseAudioDevice(devid); }
inline void BindAudioStreams(SDL_AudioDeviceID devid, SDL_AudioStream** streams, int num_streams) { SDL::raw::BindAudioStreams(devid, streams, num_streams); }
inline void BindAudioStream(SDL_AudioDeviceID devid, SDL_AudioStream* stream) { SDL::raw::BindAudioStream(devid, stream); }
inline void UnbindAudioStreams(SDL_AudioStream** streams, int num_streams) { SDL::raw::UnbindAudioStreams(streams, num_streams); }
inline void UnbindAudioStream(SDL_AudioStream* stream) { SDL::raw::UnbindAudioStream(stream); }
inline SDL_AudioDeviceID GetAudioStreamDevice(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamDevice(stream); }
inline SDL_AudioStream* CreateAudioStream(const SDL_AudioSpec* src_spec, const SDL_AudioSpec* dst_spec) { return SDL::raw::CreateAudioStream(src_spec, dst_spec); }
inline SDL_PropertiesID GetAudioStreamProperties(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamProperties(stream); }
inline void GetAudioStreamFormat(SDL_AudioStream* stream, SDL_AudioSpec* src_spec, SDL_AudioSpec* dst_spec) { SDL::raw::GetAudioStreamFormat(stream, src_spec, dst_spec); }
inline void SetAudioStreamFormat(SDL_AudioStream* stream, const SDL_AudioSpec* src_spec, const SDL_AudioSpec* dst_spec) { SDL::raw::SetAudioStreamFormat(stream, src_spec, dst_spec); }
inline float GetAudioStreamFrequencyRatio(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamFrequencyRatio(stream); }
inline void SetAudioStreamFrequencyRatio(SDL_AudioStream* stream, float ratio) { SDL::raw::SetAudioStreamFrequencyRatio(stream, ratio); }
inline float GetAudioStreamGain(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamGain(stream); }
inline void SetAudioStreamGain(SDL_AudioStream* stream, float gain) { SDL::raw::SetAudioStreamGain(stream, gain); }
inline std::vector<int> GetAudioStreamInputChannelMap(SDL_AudioStream* stream) { int _count; std::vector<int> _items; auto _ret = SDL::raw::GetAudioStreamInputChannelMap(stream, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::vector<int> GetAudioStreamOutputChannelMap(SDL_AudioStream* stream) { int _count; std::vector<int> _items; auto _ret = SDL::raw::GetAudioStreamOutputChannelMap(stream, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline void SetAudioStreamInputChannelMap(SDL_AudioStream* stream, const int* chmap, int count) { SDL::raw::SetAudioStreamInputChannelMap(stream, chmap, count); }
inline void SetAudioStreamOutputChannelMap(SDL_AudioStream* stream, const int* chmap, int count) { SDL::raw::SetAudioStreamOutputChannelMap(stream, chmap, count); }
inline void PutAudioStreamData(SDL_AudioStream* stream, const void* buf, int len) { SDL::raw::PutAudioStreamData(stream, buf, len); }
inline int GetAudioStreamData(SDL_AudioStream* stream, void* buf, int len) { return SDL::raw::GetAudioStreamData(stream, buf, len); }
inline int GetAudioStreamAvailable(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamAvailable(stream); }
inline int GetAudioStreamQueued(SDL_AudioStream* stream) { return SDL::raw::GetAudioStreamQueued(stream); }
inline void FlushAudioStream(SDL_AudioStream* stream) { SDL::raw::FlushAudioStream(stream); }
inline void ClearAudioStream(SDL_AudioStream* stream) { SDL::raw::ClearAudioStream(stream); }
inline void PauseAudioStreamDevice(SDL_AudioStream* stream) { SDL::raw::PauseAudioStreamDevice(stream); }
inline void ResumeAudioStreamDevice(SDL_AudioStream* stream) { SDL::raw::ResumeAudioStreamDevice(stream); }
inline bool AudioStreamDevicePaused(SDL_AudioStream* stream) { return SDL::raw::AudioStreamDevicePaused(stream); }
inline void LockAudioStream(SDL_AudioStream* stream) { SDL::raw::LockAudioStream(stream); }
inline void UnlockAudioStream(SDL_AudioStream* stream) { SDL::raw::UnlockAudioStream(stream); }
inline void SetAudioStreamGetCallback(SDL_AudioStream* stream, SDL_AudioStreamCallback callback, void* userdata) { SDL::raw::SetAudioStreamGetCallback(stream, callback, userdata); }
inline void SetAudioStreamPutCallback(SDL_AudioStream* stream, SDL_AudioStreamCallback callback, void* userdata) { SDL::raw::SetAudioStreamPutCallback(stream, callback, userdata); }
inline void DestroyAudioStream(SDL_AudioStream* stream) { SDL::raw::DestroyAudioStream(stream); }
inline SDL_AudioStream* OpenAudioDeviceStream(SDL_AudioDeviceID devid, const SDL_AudioSpec* spec, SDL_AudioStreamCallback callback, void* userdata) { return SDL::raw::OpenAudioDeviceStream(devid, spec, callback, userdata); }
inline void SetAudioPostmixCallback(SDL_AudioDeviceID devid, SDL_AudioPostmixCallback callback, void* userdata) { SDL::raw::SetAudioPostmixCallback(devid, callback, userdata); }
inline void LoadWAV_IO(SDL_IOStream* src, bool closeio, SDL_AudioSpec* spec, Uint8** audio_buf, Uint32* audio_len) { SDL::raw::LoadWAV_IO(src, closeio, spec, audio_buf, audio_len); }
inline void LoadWAV(std::string& path, SDL_AudioSpec* spec, Uint8** audio_buf, Uint32* audio_len) { SDL::raw::LoadWAV(path.c_str(), spec, audio_buf, audio_len); }
inline void MixAudio(Uint8* dst, const Uint8* src, SDL_AudioFormat format, Uint32 len, float volume) { SDL::raw::MixAudio(dst, src, format, len, volume); }
inline void ConvertAudioSamples(const SDL_AudioSpec* src_spec, const Uint8* src_data, int src_len, const SDL_AudioSpec* dst_spec, Uint8** dst_data, int* dst_len) { SDL::raw::ConvertAudioSamples(src_spec, src_data, src_len, dst_spec, dst_data, dst_len); }
inline std::string GetAudioFormatName(SDL_AudioFormat format) { return SDL::raw::GetAudioFormatName(format); }
inline int GetSilenceValueForFormat(SDL_AudioFormat format) { return SDL::raw::GetSilenceValueForFormat(format); }
inline int MostSignificantBitIndex32(Uint32 x) { return SDL::raw::MostSignificantBitIndex32(x); }
inline bool HasExactlyOneBitSet32(Uint32 x) { return SDL::raw::HasExactlyOneBitSet32(x); }
inline SDL_BlendMode ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation) { return SDL::raw::ComposeCustomBlendMode(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation); }
inline std::string GetPixelFormatName(SDL_PixelFormat format) { return SDL::raw::GetPixelFormatName(format); }
inline void GetMasksForPixelFormat(SDL_PixelFormat format, int* bpp, Uint32* Rmask, Uint32* Gmask, Uint32* Bmask, Uint32* Amask) { SDL::raw::GetMasksForPixelFormat(format, bpp, Rmask, Gmask, Bmask, Amask); }
inline SDL_PixelFormat GetPixelFormatForMasks(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask) { return SDL::raw::GetPixelFormatForMasks(bpp, Rmask, Gmask, Bmask, Amask); }
inline const SDL_PixelFormatDetails* GetPixelFormatDetails(SDL_PixelFormat format) { return SDL::raw::GetPixelFormatDetails(format); }
inline std::shared_ptr<SDL::Palette> CreatePalette(int ncolors) { return SDL::Palette::get(SDL::raw::CreatePalette(ncolors)); }
inline void DestroyPalette(std::shared_ptr<SDL::Palette> palette) { SDL::raw::DestroyPalette(palette->get()); }
inline Uint32 MapRGB(const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8 r, Uint8 g, Uint8 b) { return SDL::raw::MapRGB(format, palette, r, g, b); }
inline Uint32 MapRGBA(const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8 r, Uint8 g, Uint8 b, Uint8 a) { return SDL::raw::MapRGBA(format, palette, r, g, b, a); }
inline void GetRGB(Uint32 pixel, const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8* r, Uint8* g, Uint8* b) { SDL::raw::GetRGB(pixel, format, palette, r, g, b); }
inline void GetRGBA(Uint32 pixel, const SDL_PixelFormatDetails* format, const SDL_Palette* palette, Uint8* r, Uint8* g, Uint8* b, Uint8* a) { SDL::raw::GetRGBA(pixel, format, palette, r, g, b, a); }
inline void RectToFRect(const SDL::Rect& rect, SDL::FRect& frect) { SDL::raw::RectToFRect(&rect, &frect); }
inline bool PointInRect(const SDL::Point& p, const SDL::Rect& r) { return SDL::raw::PointInRect(&p, &r); }
inline bool RectEmpty(const SDL::Rect& r) { return SDL::raw::RectEmpty(&r); }
inline bool RectsEqual(const SDL::Rect& a, const SDL::Rect& b) { return SDL::raw::RectsEqual(&a, &b); }
inline bool HasRectIntersection(const SDL::Rect& A, const SDL::Rect& B) { return SDL::raw::HasRectIntersection(&A, &B); }
inline bool GetRectIntersection(const SDL::Rect& A, const SDL::Rect& B, SDL::Rect& result) { return SDL::raw::GetRectIntersection(&A, &B, &result); }
inline void GetRectUnion(const SDL::Rect& A, const SDL::Rect& B, SDL::Rect& result) { SDL::raw::GetRectUnion(&A, &B, &result); }
inline bool GetRectEnclosingPoints(const SDL::Point& points, int count, const SDL::Rect& clip, SDL::Rect& result) { return SDL::raw::GetRectEnclosingPoints(&points, count, &clip, &result); }
inline bool GetRectAndLineIntersection(const SDL::Rect& rect, int* X1, int* Y1, int* X2, int* Y2) { return SDL::raw::GetRectAndLineIntersection(&rect, X1, Y1, X2, Y2); }
inline bool PointInRectFloat(const SDL::FPoint& p, const SDL::FRect& r) { return SDL::raw::PointInRectFloat(&p, &r); }
inline bool RectEmptyFloat(const SDL::FRect& r) { return SDL::raw::RectEmptyFloat(&r); }
inline bool RectsEqualEpsilon(const SDL::FRect& a, const SDL::FRect& b, const float epsilon) { return SDL::raw::RectsEqualEpsilon(&a, &b, epsilon); }
inline bool RectsEqualFloat(const SDL::FRect& a, const SDL::FRect& b) { return SDL::raw::RectsEqualFloat(&a, &b); }
inline bool HasRectIntersectionFloat(const SDL::FRect& A, const SDL::FRect& B) { return SDL::raw::HasRectIntersectionFloat(&A, &B); }
inline bool GetRectIntersectionFloat(const SDL::FRect& A, const SDL::FRect& B, SDL::FRect& result) { return SDL::raw::GetRectIntersectionFloat(&A, &B, &result); }
inline void GetRectUnionFloat(const SDL::FRect& A, const SDL::FRect& B, SDL::FRect& result) { SDL::raw::GetRectUnionFloat(&A, &B, &result); }
inline bool GetRectEnclosingPointsFloat(const SDL::FPoint& points, int count, const SDL::FRect& clip, SDL::FRect& result) { return SDL::raw::GetRectEnclosingPointsFloat(&points, count, &clip, &result); }
inline bool GetRectAndLineIntersectionFloat(const SDL::FRect& rect, float* X1, float* Y1, float* X2, float* Y2) { return SDL::raw::GetRectAndLineIntersectionFloat(&rect, X1, Y1, X2, Y2); }
inline std::shared_ptr<SDL::Surface> CreateSurface(int width, int height, SDL_PixelFormat format) { return SDL::Surface::get(SDL::raw::CreateSurface(width, height, format)); }
inline std::shared_ptr<SDL::Surface> CreateSurfaceFrom(int width, int height, SDL_PixelFormat format, void* pixels, int pitch) { return SDL::Surface::get(SDL::raw::CreateSurfaceFrom(width, height, format, pixels, pitch)); }
inline void DestroySurface(std::shared_ptr<SDL::Surface> surface) { SDL::raw::DestroySurface(surface->get()); }
inline std::shared_ptr<SDL::Surface> LoadBMP_IO(SDL_IOStream* src, bool closeio) { return SDL::Surface::get(SDL::raw::LoadBMP_IO(src, closeio)); }
inline std::shared_ptr<SDL::Surface> LoadBMP(std::string& file) { return SDL::Surface::get(SDL::raw::LoadBMP(file.c_str())); }
inline void ConvertPixels(int width, int height, SDL_PixelFormat src_format, const void* src, int src_pitch, SDL_PixelFormat dst_format, void* dst, int dst_pitch) { SDL::raw::ConvertPixels(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch); }
inline void ConvertPixelsAndColorspace(int width, int height, SDL_PixelFormat src_format, SDL_Colorspace src_colorspace, SDL_PropertiesID src_properties, const void* src, int src_pitch, SDL_PixelFormat dst_format, SDL_Colorspace dst_colorspace, SDL_PropertiesID dst_properties, void* dst, int dst_pitch) { SDL::raw::ConvertPixelsAndColorspace(width, height, src_format, src_colorspace, src_properties, src, src_pitch, dst_format, dst_colorspace, dst_properties, dst, dst_pitch); }
inline void PremultiplyAlpha(int width, int height, SDL_PixelFormat src_format, const void* src, int src_pitch, SDL_PixelFormat dst_format, void* dst, int dst_pitch, bool linear) { SDL::raw::PremultiplyAlpha(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch, linear); }
inline int GetNumCameraDrivers() { return SDL::raw::GetNumCameraDrivers(); }
inline std::string GetCameraDriver(int index) { return SDL::raw::GetCameraDriver(index); }
inline std::string GetCurrentCameraDriver() { return SDL::raw::GetCurrentCameraDriver(); }
inline std::vector<SDL_CameraID> GetCameras() { int _count; std::vector<SDL_CameraID> _items; auto _ret = SDL::raw::GetCameras(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::vector<SDL_CameraSpec*> GetCameraSupportedFormats(SDL_CameraID devid) { int _count; std::vector<SDL_CameraSpec*> _items; auto _ret = SDL::raw::GetCameraSupportedFormats(devid, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetCameraName(SDL_CameraID instance_id) { return SDL::raw::GetCameraName(instance_id); }
inline SDL_CameraPosition GetCameraPosition(SDL_CameraID instance_id) { return SDL::raw::GetCameraPosition(instance_id); }
inline SDL_Camera* OpenCamera(SDL_CameraID instance_id, const SDL_CameraSpec* spec) { return SDL::raw::OpenCamera(instance_id, spec); }
inline int GetCameraPermissionState(SDL_Camera* camera) { return SDL::raw::GetCameraPermissionState(camera); }
inline SDL_CameraID GetCameraID(SDL_Camera* camera) { return SDL::raw::GetCameraID(camera); }
inline SDL_PropertiesID GetCameraProperties(SDL_Camera* camera) { return SDL::raw::GetCameraProperties(camera); }
inline void GetCameraFormat(SDL_Camera* camera, SDL_CameraSpec* spec) { SDL::raw::GetCameraFormat(camera, spec); }
inline std::shared_ptr<SDL::Surface> AcquireCameraFrame(SDL_Camera* camera, Uint64* timestampNS) { return SDL::Surface::get(SDL::raw::AcquireCameraFrame(camera, timestampNS)); }
inline void ReleaseCameraFrame(SDL_Camera* camera, std::shared_ptr<SDL::Surface> frame) { SDL::raw::ReleaseCameraFrame(camera, frame->get()); }
inline void CloseCamera(SDL_Camera* camera) { SDL::raw::CloseCamera(camera); }
inline void SetClipboardText(std::string& text) { SDL::raw::SetClipboardText(text.c_str()); }
inline std::string GetClipboardText() { return SDL::raw::GetClipboardText(); }
inline bool HasClipboardText() { return SDL::raw::HasClipboardText(); }
inline void SetPrimarySelectionText(std::string& text) { SDL::raw::SetPrimarySelectionText(text.c_str()); }
inline std::string GetPrimarySelectionText() { return SDL::raw::GetPrimarySelectionText(); }
inline bool HasPrimarySelectionText() { return SDL::raw::HasPrimarySelectionText(); }
inline void SetClipboardData(SDL_ClipboardDataCallback callback, SDL_ClipboardCleanupCallback cleanup, void* userdata, std::string& mime_types, size_t num_mime_types) { SDL::raw::SetClipboardData(callback, cleanup, userdata, mime_types, num_mime_types); }
inline void ClearClipboardData() { SDL::raw::ClearClipboardData(); }
inline void* GetClipboardData(std::string& mime_type, size_t* size) { return SDL::raw::GetClipboardData(mime_type.c_str(), size); }
inline bool HasClipboardData(std::string& mime_type) { return SDL::raw::HasClipboardData(mime_type.c_str()); }
inline std::string GetClipboardMimeTypes(size_t* num_mime_types) { return SDL::raw::GetClipboardMimeTypes(num_mime_types); }
inline int GetNumLogicalCPUCores() { return SDL::raw::GetNumLogicalCPUCores(); }
inline int GetCPUCacheLineSize() { return SDL::raw::GetCPUCacheLineSize(); }
inline bool HasAltiVec() { return SDL::raw::HasAltiVec(); }
inline bool HasMMX() { return SDL::raw::HasMMX(); }
inline bool HasSSE() { return SDL::raw::HasSSE(); }
inline bool HasSSE2() { return SDL::raw::HasSSE2(); }
inline bool HasSSE3() { return SDL::raw::HasSSE3(); }
inline bool HasSSE41() { return SDL::raw::HasSSE41(); }
inline bool HasSSE42() { return SDL::raw::HasSSE42(); }
inline bool HasAVX() { return SDL::raw::HasAVX(); }
inline bool HasAVX2() { return SDL::raw::HasAVX2(); }
inline bool HasAVX512F() { return SDL::raw::HasAVX512F(); }
inline bool HasARMSIMD() { return SDL::raw::HasARMSIMD(); }
inline bool HasNEON() { return SDL::raw::HasNEON(); }
inline bool HasLSX() { return SDL::raw::HasLSX(); }
inline bool HasLASX() { return SDL::raw::HasLASX(); }
inline int GetSystemRAM() { return SDL::raw::GetSystemRAM(); }
inline size_t GetSIMDAlignment() { return SDL::raw::GetSIMDAlignment(); }
inline int GetNumVideoDrivers() { return SDL::raw::GetNumVideoDrivers(); }
inline std::string GetVideoDriver(int index) { return SDL::raw::GetVideoDriver(index); }
inline std::string GetCurrentVideoDriver() { return SDL::raw::GetCurrentVideoDriver(); }
inline SDL_SystemTheme GetSystemTheme() { return SDL::raw::GetSystemTheme(); }
inline std::vector<SDL_DisplayID> GetDisplays() { int _count; std::vector<SDL_DisplayID> _items; auto _ret = SDL::raw::GetDisplays(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline SDL_DisplayID GetPrimaryDisplay() { return SDL::raw::GetPrimaryDisplay(); }
inline SDL_PropertiesID GetDisplayProperties(SDL_DisplayID displayID) { return SDL::raw::GetDisplayProperties(displayID); }
inline std::string GetDisplayName(SDL_DisplayID displayID) { return SDL::raw::GetDisplayName(displayID); }
inline SDL::Rect GetDisplayBounds(SDL_DisplayID displayID) { SDL_Rect _out; SDL::raw::GetDisplayBounds(displayID, &_out); return _out; }
inline SDL::Rect GetDisplayUsableBounds(SDL_DisplayID displayID) { SDL_Rect _out; SDL::raw::GetDisplayUsableBounds(displayID, &_out); return _out; }
inline SDL_DisplayOrientation GetNaturalDisplayOrientation(SDL_DisplayID displayID) { return SDL::raw::GetNaturalDisplayOrientation(displayID); }
inline SDL_DisplayOrientation GetCurrentDisplayOrientation(SDL_DisplayID displayID) { return SDL::raw::GetCurrentDisplayOrientation(displayID); }
inline float GetDisplayContentScale(SDL_DisplayID displayID) { return SDL::raw::GetDisplayContentScale(displayID); }
inline std::vector<SDL_DisplayMode*> GetFullscreenDisplayModes(SDL_DisplayID displayID) { int _count; std::vector<SDL_DisplayMode*> _items; auto _ret = SDL::raw::GetFullscreenDisplayModes(displayID, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline SDL_DisplayMode GetClosestFullscreenDisplayMode(SDL_DisplayID displayID, int w, int h, float refresh_rate, bool include_high_density_modes) { SDL_DisplayMode _out; SDL::raw::GetClosestFullscreenDisplayMode(displayID, w, h, refresh_rate, include_high_density_modes, &_out); return _out; }
inline const SDL_DisplayMode* GetDesktopDisplayMode(SDL_DisplayID displayID) { return SDL::raw::GetDesktopDisplayMode(displayID); }
inline const SDL_DisplayMode* GetCurrentDisplayMode(SDL_DisplayID displayID) { return SDL::raw::GetCurrentDisplayMode(displayID); }
inline SDL_DisplayID GetDisplayForPoint(const SDL::Point& point) { return SDL::raw::GetDisplayForPoint(&point); }
inline SDL_DisplayID GetDisplayForRect(const SDL::Rect& rect) { return SDL::raw::GetDisplayForRect(&rect); }
inline std::vector<std::shared_ptr<SDL::Window>> GetWindows() { int _count; std::vector<std::shared_ptr<SDL::Window>> _items; auto _ret = SDL::raw::GetWindows(&_count); for (int i = 0; i < _count; i++) _items.push_back(SDL::Window::get(_ret[i])); return _items; }
inline std::shared_ptr<SDL::Window> CreateWindow(std::string& title, int w, int h, SDL::WindowFlags flags) { return SDL::Window::get(SDL::raw::CreateWindow(title.c_str(), w, h, flags)); }
inline std::shared_ptr<SDL::Window> CreateWindowWithProperties(SDL_PropertiesID props) { return SDL::Window::get(SDL::raw::CreateWindowWithProperties(props)); }
inline std::shared_ptr<SDL::Window> GetWindowFromID(SDL_WindowID id) { return SDL::Window::get(SDL::raw::GetWindowFromID(id)); }
inline std::shared_ptr<SDL::Window> GetGrabbedWindow() { return SDL::Window::get(SDL::raw::GetGrabbedWindow()); }
inline void DestroyWindow(std::shared_ptr<SDL::Window> window) { SDL::raw::DestroyWindow(window->get()); }
inline bool ScreenSaverEnabled() { return SDL::raw::ScreenSaverEnabled(); }
inline void EnableScreenSaver() { SDL::raw::EnableScreenSaver(); }
inline void DisableScreenSaver() { SDL::raw::DisableScreenSaver(); }
inline void GL_LoadLibrary(std::string& path) { SDL::raw::GL_LoadLibrary(path.c_str()); }
inline SDL_FunctionPointer GL_GetProcAddress(std::string& proc) { return SDL::raw::GL_GetProcAddress(proc.c_str()); }
inline SDL_FunctionPointer EGL_GetProcAddress(std::string& proc) { return SDL::raw::EGL_GetProcAddress(proc.c_str()); }
inline void GL_UnloadLibrary() { SDL::raw::GL_UnloadLibrary(); }
inline bool GL_ExtensionSupported(std::string& extension) { return SDL::raw::GL_ExtensionSupported(extension.c_str()); }
inline void GL_ResetAttributes() { SDL::raw::GL_ResetAttributes(); }
inline void GL_SetAttribute(SDL_GLAttr attr, int value) { SDL::raw::GL_SetAttribute(attr, value); }
inline void GL_GetAttribute(SDL_GLAttr attr, int* value) { SDL::raw::GL_GetAttribute(attr, value); }
inline std::shared_ptr<SDL::Window> GL_GetCurrentWindow() { return SDL::Window::get(SDL::raw::GL_GetCurrentWindow()); }
inline SDL_GLContext GL_GetCurrentContext() { return SDL::raw::GL_GetCurrentContext(); }
inline SDL_EGLDisplay EGL_GetCurrentDisplay() { return SDL::raw::EGL_GetCurrentDisplay(); }
inline SDL_EGLConfig EGL_GetCurrentConfig() { return SDL::raw::EGL_GetCurrentConfig(); }
inline void EGL_SetAttributeCallbacks(SDL_EGLAttribArrayCallback platformAttribCallback, SDL_EGLIntArrayCallback surfaceAttribCallback, SDL_EGLIntArrayCallback contextAttribCallback, void* userdata) { SDL::raw::EGL_SetAttributeCallbacks(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata); }
inline void GL_SetSwapInterval(int interval) { SDL::raw::GL_SetSwapInterval(interval); }
inline void GL_GetSwapInterval(int* interval) { SDL::raw::GL_GetSwapInterval(interval); }
inline void GL_DestroyContext(SDL_GLContext context) { SDL::raw::GL_DestroyContext(context); }
inline void ShowOpenFileDialog(SDL_DialogFileCallback callback, void* userdata, std::shared_ptr<SDL::Window> window, const SDL_DialogFileFilter* filters, int nfilters, std::string& default_location, bool allow_many) { SDL::raw::ShowOpenFileDialog(callback, userdata, window->get(), filters, nfilters, default_location.c_str(), allow_many); }
inline void ShowSaveFileDialog(SDL_DialogFileCallback callback, void* userdata, std::shared_ptr<SDL::Window> window, const SDL_DialogFileFilter* filters, int nfilters, std::string& default_location) { SDL::raw::ShowSaveFileDialog(callback, userdata, window->get(), filters, nfilters, default_location.c_str()); }
inline void ShowOpenFolderDialog(SDL_DialogFileCallback callback, void* userdata, std::shared_ptr<SDL::Window> window, std::string& default_location, bool allow_many) { SDL::raw::ShowOpenFolderDialog(callback, userdata, window->get(), default_location.c_str(), allow_many); }
inline void ShowFileDialogWithProperties(SDL_FileDialogType type, SDL_DialogFileCallback callback, void* userdata, SDL_PropertiesID props) { SDL::raw::ShowFileDialogWithProperties(type, callback, userdata, props); }
inline void GUIDToString(SDL_GUID guid, std::string& pszGUID, int cbGUID) { SDL::raw::GUIDToString(guid, pszGUID.c_str(), cbGUID); }
inline SDL_GUID StringToGUID(std::string& pchGUID) { return SDL::raw::StringToGUID(pchGUID.c_str()); }
inline SDL_PowerState GetPowerInfo(int* seconds, int* percent) { return SDL::raw::GetPowerInfo(seconds, percent); }
inline std::vector<SDL_SensorID> GetSensors() { int _count; std::vector<SDL_SensorID> _items; auto _ret = SDL::raw::GetSensors(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetSensorNameForID(SDL_SensorID instance_id) { return SDL::raw::GetSensorNameForID(instance_id); }
inline SDL_SensorType GetSensorTypeForID(SDL_SensorID instance_id) { return SDL::raw::GetSensorTypeForID(instance_id); }
inline int GetSensorNonPortableTypeForID(SDL_SensorID instance_id) { return SDL::raw::GetSensorNonPortableTypeForID(instance_id); }
inline SDL_Sensor* OpenSensor(SDL_SensorID instance_id) { return SDL::raw::OpenSensor(instance_id); }
inline SDL_Sensor* GetSensorFromID(SDL_SensorID instance_id) { return SDL::raw::GetSensorFromID(instance_id); }
inline SDL_PropertiesID GetSensorProperties(SDL_Sensor* sensor) { return SDL::raw::GetSensorProperties(sensor); }
inline std::string GetSensorName(SDL_Sensor* sensor) { return SDL::raw::GetSensorName(sensor); }
inline SDL_SensorType GetSensorType(SDL_Sensor* sensor) { return SDL::raw::GetSensorType(sensor); }
inline int GetSensorNonPortableType(SDL_Sensor* sensor) { return SDL::raw::GetSensorNonPortableType(sensor); }
inline SDL_SensorID GetSensorID(SDL_Sensor* sensor) { return SDL::raw::GetSensorID(sensor); }
inline void GetSensorData(SDL_Sensor* sensor, float* data, int num_values) { SDL::raw::GetSensorData(sensor, data, num_values); }
inline void CloseSensor(SDL_Sensor* sensor) { SDL::raw::CloseSensor(sensor); }
inline void UpdateSensors() { SDL::raw::UpdateSensors(); }
inline void LockJoysticks() { SDL::raw::LockJoysticks(); }
inline void UnlockJoysticks() { SDL::raw::UnlockJoysticks(); }
inline bool HasJoystick() { return SDL::raw::HasJoystick(); }
inline std::vector<SDL_JoystickID> GetJoysticks() { int _count; std::vector<SDL_JoystickID> _items; auto _ret = SDL::raw::GetJoysticks(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetJoystickNameForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickNameForID(instance_id); }
inline std::string GetJoystickPathForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickPathForID(instance_id); }
inline int GetJoystickPlayerIndexForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickPlayerIndexForID(instance_id); }
inline SDL_GUID GetJoystickGUIDForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickGUIDForID(instance_id); }
inline Uint16 GetJoystickVendorForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickVendorForID(instance_id); }
inline Uint16 GetJoystickProductForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickProductForID(instance_id); }
inline Uint16 GetJoystickProductVersionForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickProductVersionForID(instance_id); }
inline SDL_JoystickType GetJoystickTypeForID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickTypeForID(instance_id); }
inline SDL_Joystick* OpenJoystick(SDL_JoystickID instance_id) { return SDL::raw::OpenJoystick(instance_id); }
inline SDL_Joystick* GetJoystickFromID(SDL_JoystickID instance_id) { return SDL::raw::GetJoystickFromID(instance_id); }
inline SDL_Joystick* GetJoystickFromPlayerIndex(int player_index) { return SDL::raw::GetJoystickFromPlayerIndex(player_index); }
inline SDL_JoystickID AttachVirtualJoystick(const SDL_VirtualJoystickDesc* desc) { return SDL::raw::AttachVirtualJoystick(desc); }
inline void DetachVirtualJoystick(SDL_JoystickID instance_id) { SDL::raw::DetachVirtualJoystick(instance_id); }
inline bool IsJoystickVirtual(SDL_JoystickID instance_id) { return SDL::raw::IsJoystickVirtual(instance_id); }
inline void SetJoystickVirtualAxis(SDL_Joystick* joystick, int axis, Sint16 value) { SDL::raw::SetJoystickVirtualAxis(joystick, axis, value); }
inline void SetJoystickVirtualBall(SDL_Joystick* joystick, int ball, Sint16 xrel, Sint16 yrel) { SDL::raw::SetJoystickVirtualBall(joystick, ball, xrel, yrel); }
inline void SetJoystickVirtualButton(SDL_Joystick* joystick, int button, bool down) { SDL::raw::SetJoystickVirtualButton(joystick, button, down); }
inline void SetJoystickVirtualHat(SDL_Joystick* joystick, int hat, Uint8 value) { SDL::raw::SetJoystickVirtualHat(joystick, hat, value); }
inline void SetJoystickVirtualTouchpad(SDL_Joystick* joystick, int touchpad, int finger, bool down, float x, float y, float pressure) { SDL::raw::SetJoystickVirtualTouchpad(joystick, touchpad, finger, down, x, y, pressure); }
inline void SendJoystickVirtualSensorData(SDL_Joystick* joystick, SDL_SensorType type, Uint64 sensor_timestamp, const float* data, int num_values) { SDL::raw::SendJoystickVirtualSensorData(joystick, type, sensor_timestamp, data, num_values); }
inline SDL_PropertiesID GetJoystickProperties(SDL_Joystick* joystick) { return SDL::raw::GetJoystickProperties(joystick); }
inline std::string GetJoystickName(SDL_Joystick* joystick) { return SDL::raw::GetJoystickName(joystick); }
inline std::string GetJoystickPath(SDL_Joystick* joystick) { return SDL::raw::GetJoystickPath(joystick); }
inline int GetJoystickPlayerIndex(SDL_Joystick* joystick) { return SDL::raw::GetJoystickPlayerIndex(joystick); }
inline void SetJoystickPlayerIndex(SDL_Joystick* joystick, int player_index) { SDL::raw::SetJoystickPlayerIndex(joystick, player_index); }
inline SDL_GUID GetJoystickGUID(SDL_Joystick* joystick) { return SDL::raw::GetJoystickGUID(joystick); }
inline Uint16 GetJoystickVendor(SDL_Joystick* joystick) { return SDL::raw::GetJoystickVendor(joystick); }
inline Uint16 GetJoystickProduct(SDL_Joystick* joystick) { return SDL::raw::GetJoystickProduct(joystick); }
inline Uint16 GetJoystickProductVersion(SDL_Joystick* joystick) { return SDL::raw::GetJoystickProductVersion(joystick); }
inline Uint16 GetJoystickFirmwareVersion(SDL_Joystick* joystick) { return SDL::raw::GetJoystickFirmwareVersion(joystick); }
inline std::string GetJoystickSerial(SDL_Joystick* joystick) { return SDL::raw::GetJoystickSerial(joystick); }
inline SDL_JoystickType GetJoystickType(SDL_Joystick* joystick) { return SDL::raw::GetJoystickType(joystick); }
inline void GetJoystickGUIDInfo(SDL_GUID guid, Uint16* vendor, Uint16* product, Uint16* version, Uint16* crc16) { SDL::raw::GetJoystickGUIDInfo(guid, vendor, product, version, crc16); }
inline void JoystickConnected(SDL_Joystick* joystick) { SDL::raw::JoystickConnected(joystick); }
inline SDL_JoystickID GetJoystickID(SDL_Joystick* joystick) { return SDL::raw::GetJoystickID(joystick); }
inline int GetNumJoystickAxes(SDL_Joystick* joystick) { return SDL::raw::GetNumJoystickAxes(joystick); }
inline int GetNumJoystickBalls(SDL_Joystick* joystick) { return SDL::raw::GetNumJoystickBalls(joystick); }
inline int GetNumJoystickHats(SDL_Joystick* joystick) { return SDL::raw::GetNumJoystickHats(joystick); }
inline int GetNumJoystickButtons(SDL_Joystick* joystick) { return SDL::raw::GetNumJoystickButtons(joystick); }
inline void SetJoystickEventsEnabled(bool enabled) { SDL::raw::SetJoystickEventsEnabled(enabled); }
inline bool JoystickEventsEnabled() { return SDL::raw::JoystickEventsEnabled(); }
inline void UpdateJoysticks() { SDL::raw::UpdateJoysticks(); }
inline Sint16 GetJoystickAxis(SDL_Joystick* joystick, int axis) { return SDL::raw::GetJoystickAxis(joystick, axis); }
inline bool GetJoystickAxisInitialState(SDL_Joystick* joystick, int axis, Sint16* state) { return SDL::raw::GetJoystickAxisInitialState(joystick, axis, state); }
inline void GetJoystickBall(SDL_Joystick* joystick, int ball, int* dx, int* dy) { SDL::raw::GetJoystickBall(joystick, ball, dx, dy); }
inline Uint8 GetJoystickHat(SDL_Joystick* joystick, int hat) { return SDL::raw::GetJoystickHat(joystick, hat); }
inline bool GetJoystickButton(SDL_Joystick* joystick, int button) { return SDL::raw::GetJoystickButton(joystick, button); }
inline bool RumbleJoystick(SDL_Joystick* joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms) { return SDL::raw::RumbleJoystick(joystick, low_frequency_rumble, high_frequency_rumble, duration_ms); }
inline void RumbleJoystickTriggers(SDL_Joystick* joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms) { SDL::raw::RumbleJoystickTriggers(joystick, left_rumble, right_rumble, duration_ms); }
inline void SetJoystickLED(SDL_Joystick* joystick, Uint8 red, Uint8 green, Uint8 blue) { SDL::raw::SetJoystickLED(joystick, red, green, blue); }
inline void SendJoystickEffect(SDL_Joystick* joystick, const void* data, int size) { SDL::raw::SendJoystickEffect(joystick, data, size); }
inline void CloseJoystick(SDL_Joystick* joystick) { SDL::raw::CloseJoystick(joystick); }
inline SDL_JoystickConnectionState GetJoystickConnectionState(SDL_Joystick* joystick) { return SDL::raw::GetJoystickConnectionState(joystick); }
inline SDL_PowerState GetJoystickPowerInfo(SDL_Joystick* joystick, int* percent) { return SDL::raw::GetJoystickPowerInfo(joystick, percent); }
inline int AddGamepadMapping(std::string& mapping) { return SDL::raw::AddGamepadMapping(mapping.c_str()); }
inline int AddGamepadMappingsFromIO(SDL_IOStream* src, bool closeio) { return SDL::raw::AddGamepadMappingsFromIO(src, closeio); }
inline int AddGamepadMappingsFromFile(std::string& file) { return SDL::raw::AddGamepadMappingsFromFile(file.c_str()); }
inline void ReloadGamepadMappings() { SDL::raw::ReloadGamepadMappings(); }
inline std::vector<std::string> GetGamepadMappings() { int _count; std::vector<std::string> _items; auto _ret = SDL::raw::GetGamepadMappings(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetGamepadMappingForGUID(SDL_GUID guid) { return SDL::raw::GetGamepadMappingForGUID(guid); }
inline std::string GetGamepadMapping(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadMapping(gamepad); }
inline void SetGamepadMapping(SDL_JoystickID instance_id, std::string& mapping) { SDL::raw::SetGamepadMapping(instance_id, mapping.c_str()); }
inline bool HasGamepad() { return SDL::raw::HasGamepad(); }
inline std::vector<SDL_JoystickID> GetGamepads() { int _count; std::vector<SDL_JoystickID> _items; auto _ret = SDL::raw::GetGamepads(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline bool IsGamepad(SDL_JoystickID instance_id) { return SDL::raw::IsGamepad(instance_id); }
inline std::string GetGamepadNameForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadNameForID(instance_id); }
inline std::string GetGamepadPathForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadPathForID(instance_id); }
inline int GetGamepadPlayerIndexForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadPlayerIndexForID(instance_id); }
inline SDL_GUID GetGamepadGUIDForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadGUIDForID(instance_id); }
inline Uint16 GetGamepadVendorForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadVendorForID(instance_id); }
inline Uint16 GetGamepadProductForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadProductForID(instance_id); }
inline Uint16 GetGamepadProductVersionForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadProductVersionForID(instance_id); }
inline SDL_GamepadType GetGamepadTypeForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadTypeForID(instance_id); }
inline SDL_GamepadType GetRealGamepadTypeForID(SDL_JoystickID instance_id) { return SDL::raw::GetRealGamepadTypeForID(instance_id); }
inline std::string GetGamepadMappingForID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadMappingForID(instance_id); }
inline SDL_Gamepad* OpenGamepad(SDL_JoystickID instance_id) { return SDL::raw::OpenGamepad(instance_id); }
inline SDL_Gamepad* GetGamepadFromID(SDL_JoystickID instance_id) { return SDL::raw::GetGamepadFromID(instance_id); }
inline SDL_Gamepad* GetGamepadFromPlayerIndex(int player_index) { return SDL::raw::GetGamepadFromPlayerIndex(player_index); }
inline SDL_PropertiesID GetGamepadProperties(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadProperties(gamepad); }
inline SDL_JoystickID GetGamepadID(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadID(gamepad); }
inline std::string GetGamepadName(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadName(gamepad); }
inline std::string GetGamepadPath(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadPath(gamepad); }
inline SDL_GamepadType GetGamepadType(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadType(gamepad); }
inline SDL_GamepadType GetRealGamepadType(SDL_Gamepad* gamepad) { return SDL::raw::GetRealGamepadType(gamepad); }
inline int GetGamepadPlayerIndex(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadPlayerIndex(gamepad); }
inline void SetGamepadPlayerIndex(SDL_Gamepad* gamepad, int player_index) { SDL::raw::SetGamepadPlayerIndex(gamepad, player_index); }
inline Uint16 GetGamepadVendor(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadVendor(gamepad); }
inline Uint16 GetGamepadProduct(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadProduct(gamepad); }
inline Uint16 GetGamepadProductVersion(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadProductVersion(gamepad); }
inline Uint16 GetGamepadFirmwareVersion(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadFirmwareVersion(gamepad); }
inline std::string GetGamepadSerial(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadSerial(gamepad); }
inline Uint64 GetGamepadSteamHandle(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadSteamHandle(gamepad); }
inline SDL_JoystickConnectionState GetGamepadConnectionState(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadConnectionState(gamepad); }
inline SDL_PowerState GetGamepadPowerInfo(SDL_Gamepad* gamepad, int* percent) { return SDL::raw::GetGamepadPowerInfo(gamepad, percent); }
inline bool GamepadConnected(SDL_Gamepad* gamepad) { return SDL::raw::GamepadConnected(gamepad); }
inline SDL_Joystick* GetGamepadJoystick(SDL_Gamepad* gamepad) { return SDL::raw::GetGamepadJoystick(gamepad); }
inline void SetGamepadEventsEnabled(bool enabled) { SDL::raw::SetGamepadEventsEnabled(enabled); }
inline bool GamepadEventsEnabled() { return SDL::raw::GamepadEventsEnabled(); }
inline std::vector<SDL_GamepadBinding*> GetGamepadBindings(SDL_Gamepad* gamepad) { int _count; std::vector<SDL_GamepadBinding*> _items; auto _ret = SDL::raw::GetGamepadBindings(gamepad, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline void UpdateGamepads() { SDL::raw::UpdateGamepads(); }
inline SDL_GamepadType GetGamepadTypeFromString(std::string& str) { return SDL::raw::GetGamepadTypeFromString(str.c_str()); }
inline std::string GetGamepadStringForType(SDL_GamepadType type) { return SDL::raw::GetGamepadStringForType(type); }
inline SDL_GamepadAxis GetGamepadAxisFromString(std::string& str) { return SDL::raw::GetGamepadAxisFromString(str.c_str()); }
inline std::string GetGamepadStringForAxis(SDL_GamepadAxis axis) { return SDL::raw::GetGamepadStringForAxis(axis); }
inline bool GamepadHasAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { return SDL::raw::GamepadHasAxis(gamepad, axis); }
inline Sint16 GetGamepadAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { return SDL::raw::GetGamepadAxis(gamepad, axis); }
inline SDL_GamepadButton GetGamepadButtonFromString(std::string& str) { return SDL::raw::GetGamepadButtonFromString(str.c_str()); }
inline std::string GetGamepadStringForButton(SDL_GamepadButton button) { return SDL::raw::GetGamepadStringForButton(button); }
inline bool GamepadHasButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL::raw::GamepadHasButton(gamepad, button); }
inline bool GetGamepadButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL::raw::GetGamepadButton(gamepad, button); }
inline SDL_GamepadButtonLabel GetGamepadButtonLabelForType(SDL_GamepadType type, SDL_GamepadButton button) { return SDL::raw::GetGamepadButtonLabelForType(type, button); }
inline SDL_GamepadButtonLabel GetGamepadButtonLabel(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL::raw::GetGamepadButtonLabel(gamepad, button); }
inline int GetNumGamepadTouchpads(SDL_Gamepad* gamepad) { return SDL::raw::GetNumGamepadTouchpads(gamepad); }
inline int GetNumGamepadTouchpadFingers(SDL_Gamepad* gamepad, int touchpad) { return SDL::raw::GetNumGamepadTouchpadFingers(gamepad, touchpad); }
inline void GetGamepadTouchpadFinger(SDL_Gamepad* gamepad, int touchpad, int finger, bool* down, float* x, float* y, float* pressure) { SDL::raw::GetGamepadTouchpadFinger(gamepad, touchpad, finger, down, x, y, pressure); }
inline bool GamepadHasSensor(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL::raw::GamepadHasSensor(gamepad, type); }
inline void SetGamepadSensorEnabled(SDL_Gamepad* gamepad, SDL_SensorType type, bool enabled) { SDL::raw::SetGamepadSensorEnabled(gamepad, type, enabled); }
inline bool GamepadSensorEnabled(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL::raw::GamepadSensorEnabled(gamepad, type); }
inline float GetGamepadSensorDataRate(SDL_Gamepad* gamepad, SDL_SensorType type) { return SDL::raw::GetGamepadSensorDataRate(gamepad, type); }
inline void GetGamepadSensorData(SDL_Gamepad* gamepad, SDL_SensorType type, float* data, int num_values) { SDL::raw::GetGamepadSensorData(gamepad, type, data, num_values); }
inline void RumbleGamepad(SDL_Gamepad* gamepad, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms) { SDL::raw::RumbleGamepad(gamepad, low_frequency_rumble, high_frequency_rumble, duration_ms); }
inline void RumbleGamepadTriggers(SDL_Gamepad* gamepad, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms) { SDL::raw::RumbleGamepadTriggers(gamepad, left_rumble, right_rumble, duration_ms); }
inline void SetGamepadLED(SDL_Gamepad* gamepad, Uint8 red, Uint8 green, Uint8 blue) { SDL::raw::SetGamepadLED(gamepad, red, green, blue); }
inline void SendGamepadEffect(SDL_Gamepad* gamepad, const void* data, int size) { SDL::raw::SendGamepadEffect(gamepad, data, size); }
inline void CloseGamepad(SDL_Gamepad* gamepad) { SDL::raw::CloseGamepad(gamepad); }
inline std::string GetGamepadAppleSFSymbolsNameForButton(SDL_Gamepad* gamepad, SDL_GamepadButton button) { return SDL::raw::GetGamepadAppleSFSymbolsNameForButton(gamepad, button); }
inline std::string GetGamepadAppleSFSymbolsNameForAxis(SDL_Gamepad* gamepad, SDL_GamepadAxis axis) { return SDL::raw::GetGamepadAppleSFSymbolsNameForAxis(gamepad, axis); }
inline bool HasKeyboard() { return SDL::raw::HasKeyboard(); }
inline std::vector<SDL_KeyboardID> GetKeyboards() { int _count; std::vector<SDL_KeyboardID> _items; auto _ret = SDL::raw::GetKeyboards(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetKeyboardNameForID(SDL_KeyboardID instance_id) { return SDL::raw::GetKeyboardNameForID(instance_id); }
inline std::shared_ptr<SDL::Window> GetKeyboardFocus() { return SDL::Window::get(SDL::raw::GetKeyboardFocus()); }
inline const bool* GetKeyboardState(int* numkeys) { return SDL::raw::GetKeyboardState(numkeys); }
inline void ResetKeyboard() { SDL::raw::ResetKeyboard(); }
inline SDL_Keymod GetModState() { return SDL::raw::GetModState(); }
inline void SetModState(SDL_Keymod modstate) { SDL::raw::SetModState(modstate); }
inline SDL_Keycode GetKeyFromScancode(SDL_Scancode scancode, SDL_Keymod modstate, bool key_event) { return SDL::raw::GetKeyFromScancode(scancode, modstate, key_event); }
inline SDL_Scancode GetScancodeFromKey(SDL_Keycode key, SDL_Keymod* modstate) { return SDL::raw::GetScancodeFromKey(key, modstate); }
inline void SetScancodeName(SDL_Scancode scancode, std::string& name) { SDL::raw::SetScancodeName(scancode, name.c_str()); }
inline std::string GetScancodeName(SDL_Scancode scancode) { return SDL::raw::GetScancodeName(scancode); }
inline SDL_Scancode GetScancodeFromName(std::string& name) { return SDL::raw::GetScancodeFromName(name.c_str()); }
inline std::string GetKeyName(SDL_Keycode key) { return SDL::raw::GetKeyName(key); }
inline SDL_Keycode GetKeyFromName(std::string& name) { return SDL::raw::GetKeyFromName(name.c_str()); }
inline bool HasScreenKeyboardSupport() { return SDL::raw::HasScreenKeyboardSupport(); }
inline bool HasMouse() { return SDL::raw::HasMouse(); }
inline std::vector<SDL_MouseID> GetMice() { int _count; std::vector<SDL_MouseID> _items; auto _ret = SDL::raw::GetMice(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetMouseNameForID(SDL_MouseID instance_id) { return SDL::raw::GetMouseNameForID(instance_id); }
inline std::shared_ptr<SDL::Window> GetMouseFocus() { return SDL::Window::get(SDL::raw::GetMouseFocus()); }
inline SDL_MouseButtonFlags GetMouseState(float* x, float* y) { return SDL::raw::GetMouseState(x, y); }
inline SDL_MouseButtonFlags GetGlobalMouseState(float* x, float* y) { return SDL::raw::GetGlobalMouseState(x, y); }
inline SDL_MouseButtonFlags GetRelativeMouseState(float* x, float* y) { return SDL::raw::GetRelativeMouseState(x, y); }
inline void WarpMouseGlobal(float x, float y) { SDL::raw::WarpMouseGlobal(x, y); }
inline void CaptureMouse(bool enabled) { SDL::raw::CaptureMouse(enabled); }
inline SDL_Cursor* CreateCursor(const Uint8* data, const Uint8* mask, int w, int h, int hot_x, int hot_y) { return SDL::raw::CreateCursor(data, mask, w, h, hot_x, hot_y); }
inline SDL_Cursor* CreateSystemCursor(SDL_SystemCursor id) { return SDL::raw::CreateSystemCursor(id); }
inline void SetCursor(SDL_Cursor* cursor) { SDL::raw::SetCursor(cursor); }
inline SDL_Cursor* GetCursor() { return SDL::raw::GetCursor(); }
inline SDL_Cursor* GetDefaultCursor() { return SDL::raw::GetDefaultCursor(); }
inline void DestroyCursor(SDL_Cursor* cursor) { SDL::raw::DestroyCursor(cursor); }
inline void ShowCursor() { SDL::raw::ShowCursor(); }
inline void HideCursor() { SDL::raw::HideCursor(); }
inline bool CursorVisible() { return SDL::raw::CursorVisible(); }
inline std::vector<SDL_TouchID> GetTouchDevices() { int _count; std::vector<SDL_TouchID> _items; auto _ret = SDL::raw::GetTouchDevices(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetTouchDeviceName(SDL_TouchID touchID) { return SDL::raw::GetTouchDeviceName(touchID); }
inline SDL_TouchDeviceType GetTouchDeviceType(SDL_TouchID touchID) { return SDL::raw::GetTouchDeviceType(touchID); }
inline std::vector<SDL_Finger*> GetTouchFingers(SDL_TouchID touchID) { int _count; std::vector<SDL_Finger*> _items; auto _ret = SDL::raw::GetTouchFingers(touchID, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline void PumpEvents() { SDL::raw::PumpEvents(); }
inline int PeepEvents(SDL_Event* events, int numevents, SDL_EventAction action, Uint32 minType, Uint32 maxType) { return SDL::raw::PeepEvents(events, numevents, action, minType, maxType); }
inline bool HasEvent(Uint32 type) { return SDL::raw::HasEvent(type); }
inline bool HasEvents(Uint32 minType, Uint32 maxType) { return SDL::raw::HasEvents(minType, maxType); }
inline void FlushEvent(Uint32 type) { SDL::raw::FlushEvent(type); }
inline void FlushEvents(Uint32 minType, Uint32 maxType) { SDL::raw::FlushEvents(minType, maxType); }
inline bool PollEvent(SDL_Event* event) { return SDL::raw::PollEvent(event); }
inline void WaitEvent(SDL_Event* event) { SDL::raw::WaitEvent(event); }
inline bool WaitEventTimeout(SDL_Event* event, Sint32 timeoutMS) { return SDL::raw::WaitEventTimeout(event, timeoutMS); }
inline void PushEvent(SDL_Event* event) { SDL::raw::PushEvent(event); }
inline void SetEventFilter(SDL_EventFilter filter, void* userdata) { SDL::raw::SetEventFilter(filter, userdata); }
inline bool GetEventFilter(SDL_EventFilter* filter, void** userdata) { return SDL::raw::GetEventFilter(filter, userdata); }
inline void AddEventWatch(SDL_EventFilter filter, void* userdata) { SDL::raw::AddEventWatch(filter, userdata); }
inline void RemoveEventWatch(SDL_EventFilter filter, void* userdata) { SDL::raw::RemoveEventWatch(filter, userdata); }
inline void FilterEvents(SDL_EventFilter filter, void* userdata) { SDL::raw::FilterEvents(filter, userdata); }
inline void SetEventEnabled(Uint32 type, bool enabled) { SDL::raw::SetEventEnabled(type, enabled); }
inline bool EventEnabled(Uint32 type) { return SDL::raw::EventEnabled(type); }
inline Uint32 RegisterEvents(int numevents) { return SDL::raw::RegisterEvents(numevents); }
inline std::shared_ptr<SDL::Window> GetWindowFromEvent(const SDL_Event* event) { return SDL::Window::get(SDL::raw::GetWindowFromEvent(event)); }
inline std::string GetBasePath() { return SDL::raw::GetBasePath(); }
inline std::string GetPrefPath(std::string& org, std::string& app) { return SDL::raw::GetPrefPath(org.c_str(), app.c_str()); }
inline std::string GetUserFolder(SDL_Folder folder) { return SDL::raw::GetUserFolder(folder); }
inline void CreateDirectory(std::string& path) { SDL::raw::CreateDirectory(path.c_str()); }
inline void EnumerateDirectory(std::string& path, SDL_EnumerateDirectoryCallback callback, void* userdata) { SDL::raw::EnumerateDirectory(path.c_str(), callback, userdata); }
inline void RemovePath(std::string& path) { SDL::raw::RemovePath(path.c_str()); }
inline void RenamePath(std::string& oldpath, std::string& newpath) { SDL::raw::RenamePath(oldpath.c_str(), newpath.c_str()); }
inline void CopyFile(std::string& oldpath, std::string& newpath) { SDL::raw::CopyFile(oldpath.c_str(), newpath.c_str()); }
inline void GetPathInfo(std::string& path, SDL_PathInfo* info) { SDL::raw::GetPathInfo(path.c_str(), info); }
inline std::vector<std::string> GlobDirectory(std::string& path, std::string& pattern, SDL::GlobFlags flags) { int _count; std::vector<std::string> _items; auto _ret = SDL::raw::GlobDirectory(path.c_str(), pattern.c_str(), flags, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetCurrentDirectory() { return SDL::raw::GetCurrentDirectory(); }
inline bool GPUSupportsShaderFormats(SDL_GPUShaderFormat format_flags, std::string& name) { return SDL::raw::GPUSupportsShaderFormats(format_flags, name.c_str()); }
inline bool GPUSupportsProperties(SDL_PropertiesID props) { return SDL::raw::GPUSupportsProperties(props); }
inline SDL_GPUDevice* CreateGPUDevice(SDL_GPUShaderFormat format_flags, bool debug_mode, std::string& name) { return SDL::raw::CreateGPUDevice(format_flags, debug_mode, name.c_str()); }
inline SDL_GPUDevice* CreateGPUDeviceWithProperties(SDL_PropertiesID props) { return SDL::raw::CreateGPUDeviceWithProperties(props); }
inline void DestroyGPUDevice(SDL_GPUDevice* device) { SDL::raw::DestroyGPUDevice(device); }
inline int GetNumGPUDrivers() { return SDL::raw::GetNumGPUDrivers(); }
inline std::string GetGPUDriver(int index) { return SDL::raw::GetGPUDriver(index); }
inline std::string GetGPUDeviceDriver(SDL_GPUDevice* device) { return SDL::raw::GetGPUDeviceDriver(device); }
inline SDL_GPUShaderFormat GetGPUShaderFormats(SDL_GPUDevice* device) { return SDL::raw::GetGPUShaderFormats(device); }
inline SDL_GPUComputePipeline* CreateGPUComputePipeline(SDL_GPUDevice* device, const SDL_GPUComputePipelineCreateInfo* createinfo) { return SDL::raw::CreateGPUComputePipeline(device, createinfo); }
inline SDL_GPUGraphicsPipeline* CreateGPUGraphicsPipeline(SDL_GPUDevice* device, const SDL_GPUGraphicsPipelineCreateInfo* createinfo) { return SDL::raw::CreateGPUGraphicsPipeline(device, createinfo); }
inline SDL_GPUSampler* CreateGPUSampler(SDL_GPUDevice* device, const SDL_GPUSamplerCreateInfo* createinfo) { return SDL::raw::CreateGPUSampler(device, createinfo); }
inline SDL_GPUShader* CreateGPUShader(SDL_GPUDevice* device, const SDL_GPUShaderCreateInfo* createinfo) { return SDL::raw::CreateGPUShader(device, createinfo); }
inline SDL_GPUTexture* CreateGPUTexture(SDL_GPUDevice* device, const SDL_GPUTextureCreateInfo* createinfo) { return SDL::raw::CreateGPUTexture(device, createinfo); }
inline SDL_GPUBuffer* CreateGPUBuffer(SDL_GPUDevice* device, const SDL_GPUBufferCreateInfo* createinfo) { return SDL::raw::CreateGPUBuffer(device, createinfo); }
inline SDL_GPUTransferBuffer* CreateGPUTransferBuffer(SDL_GPUDevice* device, const SDL_GPUTransferBufferCreateInfo* createinfo) { return SDL::raw::CreateGPUTransferBuffer(device, createinfo); }
inline void SetGPUBufferName(SDL_GPUDevice* device, SDL_GPUBuffer* buffer, std::string& text) { SDL::raw::SetGPUBufferName(device, buffer, text.c_str()); }
inline void SetGPUTextureName(SDL_GPUDevice* device, SDL_GPUTexture* texture, std::string& text) { SDL::raw::SetGPUTextureName(device, texture, text.c_str()); }
inline void InsertGPUDebugLabel(SDL_GPUCommandBuffer* command_buffer, std::string& text) { SDL::raw::InsertGPUDebugLabel(command_buffer, text.c_str()); }
inline void PushGPUDebugGroup(SDL_GPUCommandBuffer* command_buffer, std::string& name) { SDL::raw::PushGPUDebugGroup(command_buffer, name.c_str()); }
inline void PopGPUDebugGroup(SDL_GPUCommandBuffer* command_buffer) { SDL::raw::PopGPUDebugGroup(command_buffer); }
inline void ReleaseGPUTexture(SDL_GPUDevice* device, SDL_GPUTexture* texture) { SDL::raw::ReleaseGPUTexture(device, texture); }
inline void ReleaseGPUSampler(SDL_GPUDevice* device, SDL_GPUSampler* sampler) { SDL::raw::ReleaseGPUSampler(device, sampler); }
inline void ReleaseGPUBuffer(SDL_GPUDevice* device, SDL_GPUBuffer* buffer) { SDL::raw::ReleaseGPUBuffer(device, buffer); }
inline void ReleaseGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer) { SDL::raw::ReleaseGPUTransferBuffer(device, transfer_buffer); }
inline void ReleaseGPUComputePipeline(SDL_GPUDevice* device, SDL_GPUComputePipeline* compute_pipeline) { SDL::raw::ReleaseGPUComputePipeline(device, compute_pipeline); }
inline void ReleaseGPUShader(SDL_GPUDevice* device, SDL_GPUShader* shader) { SDL::raw::ReleaseGPUShader(device, shader); }
inline void ReleaseGPUGraphicsPipeline(SDL_GPUDevice* device, SDL_GPUGraphicsPipeline* graphics_pipeline) { SDL::raw::ReleaseGPUGraphicsPipeline(device, graphics_pipeline); }
inline SDL_GPUCommandBuffer* AcquireGPUCommandBuffer(SDL_GPUDevice* device) { return SDL::raw::AcquireGPUCommandBuffer(device); }
inline void PushGPUVertexUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL::raw::PushGPUVertexUniformData(command_buffer, slot_index, data, length); }
inline void PushGPUFragmentUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL::raw::PushGPUFragmentUniformData(command_buffer, slot_index, data, length); }
inline void PushGPUComputeUniformData(SDL_GPUCommandBuffer* command_buffer, Uint32 slot_index, const void* data, Uint32 length) { SDL::raw::PushGPUComputeUniformData(command_buffer, slot_index, data, length); }
inline SDL_GPURenderPass* BeginGPURenderPass(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUColorTargetInfo* color_target_infos, Uint32 num_color_targets, const SDL_GPUDepthStencilTargetInfo* depth_stencil_target_info) { return SDL::raw::BeginGPURenderPass(command_buffer, color_target_infos, num_color_targets, depth_stencil_target_info); }
inline void BindGPUGraphicsPipeline(SDL_GPURenderPass* render_pass, SDL_GPUGraphicsPipeline* graphics_pipeline) { SDL::raw::BindGPUGraphicsPipeline(render_pass, graphics_pipeline); }
inline void SetGPUViewport(SDL_GPURenderPass* render_pass, const SDL_GPUViewport* viewport) { SDL::raw::SetGPUViewport(render_pass, viewport); }
inline void SetGPUScissor(SDL_GPURenderPass* render_pass, const SDL::Rect& scissor) { SDL::raw::SetGPUScissor(render_pass, &scissor); }
inline void SetGPUBlendConstants(SDL_GPURenderPass* render_pass, SDL_FColor blend_constants) { SDL::raw::SetGPUBlendConstants(render_pass, blend_constants); }
inline void SetGPUStencilReference(SDL_GPURenderPass* render_pass, Uint8 reference) { SDL::raw::SetGPUStencilReference(render_pass, reference); }
inline void BindGPUVertexBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUBufferBinding* bindings, Uint32 num_bindings) { SDL::raw::BindGPUVertexBuffers(render_pass, first_slot, bindings, num_bindings); }
inline void BindGPUIndexBuffer(SDL_GPURenderPass* render_pass, const SDL_GPUBufferBinding* binding, SDL_GPUIndexElementSize index_element_size) { SDL::raw::BindGPUIndexBuffer(render_pass, binding, index_element_size); }
inline void BindGPUVertexSamplers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL::raw::BindGPUVertexSamplers(render_pass, first_slot, texture_sampler_bindings, num_bindings); }
inline void BindGPUVertexStorageTextures(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL::raw::BindGPUVertexStorageTextures(render_pass, first_slot, storage_textures, num_bindings); }
inline void BindGPUVertexStorageBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL::raw::BindGPUVertexStorageBuffers(render_pass, first_slot, storage_buffers, num_bindings); }
inline void BindGPUFragmentSamplers(SDL_GPURenderPass* render_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL::raw::BindGPUFragmentSamplers(render_pass, first_slot, texture_sampler_bindings, num_bindings); }
inline void BindGPUFragmentStorageTextures(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL::raw::BindGPUFragmentStorageTextures(render_pass, first_slot, storage_textures, num_bindings); }
inline void BindGPUFragmentStorageBuffers(SDL_GPURenderPass* render_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL::raw::BindGPUFragmentStorageBuffers(render_pass, first_slot, storage_buffers, num_bindings); }
inline void DrawGPUIndexedPrimitives(SDL_GPURenderPass* render_pass, Uint32 num_indices, Uint32 num_instances, Uint32 first_index, Sint32 vertex_offset, Uint32 first_instance) { SDL::raw::DrawGPUIndexedPrimitives(render_pass, num_indices, num_instances, first_index, vertex_offset, first_instance); }
inline void DrawGPUPrimitives(SDL_GPURenderPass* render_pass, Uint32 num_vertices, Uint32 num_instances, Uint32 first_vertex, Uint32 first_instance) { SDL::raw::DrawGPUPrimitives(render_pass, num_vertices, num_instances, first_vertex, first_instance); }
inline void DrawGPUPrimitivesIndirect(SDL_GPURenderPass* render_pass, SDL_GPUBuffer* buffer, Uint32 offset, Uint32 draw_count) { SDL::raw::DrawGPUPrimitivesIndirect(render_pass, buffer, offset, draw_count); }
inline void DrawGPUIndexedPrimitivesIndirect(SDL_GPURenderPass* render_pass, SDL_GPUBuffer* buffer, Uint32 offset, Uint32 draw_count) { SDL::raw::DrawGPUIndexedPrimitivesIndirect(render_pass, buffer, offset, draw_count); }
inline void EndGPURenderPass(SDL_GPURenderPass* render_pass) { SDL::raw::EndGPURenderPass(render_pass); }
inline SDL_GPUComputePass* BeginGPUComputePass(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUStorageTextureReadWriteBinding* storage_texture_bindings, Uint32 num_storage_texture_bindings, const SDL_GPUStorageBufferReadWriteBinding* storage_buffer_bindings, Uint32 num_storage_buffer_bindings) { return SDL::raw::BeginGPUComputePass(command_buffer, storage_texture_bindings, num_storage_texture_bindings, storage_buffer_bindings, num_storage_buffer_bindings); }
inline void BindGPUComputePipeline(SDL_GPUComputePass* compute_pass, SDL_GPUComputePipeline* compute_pipeline) { SDL::raw::BindGPUComputePipeline(compute_pass, compute_pipeline); }
inline void BindGPUComputeSamplers(SDL_GPUComputePass* compute_pass, Uint32 first_slot, const SDL_GPUTextureSamplerBinding* texture_sampler_bindings, Uint32 num_bindings) { SDL::raw::BindGPUComputeSamplers(compute_pass, first_slot, texture_sampler_bindings, num_bindings); }
inline void BindGPUComputeStorageTextures(SDL_GPUComputePass* compute_pass, Uint32 first_slot, SDL_GPUTexture** storage_textures, Uint32 num_bindings) { SDL::raw::BindGPUComputeStorageTextures(compute_pass, first_slot, storage_textures, num_bindings); }
inline void BindGPUComputeStorageBuffers(SDL_GPUComputePass* compute_pass, Uint32 first_slot, SDL_GPUBuffer** storage_buffers, Uint32 num_bindings) { SDL::raw::BindGPUComputeStorageBuffers(compute_pass, first_slot, storage_buffers, num_bindings); }
inline void DispatchGPUCompute(SDL_GPUComputePass* compute_pass, Uint32 groupcount_x, Uint32 groupcount_y, Uint32 groupcount_z) { SDL::raw::DispatchGPUCompute(compute_pass, groupcount_x, groupcount_y, groupcount_z); }
inline void DispatchGPUComputeIndirect(SDL_GPUComputePass* compute_pass, SDL_GPUBuffer* buffer, Uint32 offset) { SDL::raw::DispatchGPUComputeIndirect(compute_pass, buffer, offset); }
inline void EndGPUComputePass(SDL_GPUComputePass* compute_pass) { SDL::raw::EndGPUComputePass(compute_pass); }
inline void* MapGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer, bool cycle) { return SDL::raw::MapGPUTransferBuffer(device, transfer_buffer, cycle); }
inline void UnmapGPUTransferBuffer(SDL_GPUDevice* device, SDL_GPUTransferBuffer* transfer_buffer) { SDL::raw::UnmapGPUTransferBuffer(device, transfer_buffer); }
inline SDL_GPUCopyPass* BeginGPUCopyPass(SDL_GPUCommandBuffer* command_buffer) { return SDL::raw::BeginGPUCopyPass(command_buffer); }
inline void UploadToGPUTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureTransferInfo* source, const SDL_GPUTextureRegion* destination, bool cycle) { SDL::raw::UploadToGPUTexture(copy_pass, source, destination, cycle); }
inline void UploadToGPUBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUTransferBufferLocation* source, const SDL_GPUBufferRegion* destination, bool cycle) { SDL::raw::UploadToGPUBuffer(copy_pass, source, destination, cycle); }
inline void CopyGPUTextureToTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureLocation* source, const SDL_GPUTextureLocation* destination, Uint32 w, Uint32 h, Uint32 d, bool cycle) { SDL::raw::CopyGPUTextureToTexture(copy_pass, source, destination, w, h, d, cycle); }
inline void CopyGPUBufferToBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUBufferLocation* source, const SDL_GPUBufferLocation* destination, Uint32 size, bool cycle) { SDL::raw::CopyGPUBufferToBuffer(copy_pass, source, destination, size, cycle); }
inline void DownloadFromGPUTexture(SDL_GPUCopyPass* copy_pass, const SDL_GPUTextureRegion* source, const SDL_GPUTextureTransferInfo* destination) { SDL::raw::DownloadFromGPUTexture(copy_pass, source, destination); }
inline void DownloadFromGPUBuffer(SDL_GPUCopyPass* copy_pass, const SDL_GPUBufferRegion* source, const SDL_GPUTransferBufferLocation* destination) { SDL::raw::DownloadFromGPUBuffer(copy_pass, source, destination); }
inline void EndGPUCopyPass(SDL_GPUCopyPass* copy_pass) { SDL::raw::EndGPUCopyPass(copy_pass); }
inline void GenerateMipmapsForGPUTexture(SDL_GPUCommandBuffer* command_buffer, SDL_GPUTexture* texture) { SDL::raw::GenerateMipmapsForGPUTexture(command_buffer, texture); }
inline void BlitGPUTexture(SDL_GPUCommandBuffer* command_buffer, const SDL_GPUBlitInfo* info) { SDL::raw::BlitGPUTexture(command_buffer, info); }
inline bool WindowSupportsGPUSwapchainComposition(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window, SDL_GPUSwapchainComposition swapchain_composition) { return SDL::raw::WindowSupportsGPUSwapchainComposition(device, window->get(), swapchain_composition); }
inline bool WindowSupportsGPUPresentMode(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window, SDL_GPUPresentMode present_mode) { return SDL::raw::WindowSupportsGPUPresentMode(device, window->get(), present_mode); }
inline void ClaimWindowForGPUDevice(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window) { SDL::raw::ClaimWindowForGPUDevice(device, window->get()); }
inline void ReleaseWindowFromGPUDevice(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window) { SDL::raw::ReleaseWindowFromGPUDevice(device, window->get()); }
inline void SetGPUSwapchainParameters(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window, SDL_GPUSwapchainComposition swapchain_composition, SDL_GPUPresentMode present_mode) { SDL::raw::SetGPUSwapchainParameters(device, window->get(), swapchain_composition, present_mode); }
inline void SetGPUAllowedFramesInFlight(SDL_GPUDevice* device, Uint32 allowed_frames_in_flight) { SDL::raw::SetGPUAllowedFramesInFlight(device, allowed_frames_in_flight); }
inline SDL_GPUTextureFormat GetGPUSwapchainTextureFormat(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window) { return SDL::raw::GetGPUSwapchainTextureFormat(device, window->get()); }
inline void AcquireGPUSwapchainTexture(SDL_GPUCommandBuffer* command_buffer, std::shared_ptr<SDL::Window> window, SDL_GPUTexture** swapchain_texture, Uint32* swapchain_texture_width, Uint32* swapchain_texture_height) { SDL::raw::AcquireGPUSwapchainTexture(command_buffer, window->get(), swapchain_texture, swapchain_texture_width, swapchain_texture_height); }
inline void WaitForGPUSwapchain(SDL_GPUDevice* device, std::shared_ptr<SDL::Window> window) { SDL::raw::WaitForGPUSwapchain(device, window->get()); }
inline void WaitAndAcquireGPUSwapchainTexture(SDL_GPUCommandBuffer* command_buffer, std::shared_ptr<SDL::Window> window, SDL_GPUTexture** swapchain_texture, Uint32* swapchain_texture_width, Uint32* swapchain_texture_height) { SDL::raw::WaitAndAcquireGPUSwapchainTexture(command_buffer, window->get(), swapchain_texture, swapchain_texture_width, swapchain_texture_height); }
inline void SubmitGPUCommandBuffer(SDL_GPUCommandBuffer* command_buffer) { SDL::raw::SubmitGPUCommandBuffer(command_buffer); }
inline SDL_GPUFence* SubmitGPUCommandBufferAndAcquireFence(SDL_GPUCommandBuffer* command_buffer) { return SDL::raw::SubmitGPUCommandBufferAndAcquireFence(command_buffer); }
inline void CancelGPUCommandBuffer(SDL_GPUCommandBuffer* command_buffer) { SDL::raw::CancelGPUCommandBuffer(command_buffer); }
inline void WaitForGPUIdle(SDL_GPUDevice* device) { SDL::raw::WaitForGPUIdle(device); }
inline void WaitForGPUFences(SDL_GPUDevice* device, bool wait_all, SDL_GPUFence** fences, Uint32 num_fences) { SDL::raw::WaitForGPUFences(device, wait_all, fences, num_fences); }
inline bool QueryGPUFence(SDL_GPUDevice* device, SDL_GPUFence* fence) { return SDL::raw::QueryGPUFence(device, fence); }
inline void ReleaseGPUFence(SDL_GPUDevice* device, SDL_GPUFence* fence) { SDL::raw::ReleaseGPUFence(device, fence); }
inline Uint32 GPUTextureFormatTexelBlockSize(SDL_GPUTextureFormat format) { return SDL::raw::GPUTextureFormatTexelBlockSize(format); }
inline bool GPUTextureSupportsFormat(SDL_GPUDevice* device, SDL_GPUTextureFormat format, SDL_GPUTextureType type, SDL::GPUTextureUsageFlags usage) { return SDL::raw::GPUTextureSupportsFormat(device, format, type, usage); }
inline bool GPUTextureSupportsSampleCount(SDL_GPUDevice* device, SDL_GPUTextureFormat format, SDL_GPUSampleCount sample_count) { return SDL::raw::GPUTextureSupportsSampleCount(device, format, sample_count); }
inline Uint32 CalculateGPUTextureFormatSize(SDL_GPUTextureFormat format, Uint32 width, Uint32 height, Uint32 depth_or_layer_count) { return SDL::raw::CalculateGPUTextureFormatSize(format, width, height, depth_or_layer_count); }
inline std::vector<SDL_HapticID> GetHaptics() { int _count; std::vector<SDL_HapticID> _items; auto _ret = SDL::raw::GetHaptics(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline std::string GetHapticNameForID(SDL_HapticID instance_id) { return SDL::raw::GetHapticNameForID(instance_id); }
inline SDL_Haptic* OpenHaptic(SDL_HapticID instance_id) { return SDL::raw::OpenHaptic(instance_id); }
inline SDL_Haptic* GetHapticFromID(SDL_HapticID instance_id) { return SDL::raw::GetHapticFromID(instance_id); }
inline SDL_HapticID GetHapticID(SDL_Haptic* haptic) { return SDL::raw::GetHapticID(haptic); }
inline std::string GetHapticName(SDL_Haptic* haptic) { return SDL::raw::GetHapticName(haptic); }
inline bool IsMouseHaptic() { return SDL::raw::IsMouseHaptic(); }
inline SDL_Haptic* OpenHapticFromMouse() { return SDL::raw::OpenHapticFromMouse(); }
inline bool IsJoystickHaptic(SDL_Joystick* joystick) { return SDL::raw::IsJoystickHaptic(joystick); }
inline SDL_Haptic* OpenHapticFromJoystick(SDL_Joystick* joystick) { return SDL::raw::OpenHapticFromJoystick(joystick); }
inline void CloseHaptic(SDL_Haptic* haptic) { SDL::raw::CloseHaptic(haptic); }
inline int GetMaxHapticEffects(SDL_Haptic* haptic) { return SDL::raw::GetMaxHapticEffects(haptic); }
inline int GetMaxHapticEffectsPlaying(SDL_Haptic* haptic) { return SDL::raw::GetMaxHapticEffectsPlaying(haptic); }
inline Uint32 GetHapticFeatures(SDL_Haptic* haptic) { return SDL::raw::GetHapticFeatures(haptic); }
inline int GetNumHapticAxes(SDL_Haptic* haptic) { return SDL::raw::GetNumHapticAxes(haptic); }
inline bool HapticEffectSupported(SDL_Haptic* haptic, const SDL_HapticEffect* effect) { return SDL::raw::HapticEffectSupported(haptic, effect); }
inline int CreateHapticEffect(SDL_Haptic* haptic, const SDL_HapticEffect* effect) { return SDL::raw::CreateHapticEffect(haptic, effect); }
inline void UpdateHapticEffect(SDL_Haptic* haptic, int effect, const SDL_HapticEffect* data) { SDL::raw::UpdateHapticEffect(haptic, effect, data); }
inline void RunHapticEffect(SDL_Haptic* haptic, int effect, Uint32 iterations) { SDL::raw::RunHapticEffect(haptic, effect, iterations); }
inline void StopHapticEffect(SDL_Haptic* haptic, int effect) { SDL::raw::StopHapticEffect(haptic, effect); }
inline void DestroyHapticEffect(SDL_Haptic* haptic, int effect) { SDL::raw::DestroyHapticEffect(haptic, effect); }
inline bool GetHapticEffectStatus(SDL_Haptic* haptic, int effect) { return SDL::raw::GetHapticEffectStatus(haptic, effect); }
inline void SetHapticGain(SDL_Haptic* haptic, int gain) { SDL::raw::SetHapticGain(haptic, gain); }
inline void SetHapticAutocenter(SDL_Haptic* haptic, int autocenter) { SDL::raw::SetHapticAutocenter(haptic, autocenter); }
inline void PauseHaptic(SDL_Haptic* haptic) { SDL::raw::PauseHaptic(haptic); }
inline void ResumeHaptic(SDL_Haptic* haptic) { SDL::raw::ResumeHaptic(haptic); }
inline void StopHapticEffects(SDL_Haptic* haptic) { SDL::raw::StopHapticEffects(haptic); }
inline bool HapticRumbleSupported(SDL_Haptic* haptic) { return SDL::raw::HapticRumbleSupported(haptic); }
inline void InitHapticRumble(SDL_Haptic* haptic) { SDL::raw::InitHapticRumble(haptic); }
inline void PlayHapticRumble(SDL_Haptic* haptic, float strength, Uint32 length) { SDL::raw::PlayHapticRumble(haptic, strength, length); }
inline void StopHapticRumble(SDL_Haptic* haptic) { SDL::raw::StopHapticRumble(haptic); }
inline int hid_init() { return SDL::raw::hid_init(); }
inline int hid_exit() { return SDL::raw::hid_exit(); }
inline Uint32 hid_device_change_count() { return SDL::raw::hid_device_change_count(); }
inline SDL_hid_device_info* hid_enumerate(unsigned short vendor_id, unsigned short product_id) { return SDL::raw::hid_enumerate(vendor_id, product_id); }
inline void hid_free_enumeration(SDL_hid_device_info* devs) { SDL::raw::hid_free_enumeration(devs); }
inline SDL_hid_device* hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t* serial_number) { return SDL::raw::hid_open(vendor_id, product_id, serial_number); }
inline SDL_hid_device* hid_open_path(std::string& path) { return SDL::raw::hid_open_path(path.c_str()); }
inline int hid_write(SDL_hid_device* dev, std::string& data, size_t length) { return SDL::raw::hid_write(dev, data.c_str(), length); }
inline int hid_read_timeout(SDL_hid_device* dev, std::string& data, size_t length, int milliseconds) { return SDL::raw::hid_read_timeout(dev, data.c_str(), length, milliseconds); }
inline int hid_read(SDL_hid_device* dev, std::string& data, size_t length) { return SDL::raw::hid_read(dev, data.c_str(), length); }
inline int hid_set_nonblocking(SDL_hid_device* dev, int nonblock) { return SDL::raw::hid_set_nonblocking(dev, nonblock); }
inline int hid_send_feature_report(SDL_hid_device* dev, std::string& data, size_t length) { return SDL::raw::hid_send_feature_report(dev, data.c_str(), length); }
inline int hid_get_feature_report(SDL_hid_device* dev, std::string& data, size_t length) { return SDL::raw::hid_get_feature_report(dev, data.c_str(), length); }
inline int hid_get_input_report(SDL_hid_device* dev, std::string& data, size_t length) { return SDL::raw::hid_get_input_report(dev, data.c_str(), length); }
inline int hid_close(SDL_hid_device* dev) { return SDL::raw::hid_close(dev); }
inline int hid_get_manufacturer_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { return SDL::raw::hid_get_manufacturer_string(dev, string, maxlen); }
inline int hid_get_product_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { return SDL::raw::hid_get_product_string(dev, string, maxlen); }
inline int hid_get_serial_number_string(SDL_hid_device* dev, wchar_t* string, size_t maxlen) { return SDL::raw::hid_get_serial_number_string(dev, string, maxlen); }
inline int hid_get_indexed_string(SDL_hid_device* dev, int string_index, wchar_t* string, size_t maxlen) { return SDL::raw::hid_get_indexed_string(dev, string_index, string, maxlen); }
inline SDL_hid_device_info* hid_get_device_info(SDL_hid_device* dev) { return SDL::raw::hid_get_device_info(dev); }
inline int hid_get_report_descriptor(SDL_hid_device* dev, std::string& buf, size_t buf_size) { return SDL::raw::hid_get_report_descriptor(dev, buf.c_str(), buf_size); }
inline void hid_ble_scan(bool active) { SDL::raw::hid_ble_scan(active); }
inline void SetHintWithPriority(std::string& name, std::string& value, SDL_HintPriority priority) { SDL::raw::SetHintWithPriority(name.c_str(), value.c_str(), priority); }
inline void SetHint(std::string& name, std::string& value) { SDL::raw::SetHint(name.c_str(), value.c_str()); }
inline void ResetHint(std::string& name) { SDL::raw::ResetHint(name.c_str()); }
inline void ResetHints() { SDL::raw::ResetHints(); }
inline std::string GetHint(std::string& name) { return SDL::raw::GetHint(name.c_str()); }
inline bool GetHintBoolean(std::string& name, bool default_value) { return SDL::raw::GetHintBoolean(name.c_str(), default_value); }
inline void AddHintCallback(std::string& name, SDL_HintCallback callback, void* userdata) { SDL::raw::AddHintCallback(name.c_str(), callback, userdata); }
inline void RemoveHintCallback(std::string& name, SDL_HintCallback callback, void* userdata) { SDL::raw::RemoveHintCallback(name.c_str(), callback, userdata); }
inline void Init(SDL::InitFlags flags) { SDL::raw::Init(flags); }
inline void InitSubSystem(SDL::InitFlags flags) { SDL::raw::InitSubSystem(flags); }
inline void QuitSubSystem(SDL::InitFlags flags) { SDL::raw::QuitSubSystem(flags); }
inline SDL::InitFlags WasInit(SDL::InitFlags flags) { return (SDL::InitFlags) SDL::raw::WasInit(flags); }
inline void Quit() { SDL::raw::Quit(); }
inline bool IsMainThread() { return SDL::raw::IsMainThread(); }
inline void RunOnMainThread(SDL_MainThreadCallback callback, void* userdata, bool wait_complete) { SDL::raw::RunOnMainThread(callback, userdata, wait_complete); }
inline void SetAppMetadata(std::string& appname, std::string& appversion, std::string& appidentifier) { SDL::raw::SetAppMetadata(appname.c_str(), appversion.c_str(), appidentifier.c_str()); }
inline void SetAppMetadataProperty(std::string& name, std::string& value) { SDL::raw::SetAppMetadataProperty(name.c_str(), value.c_str()); }
inline std::string GetAppMetadataProperty(std::string& name) { return SDL::raw::GetAppMetadataProperty(name.c_str()); }
inline SDL_SharedObject* LoadObject(std::string& sofile) { return SDL::raw::LoadObject(sofile.c_str()); }
inline SDL_FunctionPointer LoadFunction(SDL_SharedObject* handle, std::string& name) { return SDL::raw::LoadFunction(handle, name.c_str()); }
inline void UnloadObject(SDL_SharedObject* handle) { SDL::raw::UnloadObject(handle); }
inline std::vector<SDL_Locale*> GetPreferredLocales() { int _count; std::vector<SDL_Locale*> _items; auto _ret = SDL::raw::GetPreferredLocales(&_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline void SetLogPriorities(SDL_LogPriority priority) { SDL::raw::SetLogPriorities(priority); }
inline void SetLogPriority(int category, SDL_LogPriority priority) { SDL::raw::SetLogPriority(category, priority); }
inline SDL_LogPriority GetLogPriority(int category) { return SDL::raw::GetLogPriority(category); }
inline void ResetLogPriorities() { SDL::raw::ResetLogPriorities(); }
inline void SetLogPriorityPrefix(SDL_LogPriority priority, std::string& prefix) { SDL::raw::SetLogPriorityPrefix(priority, prefix.c_str()); }
inline void LogMessageV(int category, SDL_LogPriority priority, std::string& fmt, va_list ap) { SDL::raw::LogMessageV(category, priority, fmt.c_str(), ap); }
inline SDL_LogOutputFunction GetDefaultLogOutputFunction() { return SDL::raw::GetDefaultLogOutputFunction(); }
inline void GetLogOutputFunction(SDL_LogOutputFunction* callback, void** userdata) { SDL::raw::GetLogOutputFunction(callback, userdata); }
inline void SetLogOutputFunction(SDL_LogOutputFunction callback, void* userdata) { SDL::raw::SetLogOutputFunction(callback, userdata); }
inline void ShowMessageBox(const SDL_MessageBoxData* messageboxdata, int* buttonid) { SDL::raw::ShowMessageBox(messageboxdata, buttonid); }
inline void ShowSimpleMessageBox(SDL::MessageBoxFlags flags, std::string& title, std::string& message, std::shared_ptr<SDL::Window> window) { SDL::raw::ShowSimpleMessageBox(flags, title.c_str(), message.c_str(), window->get()); }
inline void Metal_DestroyView(SDL_MetalView view) { SDL::raw::Metal_DestroyView(view); }
inline void* Metal_GetLayer(SDL_MetalView view) { return SDL::raw::Metal_GetLayer(view); }
inline void OpenURL(std::string& url) { SDL::raw::OpenURL(url.c_str()); }
inline std::string GetPlatform() { return SDL::raw::GetPlatform(); }
inline SDL_Process* CreateProcess(std::string& args, bool pipe_stdio) { return SDL::raw::CreateProcess(args, pipe_stdio); }
inline SDL_Process* CreateProcessWithProperties(SDL_PropertiesID props) { return SDL::raw::CreateProcessWithProperties(props); }
inline SDL_PropertiesID GetProcessProperties(SDL_Process* process) { return SDL::raw::GetProcessProperties(process); }
inline void* ReadProcess(SDL_Process* process, size_t* datasize, int* exitcode) { return SDL::raw::ReadProcess(process, datasize, exitcode); }
inline SDL_IOStream* GetProcessInput(SDL_Process* process) { return SDL::raw::GetProcessInput(process); }
inline SDL_IOStream* GetProcessOutput(SDL_Process* process) { return SDL::raw::GetProcessOutput(process); }
inline void KillProcess(SDL_Process* process, bool force) { SDL::raw::KillProcess(process, force); }
inline bool WaitProcess(SDL_Process* process, bool block, int* exitcode) { return SDL::raw::WaitProcess(process, block, exitcode); }
inline void DestroyProcess(SDL_Process* process) { SDL::raw::DestroyProcess(process); }
inline int GetNumRenderDrivers() { return SDL::raw::GetNumRenderDrivers(); }
inline std::string GetRenderDriver(int index) { return SDL::raw::GetRenderDriver(index); }
inline void CreateWindowAndRenderer(std::string& title, int width, int height, SDL::WindowFlags window_flags, std::shared_ptr<SDL::Window> window, std::shared_ptr<SDL::Renderer> renderer) { SDL::raw::CreateWindowAndRenderer(title.c_str(), width, height, window_flags, window->get(), renderer->get()); }
inline std::shared_ptr<SDL::Renderer> CreateRendererWithProperties(SDL_PropertiesID props) { return SDL::Renderer::get(SDL::raw::CreateRendererWithProperties(props)); }
inline void DestroyTexture(std::shared_ptr<SDL::Texture> texture) { SDL::raw::DestroyTexture(texture->get()); }
inline void DestroyRenderer(std::shared_ptr<SDL::Renderer> renderer) { SDL::raw::DestroyRenderer(renderer->get()); }
inline SDL_Storage* OpenTitleStorage(std::string& override, SDL_PropertiesID props) { return SDL::raw::OpenTitleStorage(override.c_str(), props); }
inline SDL_Storage* OpenUserStorage(std::string& org, std::string& app, SDL_PropertiesID props) { return SDL::raw::OpenUserStorage(org.c_str(), app.c_str(), props); }
inline SDL_Storage* OpenFileStorage(std::string& path) { return SDL::raw::OpenFileStorage(path.c_str()); }
inline SDL_Storage* OpenStorage(const SDL_StorageInterface* iface, void* userdata) { return SDL::raw::OpenStorage(iface, userdata); }
inline void CloseStorage(SDL_Storage* storage) { SDL::raw::CloseStorage(storage); }
inline bool StorageReady(SDL_Storage* storage) { return SDL::raw::StorageReady(storage); }
inline void GetStorageFileSize(SDL_Storage* storage, std::string& path, Uint64* length) { SDL::raw::GetStorageFileSize(storage, path.c_str(), length); }
inline void ReadStorageFile(SDL_Storage* storage, std::string& path, void* destination, Uint64 length) { SDL::raw::ReadStorageFile(storage, path.c_str(), destination, length); }
inline void WriteStorageFile(SDL_Storage* storage, std::string& path, const void* source, Uint64 length) { SDL::raw::WriteStorageFile(storage, path.c_str(), source, length); }
inline void CreateStorageDirectory(SDL_Storage* storage, std::string& path) { SDL::raw::CreateStorageDirectory(storage, path.c_str()); }
inline void EnumerateStorageDirectory(SDL_Storage* storage, std::string& path, SDL_EnumerateDirectoryCallback callback, void* userdata) { SDL::raw::EnumerateStorageDirectory(storage, path.c_str(), callback, userdata); }
inline void RemoveStoragePath(SDL_Storage* storage, std::string& path) { SDL::raw::RemoveStoragePath(storage, path.c_str()); }
inline void RenameStoragePath(SDL_Storage* storage, std::string& oldpath, std::string& newpath) { SDL::raw::RenameStoragePath(storage, oldpath.c_str(), newpath.c_str()); }
inline void CopyStorageFile(SDL_Storage* storage, std::string& oldpath, std::string& newpath) { SDL::raw::CopyStorageFile(storage, oldpath.c_str(), newpath.c_str()); }
inline void GetStoragePathInfo(SDL_Storage* storage, std::string& path, SDL_PathInfo* info) { SDL::raw::GetStoragePathInfo(storage, path.c_str(), info); }
inline Uint64 GetStorageSpaceRemaining(SDL_Storage* storage) { return SDL::raw::GetStorageSpaceRemaining(storage); }
inline std::vector<std::string> GlobStorageDirectory(SDL_Storage* storage, std::string& path, std::string& pattern, SDL::GlobFlags flags) { int _count; std::vector<std::string> _items; auto _ret = SDL::raw::GlobStorageDirectory(storage, path.c_str(), pattern.c_str(), flags, &_count); for (int i = 0; i < _count; i++) _items.push_back(_ret[i]); return _items; }
inline void SetX11EventHook(SDL_X11EventHook callback, void* userdata) { SDL::raw::SetX11EventHook(callback, userdata); }
inline bool IsTablet() { return SDL::raw::IsTablet(); }
inline bool IsTV() { return SDL::raw::IsTV(); }
inline SDL_Sandbox GetSandbox() { return SDL::raw::GetSandbox(); }
inline void OnApplicationWillTerminate() { SDL::raw::OnApplicationWillTerminate(); }
inline void OnApplicationDidReceiveMemoryWarning() { SDL::raw::OnApplicationDidReceiveMemoryWarning(); }
inline void OnApplicationWillEnterBackground() { SDL::raw::OnApplicationWillEnterBackground(); }
inline void OnApplicationDidEnterBackground() { SDL::raw::OnApplicationDidEnterBackground(); }
inline void OnApplicationWillEnterForeground() { SDL::raw::OnApplicationWillEnterForeground(); }
inline void OnApplicationDidEnterForeground() { SDL::raw::OnApplicationDidEnterForeground(); }
inline void GetDateTimeLocalePreferences(SDL_DateFormat* dateFormat, SDL_TimeFormat* timeFormat) { SDL::raw::GetDateTimeLocalePreferences(dateFormat, timeFormat); }
inline SDL_Time GetCurrentTime() { SDL_Time _out; SDL::raw::GetCurrentTime(&_out); return _out; }
inline void TimeToDateTime(SDL_Time ticks, SDL_DateTime* dt, bool localTime) { SDL::raw::TimeToDateTime(ticks, dt, localTime); }
inline void DateTimeToTime(const SDL_DateTime* dt, SDL_Time* ticks) { SDL::raw::DateTimeToTime(dt, ticks); }
inline void TimeToWindows(SDL_Time ticks, Uint32* dwLowDateTime, Uint32* dwHighDateTime) { SDL::raw::TimeToWindows(ticks, dwLowDateTime, dwHighDateTime); }
inline SDL_Time TimeFromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime) { return SDL::raw::TimeFromWindows(dwLowDateTime, dwHighDateTime); }
inline int GetDaysInMonth(int year, int month) { return SDL::raw::GetDaysInMonth(year, month); }
inline int GetDayOfYear(int year, int month, int day) { return SDL::raw::GetDayOfYear(year, month, day); }
inline int GetDayOfWeek(int year, int month, int day) { return SDL::raw::GetDayOfWeek(year, month, day); }
inline Uint64 GetTicks() { return SDL::raw::GetTicks(); }
inline Uint64 GetTicksNS() { return SDL::raw::GetTicksNS(); }
inline Uint64 GetPerformanceCounter() { return SDL::raw::GetPerformanceCounter(); }
inline Uint64 GetPerformanceFrequency() { return SDL::raw::GetPerformanceFrequency(); }
inline void Delay(Uint32 ms) { SDL::raw::Delay(ms); }
inline void DelayNS(Uint64 ns) { SDL::raw::DelayNS(ns); }
inline void DelayPrecise(Uint64 ns) { SDL::raw::DelayPrecise(ns); }
inline SDL_TimerID AddTimer(Uint32 interval, SDL_TimerCallback callback, void* userdata) { return SDL::raw::AddTimer(interval, callback, userdata); }
inline SDL_TimerID AddTimerNS(Uint64 interval, SDL_NSTimerCallback callback, void* userdata) { return SDL::raw::AddTimerNS(interval, callback, userdata); }
inline void RemoveTimer(SDL_TimerID id) { SDL::raw::RemoveTimer(id); }
inline std::shared_ptr<SDL::TrayMenu> CreateTraySubmenu(SDL_TrayEntry* entry) { return SDL::TrayMenu::get(SDL::raw::CreateTraySubmenu(entry)); }
inline std::shared_ptr<SDL::TrayMenu> GetTraySubmenu(SDL_TrayEntry* entry) { return SDL::TrayMenu::get(SDL::raw::GetTraySubmenu(entry)); }
inline void RemoveTrayEntry(SDL_TrayEntry* entry) { SDL::raw::RemoveTrayEntry(entry); }
inline void SetTrayEntryLabel(SDL_TrayEntry* entry, std::string& label) { SDL::raw::SetTrayEntryLabel(entry, label.c_str()); }
inline std::string GetTrayEntryLabel(SDL_TrayEntry* entry) { return SDL::raw::GetTrayEntryLabel(entry); }
inline void SetTrayEntryChecked(SDL_TrayEntry* entry, bool checked) { SDL::raw::SetTrayEntryChecked(entry, checked); }
inline bool GetTrayEntryChecked(SDL_TrayEntry* entry) { return SDL::raw::GetTrayEntryChecked(entry); }
inline void SetTrayEntryEnabled(SDL_TrayEntry* entry, bool enabled) { SDL::raw::SetTrayEntryEnabled(entry, enabled); }
inline bool GetTrayEntryEnabled(SDL_TrayEntry* entry) { return SDL::raw::GetTrayEntryEnabled(entry); }
inline void SetTrayEntryCallback(SDL_TrayEntry* entry, SDL_TrayCallback callback, void* userdata) { SDL::raw::SetTrayEntryCallback(entry, callback, userdata); }
inline void ClickTrayEntry(SDL_TrayEntry* entry) { SDL::raw::ClickTrayEntry(entry); }
inline void DestroyTray(std::shared_ptr<SDL::Tray> tray) { SDL::raw::DestroyTray(tray->get()); }
inline std::shared_ptr<SDL::TrayMenu> GetTrayEntryParent(SDL_TrayEntry* entry) { return SDL::TrayMenu::get(SDL::raw::GetTrayEntryParent(entry)); }
inline void UpdateTrays() { SDL::raw::UpdateTrays(); }
inline int GetVersion() { return SDL::raw::GetVersion(); }
inline std::string GetRevision() { return SDL::raw::GetRevision(); }
}